/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CSITRIX%5C%5COneDrive%5C%5C%D0%A0%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D0%B9%20%D1%81%D1%82%D0%BE%D0%BB%5C%5Cnetavto%5C%5C%D0%9D%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%BF%D0%B0%D0%BF%D0%BA%D0%B0%20(2)%5C%5Csport_club%5C%5Capp%5C%5CClientWrapper.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CSITRIX%5C%5COneDrive%5C%5C%D0%A0%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D0%B9%20%D1%81%D1%82%D0%BE%D0%BB%5C%5Cnetavto%5C%5C%D0%9D%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%BF%D0%B0%D0%BF%D0%BA%D0%B0%20(2)%5C%5Csport_club%5C%5Capp%5C%5Cglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CSITRIX%5C%5COneDrive%5C%5C%D0%A0%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D0%B9%20%D1%81%D1%82%D0%BE%D0%BB%5C%5Cnetavto%5C%5C%D0%9D%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%BF%D0%B0%D0%BF%D0%BA%D0%B0%20(2)%5C%5Csport_club%5C%5Capp%5C%5Cheader.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CSITRIX%5C%5COneDrive%5C%5C%D0%A0%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D0%B9%20%D1%81%D1%82%D0%BE%D0%BB%5C%5Cnetavto%5C%5C%D0%9D%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%BF%D0%B0%D0%BF%D0%BA%D0%B0%20(2)%5C%5Csport_club%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22app%5C%5C%5C%5Clayout.js%5C%22%2C%5C%22import%5C%22%3A%5C%22Inter%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22inter%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CSITRIX%5C%5COneDrive%5C%5C%D0%A0%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D0%B9%20%D1%81%D1%82%D0%BE%D0%BB%5C%5Cnetavto%5C%5C%D0%9D%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%BF%D0%B0%D0%BF%D0%BA%D0%B0%20(2)%5C%5Csport_club%5C%5Capp%5C%5CClientWrapper.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CSITRIX%5C%5COneDrive%5C%5C%D0%A0%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D0%B9%20%D1%81%D1%82%D0%BE%D0%BB%5C%5Cnetavto%5C%5C%D0%9D%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%BF%D0%B0%D0%BF%D0%BA%D0%B0%20(2)%5C%5Csport_club%5C%5Capp%5C%5Cglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CSITRIX%5C%5COneDrive%5C%5C%D0%A0%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D0%B9%20%D1%81%D1%82%D0%BE%D0%BB%5C%5Cnetavto%5C%5C%D0%9D%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%BF%D0%B0%D0%BF%D0%BA%D0%B0%20(2)%5C%5Csport_club%5C%5Capp%5C%5Cheader.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CSITRIX%5C%5COneDrive%5C%5C%D0%A0%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D0%B9%20%D1%81%D1%82%D0%BE%D0%BB%5C%5Cnetavto%5C%5C%D0%9D%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%BF%D0%B0%D0%BF%D0%BA%D0%B0%20(2)%5C%5Csport_club%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22app%5C%5C%5C%5Clayout.js%5C%22%2C%5C%22import%5C%22%3A%5C%22Inter%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22inter%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/ClientWrapper.js */ \"(app-pages-browser)/./app/ClientWrapper.js\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/globals.css */ \"(app-pages-browser)/./app/globals.css\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/header.js */ \"(app-pages-browser)/./app/header.js\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.js\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"inter\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"app\\\\\\\\layout.js\\\",\\\"import\\\":\\\"Inter\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"]}],\\\"variableName\\\":\\\"inter\\\"}\", 23));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDU0lUUklYJTVDJTVDT25lRHJpdmUlNUMlNUMlRDAlQTAlRDAlQjAlRDAlQjElRDAlQkUlRDElODclRDAlQjglRDAlQjklMjAlRDElODElRDElODIlRDAlQkUlRDAlQkIlNUMlNUNuZXRhdnRvJTVDJTVDJUQwJTlEJUQwJUJFJUQwJUIyJUQwJUIwJUQxJThGJTIwJUQwJUJGJUQwJUIwJUQwJUJGJUQwJUJBJUQwJUIwJTIwKDIpJTVDJTVDc3BvcnRfY2x1YiU1QyU1Q2FwcCU1QyU1Q0NsaWVudFdyYXBwZXIuanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJkZWZhdWx0JTIyJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkMlM0ElNUMlNUNVc2VycyU1QyU1Q1NJVFJJWCU1QyU1Q09uZURyaXZlJTVDJTVDJUQwJUEwJUQwJUIwJUQwJUIxJUQwJUJFJUQxJTg3JUQwJUI4JUQwJUI5JTIwJUQxJTgxJUQxJTgyJUQwJUJFJUQwJUJCJTVDJTVDbmV0YXZ0byU1QyU1QyVEMCU5RCVEMCVCRSVEMCVCMiVEMCVCMCVEMSU4RiUyMCVEMCVCRiVEMCVCMCVEMCVCRiVEMCVCQSVEMCVCMCUyMCgyKSU1QyU1Q3Nwb3J0X2NsdWIlNUMlNUNhcHAlNUMlNUNnbG9iYWxzLmNzcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjJDJTNBJTVDJTVDVXNlcnMlNUMlNUNTSVRSSVglNUMlNUNPbmVEcml2ZSU1QyU1QyVEMCVBMCVEMCVCMCVEMCVCMSVEMCVCRSVEMSU4NyVEMCVCOCVEMCVCOSUyMCVEMSU4MSVEMSU4MiVEMCVCRSVEMCVCQiU1QyU1Q25ldGF2dG8lNUMlNUMlRDAlOUQlRDAlQkUlRDAlQjIlRDAlQjAlRDElOEYlMjAlRDAlQkYlRDAlQjAlRDAlQkYlRDAlQkElRDAlQjAlMjAoMiklNUMlNUNzcG9ydF9jbHViJTVDJTVDYXBwJTVDJTVDaGVhZGVyLmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTIyZGVmYXVsdCUyMiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjJDJTNBJTVDJTVDVXNlcnMlNUMlNUNTSVRSSVglNUMlNUNPbmVEcml2ZSU1QyU1QyVEMCVBMCVEMCVCMCVEMCVCMSVEMCVCRSVEMSU4NyVEMCVCOCVEMCVCOSUyMCVEMSU4MSVEMSU4MiVEMCVCRSVEMCVCQiU1QyU1Q25ldGF2dG8lNUMlNUMlRDAlOUQlRDAlQkUlRDAlQjIlRDAlQjAlRDElOEYlMjAlRDAlQkYlRDAlQjAlRDAlQkYlRDAlQkElRDAlQjAlMjAoMiklNUMlNUNzcG9ydF9jbHViJTVDJTVDbm9kZV9tb2R1bGVzJTVDJTVDbmV4dCU1QyU1Q2ZvbnQlNUMlNUNnb29nbGUlNUMlNUN0YXJnZXQuY3NzJTNGJTdCJTVDJTIycGF0aCU1QyUyMiUzQSU1QyUyMmFwcCU1QyU1QyU1QyU1Q2xheW91dC5qcyU1QyUyMiUyQyU1QyUyMmltcG9ydCU1QyUyMiUzQSU1QyUyMkludGVyJTVDJTIyJTJDJTVDJTIyYXJndW1lbnRzJTVDJTIyJTNBJTVCJTdCJTVDJTIyc3Vic2V0cyU1QyUyMiUzQSU1QiU1QyUyMmxhdGluJTVDJTIyJTVEJTdEJTVEJTJDJTVDJTIydmFyaWFibGVOYW1lJTVDJTIyJTNBJTVDJTIyaW50ZXIlNUMlMjIlN0QlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSxzS0FBd0s7QUFDeEs7QUFDQSw0SkFBc0k7QUFDdEk7QUFDQSx3SkFBaUs7QUFDaks7QUFDQSxvYkFBNFIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz85YzAyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiLCB3ZWJwYWNrRXhwb3J0czogW1wiZGVmYXVsdFwiXSAqLyBcIkM6XFxcXFVzZXJzXFxcXFNJVFJJWFxcXFxPbmVEcml2ZVxcXFzQoNCw0LHQvtGH0LjQuSDRgdGC0L7Qu1xcXFxuZXRhdnRvXFxcXNCd0L7QstCw0Y8g0L/QsNC/0LrQsCAoMilcXFxcc3BvcnRfY2x1YlxcXFxhcHBcXFxcQ2xpZW50V3JhcHBlci5qc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcU0lUUklYXFxcXE9uZURyaXZlXFxcXNCg0LDQsdC+0YfQuNC5INGB0YLQvtC7XFxcXG5ldGF2dG9cXFxc0J3QvtCy0LDRjyDQv9Cw0L/QutCwICgyKVxcXFxzcG9ydF9jbHViXFxcXGFwcFxcXFxnbG9iYWxzLmNzc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiLCB3ZWJwYWNrRXhwb3J0czogW1wiZGVmYXVsdFwiXSAqLyBcIkM6XFxcXFVzZXJzXFxcXFNJVFJJWFxcXFxPbmVEcml2ZVxcXFzQoNCw0LHQvtGH0LjQuSDRgdGC0L7Qu1xcXFxuZXRhdnRvXFxcXNCd0L7QstCw0Y8g0L/QsNC/0LrQsCAoMilcXFxcc3BvcnRfY2x1YlxcXFxhcHBcXFxcaGVhZGVyLmpzXCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJDOlxcXFxVc2Vyc1xcXFxTSVRSSVhcXFxcT25lRHJpdmVcXFxc0KDQsNCx0L7Rh9C40Lkg0YHRgtC+0LtcXFxcbmV0YXZ0b1xcXFzQndC+0LLQsNGPINC/0LDQv9C60LAgKDIpXFxcXHNwb3J0X2NsdWJcXFxcbm9kZV9tb2R1bGVzXFxcXG5leHRcXFxcZm9udFxcXFxnb29nbGVcXFxcdGFyZ2V0LmNzcz97XFxcInBhdGhcXFwiOlxcXCJhcHBcXFxcXFxcXGxheW91dC5qc1xcXCIsXFxcImltcG9ydFxcXCI6XFxcIkludGVyXFxcIixcXFwiYXJndW1lbnRzXFxcIjpbe1xcXCJzdWJzZXRzXFxcIjpbXFxcImxhdGluXFxcIl19XSxcXFwidmFyaWFibGVOYW1lXFxcIjpcXFwiaW50ZXJcXFwifVwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CSITRIX%5C%5COneDrive%5C%5C%D0%A0%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D0%B9%20%D1%81%D1%82%D0%BE%D0%BB%5C%5Cnetavto%5C%5C%D0%9D%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%BF%D0%B0%D0%BF%D0%BA%D0%B0%20(2)%5C%5Csport_club%5C%5Capp%5C%5CClientWrapper.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CSITRIX%5C%5COneDrive%5C%5C%D0%A0%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D0%B9%20%D1%81%D1%82%D0%BE%D0%BB%5C%5Cnetavto%5C%5C%D0%9D%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%BF%D0%B0%D0%BF%D0%BA%D0%B0%20(2)%5C%5Csport_club%5C%5Capp%5C%5Cglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CSITRIX%5C%5COneDrive%5C%5C%D0%A0%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D0%B9%20%D1%81%D1%82%D0%BE%D0%BB%5C%5Cnetavto%5C%5C%D0%9D%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%BF%D0%B0%D0%BF%D0%BA%D0%B0%20(2)%5C%5Csport_club%5C%5Capp%5C%5Cheader.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CSITRIX%5C%5COneDrive%5C%5C%D0%A0%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D0%B9%20%D1%81%D1%82%D0%BE%D0%BB%5C%5Cnetavto%5C%5C%D0%9D%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%BF%D0%B0%D0%BF%D0%BA%D0%B0%20(2)%5C%5Csport_club%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22app%5C%5C%5C%5Clayout.js%5C%22%2C%5C%22import%5C%22%3A%5C%22Inter%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22inter%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/exenv/index.js":
/*!*************************************!*\
  !*** ./node_modules/exenv/index.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n  Copyright (c) 2015 Jed Watson.\n  Based on code that is Copyright 2013-2015, Facebook, Inc.\n  All rights reserved.\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar canUseDOM = !!(\n\t\ttypeof window !== 'undefined' &&\n\t\twindow.document &&\n\t\twindow.document.createElement\n\t);\n\n\tvar ExecutionEnvironment = {\n\n\t\tcanUseDOM: canUseDOM,\n\n\t\tcanUseWorkers: typeof Worker !== 'undefined',\n\n\t\tcanUseEventListeners:\n\t\t\tcanUseDOM && !!(window.addEventListener || window.attachEvent),\n\n\t\tcanUseViewport: canUseDOM && !!window.screen\n\n\t};\n\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn ExecutionEnvironment;\n\t\t}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9leGVudi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSyxJQUE0RTtBQUNqRixFQUFFLG1DQUFPO0FBQ1Q7QUFDQSxHQUFHO0FBQUEsa0dBQUM7QUFDSixHQUFHLEtBQUssRUFJTjs7QUFFRixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9leGVudi9pbmRleC5qcz9kMTYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTUgSmVkIFdhdHNvbi5cbiAgQmFzZWQgb24gY29kZSB0aGF0IGlzIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGNhblVzZURPTSA9ICEhKFxuXHRcdHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG5cdFx0d2luZG93LmRvY3VtZW50ICYmXG5cdFx0d2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnRcblx0KTtcblxuXHR2YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSB7XG5cblx0XHRjYW5Vc2VET006IGNhblVzZURPTSxcblxuXHRcdGNhblVzZVdvcmtlcnM6IHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnLFxuXG5cdFx0Y2FuVXNlRXZlbnRMaXN0ZW5lcnM6XG5cdFx0XHRjYW5Vc2VET00gJiYgISEod2luZG93LmFkZEV2ZW50TGlzdGVuZXIgfHwgd2luZG93LmF0dGFjaEV2ZW50KSxcblxuXHRcdGNhblVzZVZpZXdwb3J0OiBjYW5Vc2VET00gJiYgISF3aW5kb3cuc2NyZWVuXG5cblx0fTtcblxuXHRpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdGRlZmluZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gRXhlY3V0aW9uRW52aXJvbm1lbnQ7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50O1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5FeGVjdXRpb25FbnZpcm9ubWVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50O1xuXHR9XG5cbn0oKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/exenv/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/navigation.js":
/*!**************************************************!*\
  !*** ./node_modules/next/dist/api/navigation.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceMappingURL=navigation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdEOztBQUVoRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9uYXZpZ2F0aW9uLmpzPzAxNmQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4uL2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb25cIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2aWdhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/object-assign.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object-assign.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar assign = Object.assign.bind(Object);\nmodule.exports = assign;\nmodule.exports[\"default\"] = module.exports;\n\n//# sourceMappingURL=object-assign.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL29iamVjdC1hc3NpZ24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EseUJBQXNCOztBQUV0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9vYmplY3QtYXNzaWduLmpzPzY0NWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbi5iaW5kKE9iamVjdCk7XG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0LWFzc2lnbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/object-assign.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \*********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(()=>{\"use strict\";var e={592:(e,r,t)=>{var n=t(722);var i=Object.create(null);var a=typeof document===\"undefined\";var o=Array.prototype.forEach;function debounce(e,r){var t=0;return function(){var n=this;var i=arguments;var a=function functionCall(){return e.apply(n,i)};clearTimeout(t);t=setTimeout(a,r)}}function noop(){}function getCurrentScriptUrl(e){var r=i[e];if(!r){if(document.currentScript){r=document.currentScript.src}else{var t=document.getElementsByTagName(\"script\");var a=t[t.length-1];if(a){r=a.src}}i[e]=r}return function(e){if(!r){return null}var t=r.split(/([^\\\\/]+)\\.js$/);var i=t&&t[1];if(!i){return[r.replace(\".js\",\".css\")]}if(!e){return[r.replace(\".js\",\".css\")]}return e.split(\",\").map((function(e){var t=new RegExp(\"\".concat(i,\"\\\\.js$\"),\"g\");return n(r.replace(t,\"\".concat(e.replace(/{fileName}/g,i),\".css\")))}))}}function updateCss(e,r){if(!r){if(!e.href){return}r=e.href.split(\"?\")[0]}if(!isUrlRequest(r)){return}if(e.isLoaded===false){return}if(!r||!(r.indexOf(\".css\")>-1)){return}e.visited=true;var t=e.cloneNode();t.isLoaded=false;t.addEventListener(\"load\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.addEventListener(\"error\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.href=\"\".concat(r,\"?\").concat(Date.now());if(e.nextSibling){e.parentNode.insertBefore(t,e.nextSibling)}else{e.parentNode.appendChild(t)}}function getReloadUrl(e,r){var t;e=n(e,{stripWWW:false});r.some((function(n){if(e.indexOf(r)>-1){t=n}}));return t}function reloadStyle(e){if(!e){return false}var r=document.querySelectorAll(\"link\");var t=false;o.call(r,(function(r){if(!r.href){return}var n=getReloadUrl(r.href,e);if(!isUrlRequest(n)){return}if(r.visited===true){return}if(n){updateCss(r,n);t=true}}));return t}function reloadAll(){var e=document.querySelectorAll(\"link\");o.call(e,(function(e){if(e.visited===true){return}updateCss(e)}))}function isUrlRequest(e){if(!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)){return false}return true}e.exports=function(e,r){if(a){console.log(\"no window.document found, will not HMR CSS\");return noop}var t=getCurrentScriptUrl(e);function update(){var e=t(r.filename);var n=reloadStyle(e);if(r.locals){console.log(\"[HMR] Detected local css modules. Reload all css\");reloadAll();return}if(n){console.log(\"[HMR] css reload %s\",e.join(\" \"))}else{console.log(\"[HMR] Reload all css\");reloadAll()}}return debounce(update,50)}},722:e=>{function normalizeUrl(e){return e.reduce((function(e,r){switch(r){case\"..\":e.pop();break;case\".\":break;default:e.push(r)}return e}),[]).join(\"/\")}e.exports=function(e){e=e.trim();if(/^data:/i.test(e)){return e}var r=e.indexOf(\"//\")!==-1?e.split(\"//\")[0]+\"//\":\"\";var t=e.replace(new RegExp(r,\"i\"),\"\").split(\"/\");var n=t[0].toLowerCase().replace(/\\.$/,\"\");t[0]=\"\";var i=normalizeUrl(t);return r+n+i}}};var r={};function __nccwpck_require__(t){var n=r[t];if(n!==undefined){return n.exports}var i=r[t]={exports:{}};var a=true;try{e[t](i,i.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(592);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLGFBQWEsT0FBTyxjQUFjLGFBQWEsMEJBQTBCLG9DQUFvQyw4QkFBOEIsdUJBQXVCLFFBQVEsa0JBQWtCLFdBQVcsZ0JBQWdCLDhCQUE4QixxQkFBcUIsZ0JBQWdCLG1CQUFtQixpQkFBaUIsZ0NBQWdDLFdBQVcsT0FBTywyQkFBMkIsNkJBQTZCLEtBQUssOENBQThDLG9CQUFvQixNQUFNLFNBQVMsT0FBTyxtQkFBbUIsT0FBTyxZQUFZLGdDQUFnQyxjQUFjLE9BQU8sZ0NBQWdDLE9BQU8sZ0NBQWdDLHFDQUFxQyw0Q0FBNEMsMkNBQTJDLFNBQVMsZ0JBQWdCLElBQUksd0JBQXdCLE9BQU8sWUFBWSxPQUFPLHVCQUF1QixxQkFBcUIsT0FBTyx1QkFBdUIsT0FBTyxnQ0FBZ0MsT0FBTyxlQUFlLG9CQUFvQixpQkFBaUIsc0NBQXNDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsdUNBQXVDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsMkNBQTJDLGtCQUFrQiwyQ0FBMkMsS0FBSyw2QkFBNkIsMkJBQTJCLE1BQU0sT0FBTyxlQUFlLEVBQUUsb0JBQW9CLG9CQUFvQixLQUFLLEdBQUcsU0FBUyx3QkFBd0IsT0FBTyxhQUFhLHdDQUF3QyxZQUFZLHNCQUFzQixZQUFZLE9BQU8sNkJBQTZCLHFCQUFxQixPQUFPLHFCQUFxQixPQUFPLE1BQU0sZUFBZSxRQUFRLEdBQUcsU0FBUyxxQkFBcUIsd0NBQXdDLHNCQUFzQixxQkFBcUIsT0FBTyxhQUFhLEdBQUcseUJBQXlCLHlDQUF5QyxhQUFhLFlBQVksd0JBQXdCLE1BQU0sMERBQTBELFlBQVksNkJBQTZCLGtCQUFrQixvQkFBb0IscUJBQXFCLGFBQWEsZ0VBQWdFLFlBQVksT0FBTyxNQUFNLCtDQUErQyxLQUFLLG9DQUFvQyxhQUFhLDRCQUE0QixTQUFTLHlCQUF5QiwrQkFBK0IsVUFBVSxpQkFBaUIsTUFBTSxjQUFjLGtCQUFrQixTQUFTLGdCQUFnQixzQkFBc0IsV0FBVyxzQkFBc0IsU0FBUyxvREFBb0QsaURBQWlELDJDQUEyQyxRQUFRLHNCQUFzQixnQkFBZ0IsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qcz9kYTlkIl0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXs1OTI6KGUscix0KT0+e3ZhciBuPXQoNzIyKTt2YXIgaT1PYmplY3QuY3JlYXRlKG51bGwpO3ZhciBhPXR5cGVvZiBkb2N1bWVudD09PVwidW5kZWZpbmVkXCI7dmFyIG89QXJyYXkucHJvdG90eXBlLmZvckVhY2g7ZnVuY3Rpb24gZGVib3VuY2UoZSxyKXt2YXIgdD0wO3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXM7dmFyIGk9YXJndW1lbnRzO3ZhciBhPWZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbCgpe3JldHVybiBlLmFwcGx5KG4saSl9O2NsZWFyVGltZW91dCh0KTt0PXNldFRpbWVvdXQoYSxyKX19ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0VXJsKGUpe3ZhciByPWlbZV07aWYoIXIpe2lmKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3I9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmN9ZWxzZXt2YXIgdD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTt2YXIgYT10W3QubGVuZ3RoLTFdO2lmKGEpe3I9YS5zcmN9fWlbZV09cn1yZXR1cm4gZnVuY3Rpb24oZSl7aWYoIXIpe3JldHVybiBudWxsfXZhciB0PXIuc3BsaXQoLyhbXlxcXFwvXSspXFwuanMkLyk7dmFyIGk9dCYmdFsxXTtpZighaSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19aWYoIWUpe3JldHVybltyLnJlcGxhY2UoXCIuanNcIixcIi5jc3NcIildfXJldHVybiBlLnNwbGl0KFwiLFwiKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBSZWdFeHAoXCJcIi5jb25jYXQoaSxcIlxcXFwuanMkXCIpLFwiZ1wiKTtyZXR1cm4gbihyLnJlcGxhY2UodCxcIlwiLmNvbmNhdChlLnJlcGxhY2UoL3tmaWxlTmFtZX0vZyxpKSxcIi5jc3NcIikpKX0pKX19ZnVuY3Rpb24gdXBkYXRlQ3NzKGUscil7aWYoIXIpe2lmKCFlLmhyZWYpe3JldHVybn1yPWUuaHJlZi5zcGxpdChcIj9cIilbMF19aWYoIWlzVXJsUmVxdWVzdChyKSl7cmV0dXJufWlmKGUuaXNMb2FkZWQ9PT1mYWxzZSl7cmV0dXJufWlmKCFyfHwhKHIuaW5kZXhPZihcIi5jc3NcIik+LTEpKXtyZXR1cm59ZS52aXNpdGVkPXRydWU7dmFyIHQ9ZS5jbG9uZU5vZGUoKTt0LmlzTG9hZGVkPWZhbHNlO3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoZnVuY3Rpb24oKXtpZih0LmlzTG9hZGVkKXtyZXR1cm59dC5pc0xvYWRlZD10cnVlO2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX0pKTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuaHJlZj1cIlwiLmNvbmNhdChyLFwiP1wiKS5jb25jYXQoRGF0ZS5ub3coKSk7aWYoZS5uZXh0U2libGluZyl7ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LGUubmV4dFNpYmxpbmcpfWVsc2V7ZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHQpfX1mdW5jdGlvbiBnZXRSZWxvYWRVcmwoZSxyKXt2YXIgdDtlPW4oZSx7c3RyaXBXV1c6ZmFsc2V9KTtyLnNvbWUoKGZ1bmN0aW9uKG4pe2lmKGUuaW5kZXhPZihyKT4tMSl7dD1ufX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRTdHlsZShlKXtpZighZSl7cmV0dXJuIGZhbHNlfXZhciByPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rXCIpO3ZhciB0PWZhbHNlO28uY2FsbChyLChmdW5jdGlvbihyKXtpZighci5ocmVmKXtyZXR1cm59dmFyIG49Z2V0UmVsb2FkVXJsKHIuaHJlZixlKTtpZighaXNVcmxSZXF1ZXN0KG4pKXtyZXR1cm59aWYoci52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufWlmKG4pe3VwZGF0ZUNzcyhyLG4pO3Q9dHJ1ZX19KSk7cmV0dXJuIHR9ZnVuY3Rpb24gcmVsb2FkQWxsKCl7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7by5jYWxsKGUsKGZ1bmN0aW9uKGUpe2lmKGUudmlzaXRlZD09PXRydWUpe3JldHVybn11cGRhdGVDc3MoZSl9KSl9ZnVuY3Rpb24gaXNVcmxSZXF1ZXN0KGUpe2lmKCEvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo6Ly50ZXN0KGUpKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9ZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7aWYoYSl7Y29uc29sZS5sb2coXCJubyB3aW5kb3cuZG9jdW1lbnQgZm91bmQsIHdpbGwgbm90IEhNUiBDU1NcIik7cmV0dXJuIG5vb3B9dmFyIHQ9Z2V0Q3VycmVudFNjcmlwdFVybChlKTtmdW5jdGlvbiB1cGRhdGUoKXt2YXIgZT10KHIuZmlsZW5hbWUpO3ZhciBuPXJlbG9hZFN0eWxlKGUpO2lmKHIubG9jYWxzKXtjb25zb2xlLmxvZyhcIltITVJdIERldGVjdGVkIGxvY2FsIGNzcyBtb2R1bGVzLiBSZWxvYWQgYWxsIGNzc1wiKTtyZWxvYWRBbGwoKTtyZXR1cm59aWYobil7Y29uc29sZS5sb2coXCJbSE1SXSBjc3MgcmVsb2FkICVzXCIsZS5qb2luKFwiIFwiKSl9ZWxzZXtjb25zb2xlLmxvZyhcIltITVJdIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpfX1yZXR1cm4gZGVib3VuY2UodXBkYXRlLDUwKX19LDcyMjplPT57ZnVuY3Rpb24gbm9ybWFsaXplVXJsKGUpe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXtzd2l0Y2gocil7Y2FzZVwiLi5cIjplLnBvcCgpO2JyZWFrO2Nhc2VcIi5cIjpicmVhaztkZWZhdWx0OmUucHVzaChyKX1yZXR1cm4gZX0pLFtdKS5qb2luKFwiL1wiKX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSl7ZT1lLnRyaW0oKTtpZigvXmRhdGE6L2kudGVzdChlKSl7cmV0dXJuIGV9dmFyIHI9ZS5pbmRleE9mKFwiLy9cIikhPT0tMT9lLnNwbGl0KFwiLy9cIilbMF0rXCIvL1wiOlwiXCI7dmFyIHQ9ZS5yZXBsYWNlKG5ldyBSZWdFeHAocixcImlcIiksXCJcIikuc3BsaXQoXCIvXCIpO3ZhciBuPXRbMF0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC4kLyxcIlwiKTt0WzBdPVwiXCI7dmFyIGk9bm9ybWFsaXplVXJsKHQpO3JldHVybiByK24raX19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBuPXJbdF07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNTkyKTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar printWarning = function() {};\n\nif (true) {\n  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"(app-pages-browser)/./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n  var loggedTypeFailures = {};\n  var has = __webpack_require__(/*! ./lib/has */ \"(app-pages-browser)/./node_modules/prop-types/lib/has.js\");\n\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) { /**/ }\n  };\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error(\n              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\n              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +\n              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'\n            );\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error && !(error instanceof Error)) {\n          printWarning(\n            (componentName || 'React class') + ': type specification of ' +\n            location + ' `' + typeSpecName + '` is invalid; the type checker ' +\n            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\n            'You may have forgotten to pass an argument to the type checker ' +\n            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n            'shape all require an argument).'\n          );\n        }\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          printWarning(\n            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')\n          );\n        }\n      }\n    }\n  }\n}\n\n/**\n * Resets warning cache when testing.\n *\n * @private\n */\ncheckPropTypes.resetWarningCache = function() {\n  if (true) {\n    loggedTypeFailures = {};\n  }\n}\n\nmodule.exports = checkPropTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDLDZCQUE2QixtQkFBTyxDQUFDLDZHQUE0QjtBQUNqRTtBQUNBLFlBQVksbUJBQU8sQ0FBQywyRUFBVzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFlBQVk7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcz9jNmQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB2YXIgaGFzID0gcmVxdWlyZSgnLi9saWIvaGFzJyk7XG5cbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHsgLyoqLyB9XG4gIH07XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICtcbiAgICAgICAgICAgICAgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ZhaWxlZCAnICsgbG9jYXRpb24gKyAnIHR5cGU6ICcgKyBlcnJvci5tZXNzYWdlICsgKHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNldHMgd2FybmluZyBjYWNoZSB3aGVuIHRlc3RpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/checkPropTypes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactIs = __webpack_require__(/*! react-is */ \"(app-pages-browser)/./node_modules/react-is/index.js\");\nvar assign = __webpack_require__(/*! object-assign */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/object-assign.js\");\n\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"(app-pages-browser)/./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\nvar has = __webpack_require__(/*! ./lib/has */ \"(app-pages-browser)/./node_modules/prop-types/lib/has.js\");\nvar checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ \"(app-pages-browser)/./node_modules/prop-types/checkPropTypes.js\");\n\nvar printWarning = function() {};\n\nif (true) {\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nfunction emptyFunctionThatReturnsNull() {\n  return null;\n}\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bigint: createPrimitiveTypeChecker('bigint'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    elementType: createElementTypeTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message, data) {\n    this.message = message;\n    this.data = data && typeof data === 'object' ? data: {};\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (true) {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          var err = new Error(\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n          err.name = 'Invariant Violation';\n          throw err;\n        } else if ( true && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            printWarning(\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError(\n          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),\n          {expectedType: expectedType}\n        );\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!ReactIs.isValidElementType(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n      if (true) {\n        if (arguments.length > 1) {\n          printWarning(\n            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +\n            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'\n          );\n        } else {\n          printWarning('Invalid argument supplied to oneOf, expected an array.');\n        }\n      }\n      return emptyFunctionThatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n        var type = getPreciseType(value);\n        if (type === 'symbol') {\n          return String(value);\n        }\n        return value;\n      });\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (has(propValue, key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : 0;\n      return emptyFunctionThatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        printWarning(\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'\n        );\n        return emptyFunctionThatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var expectedTypes = [];\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);\n        if (checkerResult == null) {\n          return null;\n        }\n        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {\n          expectedTypes.push(checkerResult.data.expectedType);\n        }\n      }\n      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function invalidValidatorError(componentName, location, propFullName, key, type) {\n    return new PropTypeError(\n      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +\n      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'\n    );\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (typeof checker !== 'function') {\n          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (has(shapeTypes, key) && typeof checker !== 'function') {\n          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n        }\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // falsy value can't be a Symbol\n    if (!propValue) {\n      return false;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsc0VBQVU7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLG9HQUFlOztBQUVwQywyQkFBMkIsbUJBQU8sQ0FBQyw2R0FBNEI7QUFDL0QsVUFBVSxtQkFBTyxDQUFDLDJFQUFXO0FBQzdCLHFCQUFxQixtQkFBTyxDQUFDLHlGQUFrQjs7QUFFL0M7O0FBRUEsSUFBSSxJQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw4QkFBOEI7QUFDOUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0QkFBNEI7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTLEtBQXFDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLDRGQUE0RixDQUFNO0FBQzdJO0FBQ0E7O0FBRUEsb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlIQUFpSDtBQUNqSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanM/YzcwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL2xpYi9oYXMnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJpZ2ludDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2JpZ2ludCcpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGVsZW1lbnRUeXBlOiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlLCBkYXRhKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyA/IGRhdGE6IHt9O1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpLFxuICAgICAgICAgIHtleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZX1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFSZWFjdElzLmlzVmFsaWRFbGVtZW50VHlwZShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudCB0eXBlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnRzIHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheSwgZ290ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBhcmd1bWVudHMuICcgK1xuICAgICAgICAgICAgJ0EgY29tbW9uIG1pc3Rha2UgaXMgdG8gd3JpdGUgb25lT2YoeCwgeSwgeikgaW5zdGVhZCBvZiBvbmVPZihbeCwgeSwgel0pLidcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzLCBmdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBTdHJpbmcocHJvcFZhbHVlKSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAoaGFzKHByb3BWYWx1ZSwga2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJyArIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSArICcgYXQgaW5kZXggJyArIGkgKyAnLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgdmFyIGNoZWNrZXJSZXN1bHQgPSBjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoY2hlY2tlclJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrZXJSZXN1bHQuZGF0YSAmJiBoYXMoY2hlY2tlclJlc3VsdC5kYXRhLCAnZXhwZWN0ZWRUeXBlJykpIHtcbiAgICAgICAgICBleHBlY3RlZFR5cGVzLnB1c2goY2hlY2tlclJlc3VsdC5kYXRhLmV4cGVjdGVkVHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBleHBlY3RlZFR5cGVzTWVzc2FnZSA9IChleHBlY3RlZFR5cGVzLmxlbmd0aCA+IDApID8gJywgZXhwZWN0ZWQgb25lIG9mIHR5cGUgWycgKyBleHBlY3RlZFR5cGVzLmpvaW4oJywgJykgKyAnXSc6ICcnO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCcgKyBleHBlY3RlZFR5cGVzTWVzc2FnZSArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgdHlwZSkge1xuICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5ICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlICsgJ2AuJ1xuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIGdldFByZWNpc2VUeXBlKGNoZWNrZXIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbSBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmIChoYXMoc2hhcGVUeXBlcywga2V5KSAmJiB0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gZmFsc3kgdmFsdWUgY2FuJ3QgYmUgYSBTeW1ib2xcbiAgICBpZiAoIXByb3BWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGU7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/factoryWithTypeCheckers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (true) {\n  var ReactIs = __webpack_require__(/*! react-is */ \"(app-pages-browser)/./node_modules/react-is/index.js\");\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ \"(app-pages-browser)/./node_modules/prop-types/factoryWithTypeCheckers.js\")(ReactIs.isElement, throwOnDirectAccess);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFVOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQywyR0FBMkI7QUFDdEQsRUFBRSxLQUFLLEVBSU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanM/NjYxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzP2IyY2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/lib/ReactPropTypesSecret.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/lib/has.js":
/*!********************************************!*\
  !*** ./node_modules/prop-types/lib/has.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = Function.call.bind(Object.prototype.hasOwnProperty);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9oYXMuanMiLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL2hhcy5qcz84ZmQ2Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/lib/has.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n// (unstable) APIs that have been removed. Can we remove the symbols?\n\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\nvar REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nvar REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\nvar REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;\nvar REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;\nvar REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;\nvar REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n}\n\nfunction typeOf(object) {\n  if (typeof object === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case REACT_ASYNC_MODE_TYPE:\n          case REACT_CONCURRENT_MODE_TYPE:\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n            return type;\n\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n\n              default:\n                return $$typeof;\n            }\n\n        }\n\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n} // AsyncMode is deprecated along with isAsyncMode\n\nvar AsyncMode = REACT_ASYNC_MODE_TYPE;\nvar ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\nvar ContextConsumer = REACT_CONTEXT_TYPE;\nvar ContextProvider = REACT_PROVIDER_TYPE;\nvar Element = REACT_ELEMENT_TYPE;\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Fragment = REACT_FRAGMENT_TYPE;\nvar Lazy = REACT_LAZY_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nvar Portal = REACT_PORTAL_TYPE;\nvar Profiler = REACT_PROFILER_TYPE;\nvar StrictMode = REACT_STRICT_MODE_TYPE;\nvar Suspense = REACT_SUSPENSE_TYPE;\nvar hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n\nfunction isAsyncMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');\n    }\n  }\n\n  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n}\nfunction isConcurrentMode(object) {\n  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isContextProvider(object) {\n  return typeOf(object) === REACT_PROVIDER_TYPE;\n}\nfunction isElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isForwardRef(object) {\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n}\nfunction isFragment(object) {\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\n}\nfunction isLazy(object) {\n  return typeOf(object) === REACT_LAZY_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\nfunction isPortal(object) {\n  return typeOf(object) === REACT_PORTAL_TYPE;\n}\nfunction isProfiler(object) {\n  return typeOf(object) === REACT_PROFILER_TYPE;\n}\nfunction isStrictMode(object) {\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n}\nfunction isSuspense(object) {\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\n}\n\nexports.AsyncMode = AsyncMode;\nexports.ConcurrentMode = ConcurrentMode;\nexports.ContextConsumer = ContextConsumer;\nexports.ContextProvider = ContextProvider;\nexports.Element = Element;\nexports.ForwardRef = ForwardRef;\nexports.Fragment = Fragment;\nexports.Lazy = Lazy;\nexports.Memo = Memo;\nexports.Portal = Portal;\nexports.Profiler = Profiler;\nexports.StrictMode = StrictMode;\nexports.Suspense = Suspense;\nexports.isAsyncMode = isAsyncMode;\nexports.isConcurrentMode = isConcurrentMode;\nexports.isContextConsumer = isContextConsumer;\nexports.isContextProvider = isContextProvider;\nexports.isElement = isElement;\nexports.isForwardRef = isForwardRef;\nexports.isFragment = isFragment;\nexports.isLazy = isLazy;\nexports.isMemo = isMemo;\nexports.isPortal = isPortal;\nexports.isProfiler = isProfiler;\nexports.isStrictMode = isStrictMode;\nexports.isSuspense = isSuspense;\nexports.isValidElementType = isValidElementType;\nexports.typeOf = typeOf;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7OztBQUliLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QixlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixZQUFZO0FBQ1osWUFBWTtBQUNaLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEIsY0FBYztBQUNkLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEIsMEJBQTBCO0FBQzFCLGNBQWM7QUFDZCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcz82ZmUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTMuMVxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlOyAvLyBUT0RPOiBXZSBkb24ndCB1c2UgQXN5bmNNb2RlIG9yIENvbmN1cnJlbnRNb2RlIGFueW1vcmUuIFRoZXkgd2VyZSB0ZW1wb3Jhcnlcbi8vICh1bnN0YWJsZSkgQVBJcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkLiBDYW4gd2UgcmVtb3ZlIHRoZSBzeW1ib2xzP1xuXG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29uY3VycmVudF9tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJykgOiAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpIDogMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmJsb2NrJykgOiAweGVhZDk7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJykgOiAweGVhZDU7XG52YXIgUkVBQ1RfUkVTUE9OREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5yZXNwb25kZXInKSA6IDB4ZWFkNjtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKSA6IDB4ZWFkNztcblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUkVTUE9OREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0NPUEVfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFKTtcbn1cblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59IC8vIEFzeW5jTW9kZSBpcyBkZXByZWNhdGVkIGFsb25nIHdpdGggaXNBc3luY01vZGVcblxudmFyIEFzeW5jTW9kZSA9IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbnZhciBDb25jdXJyZW50TW9kZSA9IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xudmFyIENvbnRleHRDb25zdW1lciA9IFJFQUNUX0NPTlRFWFRfVFlQRTtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSBSRUFDVF9QUk9WSURFUl9UWVBFO1xudmFyIEVsZW1lbnQgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xudmFyIExhenkgPSBSRUFDVF9MQVpZX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbnZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcbnZhciBQcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG52YXIgU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG52YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7IC8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuXG5mdW5jdGlvbiBpc0FzeW5jTW9kZShvYmplY3QpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gdHJ1ZTsgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcblxuICAgICAgY29uc29sZVsnd2FybiddKCdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuXG5leHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcbmV4cG9ydHMuQ29uY3VycmVudE1vZGUgPSBDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuQ29udGV4dENvbnN1bWVyID0gQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Gb3J3YXJkUmVmID0gRm9yd2FyZFJlZjtcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbmV4cG9ydHMuTGF6eSA9IExhenk7XG5leHBvcnRzLk1lbW8gPSBNZW1vO1xuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XG5leHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBTdHJpY3RNb2RlO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xuZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xuZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlID0gaXNDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuaXNDb250ZXh0Q29uc3VtZXIgPSBpc0NvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0ZvcndhcmRSZWYgPSBpc0ZvcndhcmRSZWY7XG5leHBvcnRzLmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xuZXhwb3J0cy5pc0xhenkgPSBpc0xhenk7XG5leHBvcnRzLmlzTWVtbyA9IGlzTWVtbztcbmV4cG9ydHMuaXNQb3J0YWwgPSBpc1BvcnRhbDtcbmV4cG9ydHMuaXNQcm9maWxlciA9IGlzUHJvZmlsZXI7XG5leHBvcnRzLmlzU3RyaWN0TW9kZSA9IGlzU3RyaWN0TW9kZTtcbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMudHlwZU9mID0gdHlwZU9mO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-is/cjs/react-is.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ \"(app-pages-browser)/./node_modules/react-is/cjs/react-is.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsb0pBQXlEO0FBQzNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcz83ZDYwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-is/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js":
/*!****************************************************************************!*\
  !*** ./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   polyfill: function() { return /* binding */ polyfill; }\n/* harmony export */ });\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nfunction componentWillMount() {\n  // Call this.constructor.gDSFP to support sub-classes.\n  var state = this.constructor.getDerivedStateFromProps(this.props, this.state);\n  if (state !== null && state !== undefined) {\n    this.setState(state);\n  }\n}\n\nfunction componentWillReceiveProps(nextProps) {\n  // Call this.constructor.gDSFP to support sub-classes.\n  // Use the setState() updater to ensure state isn't stale in certain edge cases.\n  function updater(prevState) {\n    var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);\n    return state !== null && state !== undefined ? state : null;\n  }\n  // Binding \"this\" is important for shallow renderer support.\n  this.setState(updater.bind(this));\n}\n\nfunction componentWillUpdate(nextProps, nextState) {\n  try {\n    var prevProps = this.props;\n    var prevState = this.state;\n    this.props = nextProps;\n    this.state = nextState;\n    this.__reactInternalSnapshotFlag = true;\n    this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(\n      prevProps,\n      prevState\n    );\n  } finally {\n    this.props = prevProps;\n    this.state = prevState;\n  }\n}\n\n// React may warn about cWM/cWRP/cWU methods being deprecated.\n// Add a flag to suppress these warnings for this special case.\ncomponentWillMount.__suppressDeprecationWarning = true;\ncomponentWillReceiveProps.__suppressDeprecationWarning = true;\ncomponentWillUpdate.__suppressDeprecationWarning = true;\n\nfunction polyfill(Component) {\n  var prototype = Component.prototype;\n\n  if (!prototype || !prototype.isReactComponent) {\n    throw new Error('Can only polyfill class components');\n  }\n\n  if (\n    typeof Component.getDerivedStateFromProps !== 'function' &&\n    typeof prototype.getSnapshotBeforeUpdate !== 'function'\n  ) {\n    return Component;\n  }\n\n  // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n  // Error if any of these lifecycles are present,\n  // Because they would work differently between older and newer (16.3+) versions of React.\n  var foundWillMountName = null;\n  var foundWillReceivePropsName = null;\n  var foundWillUpdateName = null;\n  if (typeof prototype.componentWillMount === 'function') {\n    foundWillMountName = 'componentWillMount';\n  } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {\n    foundWillMountName = 'UNSAFE_componentWillMount';\n  }\n  if (typeof prototype.componentWillReceiveProps === 'function') {\n    foundWillReceivePropsName = 'componentWillReceiveProps';\n  } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {\n    foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n  }\n  if (typeof prototype.componentWillUpdate === 'function') {\n    foundWillUpdateName = 'componentWillUpdate';\n  } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {\n    foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n  }\n  if (\n    foundWillMountName !== null ||\n    foundWillReceivePropsName !== null ||\n    foundWillUpdateName !== null\n  ) {\n    var componentName = Component.displayName || Component.name;\n    var newApiName =\n      typeof Component.getDerivedStateFromProps === 'function'\n        ? 'getDerivedStateFromProps()'\n        : 'getSnapshotBeforeUpdate()';\n\n    throw Error(\n      'Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' +\n        componentName +\n        ' uses ' +\n        newApiName +\n        ' but also contains the following legacy lifecycles:' +\n        (foundWillMountName !== null ? '\\n  ' + foundWillMountName : '') +\n        (foundWillReceivePropsName !== null\n          ? '\\n  ' + foundWillReceivePropsName\n          : '') +\n        (foundWillUpdateName !== null ? '\\n  ' + foundWillUpdateName : '') +\n        '\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\n' +\n        'https://fb.me/react-async-component-lifecycle-hooks'\n    );\n  }\n\n  // React <= 16.2 does not support static getDerivedStateFromProps.\n  // As a workaround, use cWM and cWRP to invoke the new static lifecycle.\n  // Newer versions of React will ignore these lifecycles if gDSFP exists.\n  if (typeof Component.getDerivedStateFromProps === 'function') {\n    prototype.componentWillMount = componentWillMount;\n    prototype.componentWillReceiveProps = componentWillReceiveProps;\n  }\n\n  // React <= 16.2 does not support getSnapshotBeforeUpdate.\n  // As a workaround, use cWU to invoke the new lifecycle.\n  // Newer versions of React will ignore that lifecycle if gSBU exists.\n  if (typeof prototype.getSnapshotBeforeUpdate === 'function') {\n    if (typeof prototype.componentDidUpdate !== 'function') {\n      throw new Error(\n        'Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype'\n      );\n    }\n\n    prototype.componentWillUpdate = componentWillUpdate;\n\n    var componentDidUpdate = prototype.componentDidUpdate;\n\n    prototype.componentDidUpdate = function componentDidUpdatePolyfill(\n      prevProps,\n      prevState,\n      maybeSnapshot\n    ) {\n      // 16.3+ will not execute our will-update method;\n      // It will pass a snapshot value to did-update though.\n      // Older versions will require our polyfilled will-update value.\n      // We need to handle both cases, but can't just check for the presence of \"maybeSnapshot\",\n      // Because for <= 15.x versions this might be a \"prevContext\" object.\n      // We also can't just check \"__reactInternalSnapshot\",\n      // Because get-snapshot might return a falsy value.\n      // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.\n      var snapshot = this.__reactInternalSnapshotFlag\n        ? this.__reactInternalSnapshot\n        : maybeSnapshot;\n\n      componentDidUpdate.call(this, prevProps, prevState, snapshot);\n    };\n  }\n\n  return Component;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1saWZlY3ljbGVzLWNvbXBhdC9yZWFjdC1saWZlY3ljbGVzLWNvbXBhdC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWxpZmVjeWNsZXMtY29tcGF0L3JlYWN0LWxpZmVjeWNsZXMtY29tcGF0LmVzLmpzPzYxMjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5mdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gIC8vIENhbGwgdGhpcy5jb25zdHJ1Y3Rvci5nRFNGUCB0byBzdXBwb3J0IHN1Yi1jbGFzc2VzLlxuICB2YXIgc3RhdGUgPSB0aGlzLmNvbnN0cnVjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyh0aGlzLnByb3BzLCB0aGlzLnN0YXRlKTtcbiAgaWYgKHN0YXRlICE9PSBudWxsICYmIHN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnNldFN0YXRlKHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAvLyBDYWxsIHRoaXMuY29uc3RydWN0b3IuZ0RTRlAgdG8gc3VwcG9ydCBzdWItY2xhc3Nlcy5cbiAgLy8gVXNlIHRoZSBzZXRTdGF0ZSgpIHVwZGF0ZXIgdG8gZW5zdXJlIHN0YXRlIGlzbid0IHN0YWxlIGluIGNlcnRhaW4gZWRnZSBjYXNlcy5cbiAgZnVuY3Rpb24gdXBkYXRlcihwcmV2U3RhdGUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLmNvbnN0cnVjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgcmV0dXJuIHN0YXRlICE9PSBudWxsICYmIHN0YXRlICE9PSB1bmRlZmluZWQgPyBzdGF0ZSA6IG51bGw7XG4gIH1cbiAgLy8gQmluZGluZyBcInRoaXNcIiBpcyBpbXBvcnRhbnQgZm9yIHNoYWxsb3cgcmVuZGVyZXIgc3VwcG9ydC5cbiAgdGhpcy5zZXRTdGF0ZSh1cGRhdGVyLmJpbmQodGhpcykpO1xufVxuXG5mdW5jdGlvbiBjb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gIHRyeSB7XG4gICAgdmFyIHByZXZQcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHByZXZTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5wcm9wcyA9IG5leHRQcm9wcztcbiAgICB0aGlzLnN0YXRlID0gbmV4dFN0YXRlO1xuICAgIHRoaXMuX19yZWFjdEludGVybmFsU25hcHNob3RGbGFnID0gdHJ1ZTtcbiAgICB0aGlzLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90ID0gdGhpcy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShcbiAgICAgIHByZXZQcm9wcyxcbiAgICAgIHByZXZTdGF0ZVxuICAgICk7XG4gIH0gZmluYWxseSB7XG4gICAgdGhpcy5wcm9wcyA9IHByZXZQcm9wcztcbiAgICB0aGlzLnN0YXRlID0gcHJldlN0YXRlO1xuICB9XG59XG5cbi8vIFJlYWN0IG1heSB3YXJuIGFib3V0IGNXTS9jV1JQL2NXVSBtZXRob2RzIGJlaW5nIGRlcHJlY2F0ZWQuXG4vLyBBZGQgYSBmbGFnIHRvIHN1cHByZXNzIHRoZXNlIHdhcm5pbmdzIGZvciB0aGlzIHNwZWNpYWwgY2FzZS5cbmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nID0gdHJ1ZTtcbmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyA9IHRydWU7XG5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgPSB0cnVlO1xuXG5mdW5jdGlvbiBwb2x5ZmlsbChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG5cbiAgaWYgKCFwcm90b3R5cGUgfHwgIXByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gb25seSBwb2x5ZmlsbCBjbGFzcyBjb21wb25lbnRzJyk7XG4gIH1cblxuICBpZiAoXG4gICAgdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgcHJvdG90eXBlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybiBDb21wb25lbnQ7XG4gIH1cblxuICAvLyBJZiBuZXcgY29tcG9uZW50IEFQSXMgYXJlIGRlZmluZWQsIFwidW5zYWZlXCIgbGlmZWN5Y2xlcyB3b24ndCBiZSBjYWxsZWQuXG4gIC8vIEVycm9yIGlmIGFueSBvZiB0aGVzZSBsaWZlY3ljbGVzIGFyZSBwcmVzZW50LFxuICAvLyBCZWNhdXNlIHRoZXkgd291bGQgd29yayBkaWZmZXJlbnRseSBiZXR3ZWVuIG9sZGVyIGFuZCBuZXdlciAoMTYuMyspIHZlcnNpb25zIG9mIFJlYWN0LlxuICB2YXIgZm91bmRXaWxsTW91bnROYW1lID0gbnVsbDtcbiAgdmFyIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBudWxsO1xuICB2YXIgZm91bmRXaWxsVXBkYXRlTmFtZSA9IG51bGw7XG4gIGlmICh0eXBlb2YgcHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdjb21wb25lbnRXaWxsTW91bnQnO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm90b3R5cGUuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JztcbiAgfVxuICBpZiAodHlwZW9mIHByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvdG90eXBlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm90b3R5cGUuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb3RvdHlwZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICB9XG4gIGlmIChcbiAgICBmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgfHxcbiAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lICE9PSBudWxsIHx8XG4gICAgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbFxuICApIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZTtcbiAgICB2YXIgbmV3QXBpTmFtZSA9XG4gICAgICB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/ICdnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKSdcbiAgICAgICAgOiAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSc7XG5cbiAgICB0aHJvdyBFcnJvcihcbiAgICAgICdVbnNhZmUgbGVnYWN5IGxpZmVjeWNsZXMgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBjb21wb25lbnRzIHVzaW5nIG5ldyBjb21wb25lbnQgQVBJcy5cXG5cXG4nICtcbiAgICAgICAgY29tcG9uZW50TmFtZSArXG4gICAgICAgICcgdXNlcyAnICtcbiAgICAgICAgbmV3QXBpTmFtZSArXG4gICAgICAgICcgYnV0IGFsc28gY29udGFpbnMgdGhlIGZvbGxvd2luZyBsZWdhY3kgbGlmZWN5Y2xlczonICtcbiAgICAgICAgKGZvdW5kV2lsbE1vdW50TmFtZSAhPT0gbnVsbCA/ICdcXG4gICcgKyBmb3VuZFdpbGxNb3VudE5hbWUgOiAnJykgK1xuICAgICAgICAoZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbFxuICAgICAgICAgID8gJ1xcbiAgJyArIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWVcbiAgICAgICAgICA6ICcnKSArXG4gICAgICAgIChmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsID8gJ1xcbiAgJyArIGZvdW5kV2lsbFVwZGF0ZU5hbWUgOiAnJykgK1xuICAgICAgICAnXFxuXFxuVGhlIGFib3ZlIGxpZmVjeWNsZXMgc2hvdWxkIGJlIHJlbW92ZWQuIExlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6XFxuJyArXG4gICAgICAgICdodHRwczovL2ZiLm1lL3JlYWN0LWFzeW5jLWNvbXBvbmVudC1saWZlY3ljbGUtaG9va3MnXG4gICAgKTtcbiAgfVxuXG4gIC8vIFJlYWN0IDw9IDE2LjIgZG9lcyBub3Qgc3VwcG9ydCBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLlxuICAvLyBBcyBhIHdvcmthcm91bmQsIHVzZSBjV00gYW5kIGNXUlAgdG8gaW52b2tlIHRoZSBuZXcgc3RhdGljIGxpZmVjeWNsZS5cbiAgLy8gTmV3ZXIgdmVyc2lvbnMgb2YgUmVhY3Qgd2lsbCBpZ25vcmUgdGhlc2UgbGlmZWN5Y2xlcyBpZiBnRFNGUCBleGlzdHMuXG4gIGlmICh0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBjb21wb25lbnRXaWxsTW91bnQ7XG4gICAgcHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzO1xuICB9XG5cbiAgLy8gUmVhY3QgPD0gMTYuMiBkb2VzIG5vdCBzdXBwb3J0IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlLlxuICAvLyBBcyBhIHdvcmthcm91bmQsIHVzZSBjV1UgdG8gaW52b2tlIHRoZSBuZXcgbGlmZWN5Y2xlLlxuICAvLyBOZXdlciB2ZXJzaW9ucyBvZiBSZWFjdCB3aWxsIGlnbm9yZSB0aGF0IGxpZmVjeWNsZSBpZiBnU0JVIGV4aXN0cy5cbiAgaWYgKHR5cGVvZiBwcm90b3R5cGUuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAodHlwZW9mIHByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBwb2x5ZmlsbCBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIGZvciBjb21wb25lbnRzIHRoYXQgZG8gbm90IGRlZmluZSBjb21wb25lbnREaWRVcGRhdGUoKSBvbiB0aGUgcHJvdG90eXBlJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBwcm90b3R5cGUuY29tcG9uZW50V2lsbFVwZGF0ZSA9IGNvbXBvbmVudFdpbGxVcGRhdGU7XG5cbiAgICB2YXIgY29tcG9uZW50RGlkVXBkYXRlID0gcHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZTtcblxuICAgIHByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGVQb2x5ZmlsbChcbiAgICAgIHByZXZQcm9wcyxcbiAgICAgIHByZXZTdGF0ZSxcbiAgICAgIG1heWJlU25hcHNob3RcbiAgICApIHtcbiAgICAgIC8vIDE2LjMrIHdpbGwgbm90IGV4ZWN1dGUgb3VyIHdpbGwtdXBkYXRlIG1ldGhvZDtcbiAgICAgIC8vIEl0IHdpbGwgcGFzcyBhIHNuYXBzaG90IHZhbHVlIHRvIGRpZC11cGRhdGUgdGhvdWdoLlxuICAgICAgLy8gT2xkZXIgdmVyc2lvbnMgd2lsbCByZXF1aXJlIG91ciBwb2x5ZmlsbGVkIHdpbGwtdXBkYXRlIHZhbHVlLlxuICAgICAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYm90aCBjYXNlcywgYnV0IGNhbid0IGp1c3QgY2hlY2sgZm9yIHRoZSBwcmVzZW5jZSBvZiBcIm1heWJlU25hcHNob3RcIixcbiAgICAgIC8vIEJlY2F1c2UgZm9yIDw9IDE1LnggdmVyc2lvbnMgdGhpcyBtaWdodCBiZSBhIFwicHJldkNvbnRleHRcIiBvYmplY3QuXG4gICAgICAvLyBXZSBhbHNvIGNhbid0IGp1c3QgY2hlY2sgXCJfX3JlYWN0SW50ZXJuYWxTbmFwc2hvdFwiLFxuICAgICAgLy8gQmVjYXVzZSBnZXQtc25hcHNob3QgbWlnaHQgcmV0dXJuIGEgZmFsc3kgdmFsdWUuXG4gICAgICAvLyBTbyBjaGVjayBmb3IgdGhlIGV4cGxpY2l0IF9fcmVhY3RJbnRlcm5hbFNuYXBzaG90RmxhZyBmbGFnIHRvIGRldGVybWluZSBiZWhhdmlvci5cbiAgICAgIHZhciBzbmFwc2hvdCA9IHRoaXMuX19yZWFjdEludGVybmFsU25hcHNob3RGbGFnXG4gICAgICAgID8gdGhpcy5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdFxuICAgICAgICA6IG1heWJlU25hcHNob3Q7XG5cbiAgICAgIGNvbXBvbmVudERpZFVwZGF0ZS5jYWxsKHRoaXMsIHByZXZQcm9wcywgcHJldlN0YXRlLCBzbmFwc2hvdCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBDb21wb25lbnQ7XG59XG5cbmV4cG9ydCB7IHBvbHlmaWxsIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-modal/lib/components/Modal.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-modal/lib/components/Modal.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.bodyOpenClassName = exports.portalClassName = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _propTypes = __webpack_require__(/*! prop-types */ \"(app-pages-browser)/./node_modules/prop-types/index.js\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _ModalPortal = __webpack_require__(/*! ./ModalPortal */ \"(app-pages-browser)/./node_modules/react-modal/lib/components/ModalPortal.js\");\n\nvar _ModalPortal2 = _interopRequireDefault(_ModalPortal);\n\nvar _ariaAppHider = __webpack_require__(/*! ../helpers/ariaAppHider */ \"(app-pages-browser)/./node_modules/react-modal/lib/helpers/ariaAppHider.js\");\n\nvar ariaAppHider = _interopRequireWildcard(_ariaAppHider);\n\nvar _safeHTMLElement = __webpack_require__(/*! ../helpers/safeHTMLElement */ \"(app-pages-browser)/./node_modules/react-modal/lib/helpers/safeHTMLElement.js\");\n\nvar _safeHTMLElement2 = _interopRequireDefault(_safeHTMLElement);\n\nvar _reactLifecyclesCompat = __webpack_require__(/*! react-lifecycles-compat */ \"(app-pages-browser)/./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar portalClassName = exports.portalClassName = \"ReactModalPortal\";\nvar bodyOpenClassName = exports.bodyOpenClassName = \"ReactModal__Body--open\";\n\nvar isReact16 = _safeHTMLElement.canUseDOM && _reactDom2.default.createPortal !== undefined;\n\nvar createHTMLElement = function createHTMLElement(name) {\n  return document.createElement(name);\n};\n\nvar getCreatePortal = function getCreatePortal() {\n  return isReact16 ? _reactDom2.default.createPortal : _reactDom2.default.unstable_renderSubtreeIntoContainer;\n};\n\nfunction getParentElement(parentSelector) {\n  return parentSelector();\n}\n\nvar Modal = function (_Component) {\n  _inherits(Modal, _Component);\n\n  function Modal() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Modal);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Modal.__proto__ || Object.getPrototypeOf(Modal)).call.apply(_ref, [this].concat(args))), _this), _this.removePortal = function () {\n      !isReact16 && _reactDom2.default.unmountComponentAtNode(_this.node);\n      var parent = getParentElement(_this.props.parentSelector);\n      if (parent && parent.contains(_this.node)) {\n        parent.removeChild(_this.node);\n      } else {\n        // eslint-disable-next-line no-console\n        console.warn('React-Modal: \"parentSelector\" prop did not returned any DOM ' + \"element. Make sure that the parent element is unmounted to \" + \"avoid any memory leaks.\");\n      }\n    }, _this.portalRef = function (ref) {\n      _this.portal = ref;\n    }, _this.renderPortal = function (props) {\n      var createPortal = getCreatePortal();\n      var portal = createPortal(_this, _react2.default.createElement(_ModalPortal2.default, _extends({ defaultStyles: Modal.defaultStyles }, props)), _this.node);\n      _this.portalRef(portal);\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(Modal, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (!_safeHTMLElement.canUseDOM) return;\n\n      if (!isReact16) {\n        this.node = createHTMLElement(\"div\");\n      }\n      this.node.className = this.props.portalClassName;\n\n      var parent = getParentElement(this.props.parentSelector);\n      parent.appendChild(this.node);\n\n      !isReact16 && this.renderPortal(this.props);\n    }\n  }, {\n    key: \"getSnapshotBeforeUpdate\",\n    value: function getSnapshotBeforeUpdate(prevProps) {\n      var prevParent = getParentElement(prevProps.parentSelector);\n      var nextParent = getParentElement(this.props.parentSelector);\n      return { prevParent: prevParent, nextParent: nextParent };\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, _, snapshot) {\n      if (!_safeHTMLElement.canUseDOM) return;\n      var _props = this.props,\n          isOpen = _props.isOpen,\n          portalClassName = _props.portalClassName;\n\n\n      if (prevProps.portalClassName !== portalClassName) {\n        this.node.className = portalClassName;\n      }\n\n      var prevParent = snapshot.prevParent,\n          nextParent = snapshot.nextParent;\n\n      if (nextParent !== prevParent) {\n        prevParent.removeChild(this.node);\n        nextParent.appendChild(this.node);\n      }\n\n      // Stop unnecessary renders if modal is remaining closed\n      if (!prevProps.isOpen && !isOpen) return;\n\n      !isReact16 && this.renderPortal(this.props);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (!_safeHTMLElement.canUseDOM || !this.node || !this.portal) return;\n\n      var state = this.portal.state;\n      var now = Date.now();\n      var closesAt = state.isOpen && this.props.closeTimeoutMS && (state.closesAt || now + this.props.closeTimeoutMS);\n\n      if (closesAt) {\n        if (!state.beforeClose) {\n          this.portal.closeWithTimeout();\n        }\n\n        setTimeout(this.removePortal, closesAt - now);\n      } else {\n        this.removePortal();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (!_safeHTMLElement.canUseDOM || !isReact16) {\n        return null;\n      }\n\n      if (!this.node && isReact16) {\n        this.node = createHTMLElement(\"div\");\n      }\n\n      var createPortal = getCreatePortal();\n      return createPortal(_react2.default.createElement(_ModalPortal2.default, _extends({\n        ref: this.portalRef,\n        defaultStyles: Modal.defaultStyles\n      }, this.props)), this.node);\n    }\n  }], [{\n    key: \"setAppElement\",\n    value: function setAppElement(element) {\n      ariaAppHider.setElement(element);\n    }\n\n    /* eslint-disable react/no-unused-prop-types */\n\n    /* eslint-enable react/no-unused-prop-types */\n\n  }]);\n\n  return Modal;\n}(_react.Component);\n\nModal.propTypes = {\n  isOpen: _propTypes2.default.bool.isRequired,\n  style: _propTypes2.default.shape({\n    content: _propTypes2.default.object,\n    overlay: _propTypes2.default.object\n  }),\n  portalClassName: _propTypes2.default.string,\n  bodyOpenClassName: _propTypes2.default.string,\n  htmlOpenClassName: _propTypes2.default.string,\n  className: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.shape({\n    base: _propTypes2.default.string.isRequired,\n    afterOpen: _propTypes2.default.string.isRequired,\n    beforeClose: _propTypes2.default.string.isRequired\n  })]),\n  overlayClassName: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.shape({\n    base: _propTypes2.default.string.isRequired,\n    afterOpen: _propTypes2.default.string.isRequired,\n    beforeClose: _propTypes2.default.string.isRequired\n  })]),\n  appElement: _propTypes2.default.oneOfType([_propTypes2.default.instanceOf(_safeHTMLElement2.default), _propTypes2.default.instanceOf(_safeHTMLElement.SafeHTMLCollection), _propTypes2.default.instanceOf(_safeHTMLElement.SafeNodeList), _propTypes2.default.arrayOf(_propTypes2.default.instanceOf(_safeHTMLElement2.default))]),\n  onAfterOpen: _propTypes2.default.func,\n  onRequestClose: _propTypes2.default.func,\n  closeTimeoutMS: _propTypes2.default.number,\n  ariaHideApp: _propTypes2.default.bool,\n  shouldFocusAfterRender: _propTypes2.default.bool,\n  shouldCloseOnOverlayClick: _propTypes2.default.bool,\n  shouldReturnFocusAfterClose: _propTypes2.default.bool,\n  preventScroll: _propTypes2.default.bool,\n  parentSelector: _propTypes2.default.func,\n  aria: _propTypes2.default.object,\n  data: _propTypes2.default.object,\n  role: _propTypes2.default.string,\n  contentLabel: _propTypes2.default.string,\n  shouldCloseOnEsc: _propTypes2.default.bool,\n  overlayRef: _propTypes2.default.func,\n  contentRef: _propTypes2.default.func,\n  id: _propTypes2.default.string,\n  overlayElement: _propTypes2.default.func,\n  contentElement: _propTypes2.default.func\n};\nModal.defaultProps = {\n  isOpen: false,\n  portalClassName: portalClassName,\n  bodyOpenClassName: bodyOpenClassName,\n  role: \"dialog\",\n  ariaHideApp: true,\n  closeTimeoutMS: 0,\n  shouldFocusAfterRender: true,\n  shouldCloseOnEsc: true,\n  shouldCloseOnOverlayClick: true,\n  shouldReturnFocusAfterClose: true,\n  preventScroll: false,\n  parentSelector: function parentSelector() {\n    return document.body;\n  },\n  overlayElement: function overlayElement(props, contentEl) {\n    return _react2.default.createElement(\n      \"div\",\n      props,\n      contentEl\n    );\n  },\n  contentElement: function contentElement(props, children) {\n    return _react2.default.createElement(\n      \"div\",\n      props,\n      children\n    );\n  }\n};\nModal.defaultStyles = {\n  overlay: {\n    position: \"fixed\",\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    backgroundColor: \"rgba(255, 255, 255, 0.75)\"\n  },\n  content: {\n    position: \"absolute\",\n    top: \"40px\",\n    left: \"40px\",\n    right: \"40px\",\n    bottom: \"40px\",\n    border: \"1px solid #ccc\",\n    background: \"#fff\",\n    overflow: \"auto\",\n    WebkitOverflowScrolling: \"touch\",\n    borderRadius: \"4px\",\n    outline: \"none\",\n    padding: \"20px\"\n  }\n};\n\n\n(0, _reactLifecyclesCompat.polyfill)(Modal);\n\nif (true) {\n  Modal.setCreateHTMLElement = function (fn) {\n    return createHTMLElement = fn;\n  };\n}\n\nexports[\"default\"] = Modal;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9saWIvY29tcG9uZW50cy9Nb2RhbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRix5QkFBeUIsR0FBRyx1QkFBdUI7O0FBRW5ELG9EQUFvRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsaUNBQWlDOztBQUVoUCxpQ0FBaUMsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsK0RBQStELHlEQUF5RCxxRUFBcUUsNkRBQTZELHdCQUF3Qjs7QUFFampCLGFBQWEsbUJBQU8sQ0FBQyxtRkFBTzs7QUFFNUI7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsMkZBQVc7O0FBRW5DOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLDBFQUFZOztBQUVyQzs7QUFFQSxtQkFBbUIsbUJBQU8sQ0FBQyxtR0FBZTs7QUFFMUM7O0FBRUEsb0JBQW9CLG1CQUFPLENBQUMsMkdBQXlCOztBQUVyRDs7QUFFQSx1QkFBdUIsbUJBQU8sQ0FBQyxpSEFBNEI7O0FBRTNEOztBQUVBLDZCQUE2QixtQkFBTyxDQUFDLHlIQUF5Qjs7QUFFOUQsd0NBQXdDLDZCQUE2QixjQUFjLE9BQU8saUJBQWlCLG1CQUFtQix1QkFBdUIsZ0ZBQWdGLHNCQUFzQjs7QUFFM1AsdUNBQXVDLHVDQUF1Qzs7QUFFOUUsa0RBQWtELDBDQUEwQzs7QUFFNUYsa0RBQWtELGFBQWEseUZBQXlGOztBQUV4SiwyQ0FBMkMsK0RBQStELHVHQUF1Ryx5RUFBeUUsZUFBZSwwRUFBMEUsR0FBRzs7QUFFdFgsc0JBQXNCLHVCQUF1QjtBQUM3Qyx3QkFBd0IseUJBQXlCOztBQUVqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0VBQW9FLGFBQWE7QUFDakY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLHVHQUF1RyxvQ0FBb0M7QUFDM0k7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9saWIvY29tcG9uZW50cy9Nb2RhbC5qcz85ODA3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5ib2R5T3BlbkNsYXNzTmFtZSA9IGV4cG9ydHMucG9ydGFsQ2xhc3NOYW1lID0gdW5kZWZpbmVkO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoXCJyZWFjdC1kb21cIik7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG52YXIgX3Byb3BUeXBlcyA9IHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpO1xuXG52YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG52YXIgX01vZGFsUG9ydGFsID0gcmVxdWlyZShcIi4vTW9kYWxQb3J0YWxcIik7XG5cbnZhciBfTW9kYWxQb3J0YWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTW9kYWxQb3J0YWwpO1xuXG52YXIgX2FyaWFBcHBIaWRlciA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2FyaWFBcHBIaWRlclwiKTtcblxudmFyIGFyaWFBcHBIaWRlciA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9hcmlhQXBwSGlkZXIpO1xuXG52YXIgX3NhZmVIVE1MRWxlbWVudCA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3NhZmVIVE1MRWxlbWVudFwiKTtcblxudmFyIF9zYWZlSFRNTEVsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2FmZUhUTUxFbGVtZW50KTtcblxudmFyIF9yZWFjdExpZmVjeWNsZXNDb21wYXQgPSByZXF1aXJlKFwicmVhY3QtbGlmZWN5Y2xlcy1jb21wYXRcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIHBvcnRhbENsYXNzTmFtZSA9IGV4cG9ydHMucG9ydGFsQ2xhc3NOYW1lID0gXCJSZWFjdE1vZGFsUG9ydGFsXCI7XG52YXIgYm9keU9wZW5DbGFzc05hbWUgPSBleHBvcnRzLmJvZHlPcGVuQ2xhc3NOYW1lID0gXCJSZWFjdE1vZGFsX19Cb2R5LS1vcGVuXCI7XG5cbnZhciBpc1JlYWN0MTYgPSBfc2FmZUhUTUxFbGVtZW50LmNhblVzZURPTSAmJiBfcmVhY3REb20yLmRlZmF1bHQuY3JlYXRlUG9ydGFsICE9PSB1bmRlZmluZWQ7XG5cbnZhciBjcmVhdGVIVE1MRWxlbWVudCA9IGZ1bmN0aW9uIGNyZWF0ZUhUTUxFbGVtZW50KG5hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSk7XG59O1xuXG52YXIgZ2V0Q3JlYXRlUG9ydGFsID0gZnVuY3Rpb24gZ2V0Q3JlYXRlUG9ydGFsKCkge1xuICByZXR1cm4gaXNSZWFjdDE2ID8gX3JlYWN0RG9tMi5kZWZhdWx0LmNyZWF0ZVBvcnRhbCA6IF9yZWFjdERvbTIuZGVmYXVsdC51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjtcbn07XG5cbmZ1bmN0aW9uIGdldFBhcmVudEVsZW1lbnQocGFyZW50U2VsZWN0b3IpIHtcbiAgcmV0dXJuIHBhcmVudFNlbGVjdG9yKCk7XG59XG5cbnZhciBNb2RhbCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhNb2RhbCwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTW9kYWwoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vZGFsKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBNb2RhbC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE1vZGFsKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMucmVtb3ZlUG9ydGFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgIWlzUmVhY3QxNiAmJiBfcmVhY3REb20yLmRlZmF1bHQudW5tb3VudENvbXBvbmVudEF0Tm9kZShfdGhpcy5ub2RlKTtcbiAgICAgIHZhciBwYXJlbnQgPSBnZXRQYXJlbnRFbGVtZW50KF90aGlzLnByb3BzLnBhcmVudFNlbGVjdG9yKTtcbiAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LmNvbnRhaW5zKF90aGlzLm5vZGUpKSB7XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChfdGhpcy5ub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUud2FybignUmVhY3QtTW9kYWw6IFwicGFyZW50U2VsZWN0b3JcIiBwcm9wIGRpZCBub3QgcmV0dXJuZWQgYW55IERPTSAnICsgXCJlbGVtZW50LiBNYWtlIHN1cmUgdGhhdCB0aGUgcGFyZW50IGVsZW1lbnQgaXMgdW5tb3VudGVkIHRvIFwiICsgXCJhdm9pZCBhbnkgbWVtb3J5IGxlYWtzLlwiKTtcbiAgICAgIH1cbiAgICB9LCBfdGhpcy5wb3J0YWxSZWYgPSBmdW5jdGlvbiAocmVmKSB7XG4gICAgICBfdGhpcy5wb3J0YWwgPSByZWY7XG4gICAgfSwgX3RoaXMucmVuZGVyUG9ydGFsID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICB2YXIgY3JlYXRlUG9ydGFsID0gZ2V0Q3JlYXRlUG9ydGFsKCk7XG4gICAgICB2YXIgcG9ydGFsID0gY3JlYXRlUG9ydGFsKF90aGlzLCBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChfTW9kYWxQb3J0YWwyLmRlZmF1bHQsIF9leHRlbmRzKHsgZGVmYXVsdFN0eWxlczogTW9kYWwuZGVmYXVsdFN0eWxlcyB9LCBwcm9wcykpLCBfdGhpcy5ub2RlKTtcbiAgICAgIF90aGlzLnBvcnRhbFJlZihwb3J0YWwpO1xuICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1vZGFsLCBbe1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIGlmICghX3NhZmVIVE1MRWxlbWVudC5jYW5Vc2VET00pIHJldHVybjtcblxuICAgICAgaWYgKCFpc1JlYWN0MTYpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gY3JlYXRlSFRNTEVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB9XG4gICAgICB0aGlzLm5vZGUuY2xhc3NOYW1lID0gdGhpcy5wcm9wcy5wb3J0YWxDbGFzc05hbWU7XG5cbiAgICAgIHZhciBwYXJlbnQgPSBnZXRQYXJlbnRFbGVtZW50KHRoaXMucHJvcHMucGFyZW50U2VsZWN0b3IpO1xuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMubm9kZSk7XG5cbiAgICAgICFpc1JlYWN0MTYgJiYgdGhpcy5yZW5kZXJQb3J0YWwodGhpcy5wcm9wcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNuYXBzaG90QmVmb3JlVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgdmFyIHByZXZQYXJlbnQgPSBnZXRQYXJlbnRFbGVtZW50KHByZXZQcm9wcy5wYXJlbnRTZWxlY3Rvcik7XG4gICAgICB2YXIgbmV4dFBhcmVudCA9IGdldFBhcmVudEVsZW1lbnQodGhpcy5wcm9wcy5wYXJlbnRTZWxlY3Rvcik7XG4gICAgICByZXR1cm4geyBwcmV2UGFyZW50OiBwcmV2UGFyZW50LCBuZXh0UGFyZW50OiBuZXh0UGFyZW50IH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudERpZFVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBfLCBzbmFwc2hvdCkge1xuICAgICAgaWYgKCFfc2FmZUhUTUxFbGVtZW50LmNhblVzZURPTSkgcmV0dXJuO1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgaXNPcGVuID0gX3Byb3BzLmlzT3BlbixcbiAgICAgICAgICBwb3J0YWxDbGFzc05hbWUgPSBfcHJvcHMucG9ydGFsQ2xhc3NOYW1lO1xuXG5cbiAgICAgIGlmIChwcmV2UHJvcHMucG9ydGFsQ2xhc3NOYW1lICE9PSBwb3J0YWxDbGFzc05hbWUpIHtcbiAgICAgICAgdGhpcy5ub2RlLmNsYXNzTmFtZSA9IHBvcnRhbENsYXNzTmFtZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZQYXJlbnQgPSBzbmFwc2hvdC5wcmV2UGFyZW50LFxuICAgICAgICAgIG5leHRQYXJlbnQgPSBzbmFwc2hvdC5uZXh0UGFyZW50O1xuXG4gICAgICBpZiAobmV4dFBhcmVudCAhPT0gcHJldlBhcmVudCkge1xuICAgICAgICBwcmV2UGFyZW50LnJlbW92ZUNoaWxkKHRoaXMubm9kZSk7XG4gICAgICAgIG5leHRQYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RvcCB1bm5lY2Vzc2FyeSByZW5kZXJzIGlmIG1vZGFsIGlzIHJlbWFpbmluZyBjbG9zZWRcbiAgICAgIGlmICghcHJldlByb3BzLmlzT3BlbiAmJiAhaXNPcGVuKSByZXR1cm47XG5cbiAgICAgICFpc1JlYWN0MTYgJiYgdGhpcy5yZW5kZXJQb3J0YWwodGhpcy5wcm9wcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgaWYgKCFfc2FmZUhUTUxFbGVtZW50LmNhblVzZURPTSB8fCAhdGhpcy5ub2RlIHx8ICF0aGlzLnBvcnRhbCkgcmV0dXJuO1xuXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnBvcnRhbC5zdGF0ZTtcbiAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgdmFyIGNsb3Nlc0F0ID0gc3RhdGUuaXNPcGVuICYmIHRoaXMucHJvcHMuY2xvc2VUaW1lb3V0TVMgJiYgKHN0YXRlLmNsb3Nlc0F0IHx8IG5vdyArIHRoaXMucHJvcHMuY2xvc2VUaW1lb3V0TVMpO1xuXG4gICAgICBpZiAoY2xvc2VzQXQpIHtcbiAgICAgICAgaWYgKCFzdGF0ZS5iZWZvcmVDbG9zZSkge1xuICAgICAgICAgIHRoaXMucG9ydGFsLmNsb3NlV2l0aFRpbWVvdXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5yZW1vdmVQb3J0YWwsIGNsb3Nlc0F0IC0gbm93KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUG9ydGFsKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICBpZiAoIV9zYWZlSFRNTEVsZW1lbnQuY2FuVXNlRE9NIHx8ICFpc1JlYWN0MTYpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5ub2RlICYmIGlzUmVhY3QxNikge1xuICAgICAgICB0aGlzLm5vZGUgPSBjcmVhdGVIVE1MRWxlbWVudChcImRpdlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNyZWF0ZVBvcnRhbCA9IGdldENyZWF0ZVBvcnRhbCgpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChfTW9kYWxQb3J0YWwyLmRlZmF1bHQsIF9leHRlbmRzKHtcbiAgICAgICAgcmVmOiB0aGlzLnBvcnRhbFJlZixcbiAgICAgICAgZGVmYXVsdFN0eWxlczogTW9kYWwuZGVmYXVsdFN0eWxlc1xuICAgICAgfSwgdGhpcy5wcm9wcykpLCB0aGlzLm5vZGUpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInNldEFwcEVsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QXBwRWxlbWVudChlbGVtZW50KSB7XG4gICAgICBhcmlhQXBwSGlkZXIuc2V0RWxlbWVudChlbGVtZW50KTtcbiAgICB9XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9uby11bnVzZWQtcHJvcC10eXBlcyAqL1xuXG4gICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC9uby11bnVzZWQtcHJvcC10eXBlcyAqL1xuXG4gIH1dKTtcblxuICByZXR1cm4gTW9kYWw7XG59KF9yZWFjdC5Db21wb25lbnQpO1xuXG5Nb2RhbC5wcm9wVHlwZXMgPSB7XG4gIGlzT3BlbjogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLmlzUmVxdWlyZWQsXG4gIHN0eWxlOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnNoYXBlKHtcbiAgICBjb250ZW50OiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdCxcbiAgICBvdmVybGF5OiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdFxuICB9KSxcbiAgcG9ydGFsQ2xhc3NOYW1lOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcbiAgYm9keU9wZW5DbGFzc05hbWU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxuICBodG1sT3BlbkNsYXNzTmFtZTogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXG4gIGNsYXNzTmFtZTogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLCBfcHJvcFR5cGVzMi5kZWZhdWx0LnNoYXBlKHtcbiAgICBiYXNlOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGFmdGVyT3BlbjogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBiZWZvcmVDbG9zZTogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcuaXNSZXF1aXJlZFxuICB9KV0pLFxuICBvdmVybGF5Q2xhc3NOYW1lOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsIF9wcm9wVHlwZXMyLmRlZmF1bHQuc2hhcGUoe1xuICAgIGJhc2U6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgYWZ0ZXJPcGVuOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGJlZm9yZUNsb3NlOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZy5pc1JlcXVpcmVkXG4gIH0pXSksXG4gIGFwcEVsZW1lbnQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzMi5kZWZhdWx0Lmluc3RhbmNlT2YoX3NhZmVIVE1MRWxlbWVudDIuZGVmYXVsdCksIF9wcm9wVHlwZXMyLmRlZmF1bHQuaW5zdGFuY2VPZihfc2FmZUhUTUxFbGVtZW50LlNhZmVIVE1MQ29sbGVjdGlvbiksIF9wcm9wVHlwZXMyLmRlZmF1bHQuaW5zdGFuY2VPZihfc2FmZUhUTUxFbGVtZW50LlNhZmVOb2RlTGlzdCksIF9wcm9wVHlwZXMyLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzMi5kZWZhdWx0Lmluc3RhbmNlT2YoX3NhZmVIVE1MRWxlbWVudDIuZGVmYXVsdCkpXSksXG4gIG9uQWZ0ZXJPcGVuOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG4gIG9uUmVxdWVzdENsb3NlOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG4gIGNsb3NlVGltZW91dE1TOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm51bWJlcixcbiAgYXJpYUhpZGVBcHA6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcbiAgc2hvdWxkRm9jdXNBZnRlclJlbmRlcjogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuICBzaG91bGRDbG9zZU9uT3ZlcmxheUNsaWNrOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXG4gIHNob3VsZFJldHVybkZvY3VzQWZ0ZXJDbG9zZTogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuICBwcmV2ZW50U2Nyb2xsOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXG4gIHBhcmVudFNlbGVjdG9yOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG4gIGFyaWE6IF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0LFxuICBkYXRhOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdCxcbiAgcm9sZTogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXG4gIGNvbnRlbnRMYWJlbDogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXG4gIHNob3VsZENsb3NlT25Fc2M6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcbiAgb3ZlcmxheVJlZjogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxuICBjb250ZW50UmVmOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG4gIGlkOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcbiAgb3ZlcmxheUVsZW1lbnQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcbiAgY29udGVudEVsZW1lbnQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuY1xufTtcbk1vZGFsLmRlZmF1bHRQcm9wcyA9IHtcbiAgaXNPcGVuOiBmYWxzZSxcbiAgcG9ydGFsQ2xhc3NOYW1lOiBwb3J0YWxDbGFzc05hbWUsXG4gIGJvZHlPcGVuQ2xhc3NOYW1lOiBib2R5T3BlbkNsYXNzTmFtZSxcbiAgcm9sZTogXCJkaWFsb2dcIixcbiAgYXJpYUhpZGVBcHA6IHRydWUsXG4gIGNsb3NlVGltZW91dE1TOiAwLFxuICBzaG91bGRGb2N1c0FmdGVyUmVuZGVyOiB0cnVlLFxuICBzaG91bGRDbG9zZU9uRXNjOiB0cnVlLFxuICBzaG91bGRDbG9zZU9uT3ZlcmxheUNsaWNrOiB0cnVlLFxuICBzaG91bGRSZXR1cm5Gb2N1c0FmdGVyQ2xvc2U6IHRydWUsXG4gIHByZXZlbnRTY3JvbGw6IGZhbHNlLFxuICBwYXJlbnRTZWxlY3RvcjogZnVuY3Rpb24gcGFyZW50U2VsZWN0b3IoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gIH0sXG4gIG92ZXJsYXlFbGVtZW50OiBmdW5jdGlvbiBvdmVybGF5RWxlbWVudChwcm9wcywgY29udGVudEVsKSB7XG4gICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgXCJkaXZcIixcbiAgICAgIHByb3BzLFxuICAgICAgY29udGVudEVsXG4gICAgKTtcbiAgfSxcbiAgY29udGVudEVsZW1lbnQ6IGZ1bmN0aW9uIGNvbnRlbnRFbGVtZW50KHByb3BzLCBjaGlsZHJlbikge1xuICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgIFwiZGl2XCIsXG4gICAgICBwcm9wcyxcbiAgICAgIGNoaWxkcmVuXG4gICAgKTtcbiAgfVxufTtcbk1vZGFsLmRlZmF1bHRTdHlsZXMgPSB7XG4gIG92ZXJsYXk6IHtcbiAgICBwb3NpdGlvbjogXCJmaXhlZFwiLFxuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjc1KVwiXG4gIH0sXG4gIGNvbnRlbnQ6IHtcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgIHRvcDogXCI0MHB4XCIsXG4gICAgbGVmdDogXCI0MHB4XCIsXG4gICAgcmlnaHQ6IFwiNDBweFwiLFxuICAgIGJvdHRvbTogXCI0MHB4XCIsXG4gICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjY2NjXCIsXG4gICAgYmFja2dyb3VuZDogXCIjZmZmXCIsXG4gICAgb3ZlcmZsb3c6IFwiYXV0b1wiLFxuICAgIFdlYmtpdE92ZXJmbG93U2Nyb2xsaW5nOiBcInRvdWNoXCIsXG4gICAgYm9yZGVyUmFkaXVzOiBcIjRweFwiLFxuICAgIG91dGxpbmU6IFwibm9uZVwiLFxuICAgIHBhZGRpbmc6IFwiMjBweFwiXG4gIH1cbn07XG5cblxuKDAsIF9yZWFjdExpZmVjeWNsZXNDb21wYXQucG9seWZpbGwpKE1vZGFsKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBNb2RhbC5zZXRDcmVhdGVIVE1MRWxlbWVudCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBjcmVhdGVIVE1MRWxlbWVudCA9IGZuO1xuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBNb2RhbDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-modal/lib/components/Modal.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-modal/lib/components/ModalPortal.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-modal/lib/components/ModalPortal.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nvar _propTypes = __webpack_require__(/*! prop-types */ \"(app-pages-browser)/./node_modules/prop-types/index.js\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _focusManager = __webpack_require__(/*! ../helpers/focusManager */ \"(app-pages-browser)/./node_modules/react-modal/lib/helpers/focusManager.js\");\n\nvar focusManager = _interopRequireWildcard(_focusManager);\n\nvar _scopeTab = __webpack_require__(/*! ../helpers/scopeTab */ \"(app-pages-browser)/./node_modules/react-modal/lib/helpers/scopeTab.js\");\n\nvar _scopeTab2 = _interopRequireDefault(_scopeTab);\n\nvar _ariaAppHider = __webpack_require__(/*! ../helpers/ariaAppHider */ \"(app-pages-browser)/./node_modules/react-modal/lib/helpers/ariaAppHider.js\");\n\nvar ariaAppHider = _interopRequireWildcard(_ariaAppHider);\n\nvar _classList = __webpack_require__(/*! ../helpers/classList */ \"(app-pages-browser)/./node_modules/react-modal/lib/helpers/classList.js\");\n\nvar classList = _interopRequireWildcard(_classList);\n\nvar _safeHTMLElement = __webpack_require__(/*! ../helpers/safeHTMLElement */ \"(app-pages-browser)/./node_modules/react-modal/lib/helpers/safeHTMLElement.js\");\n\nvar _safeHTMLElement2 = _interopRequireDefault(_safeHTMLElement);\n\nvar _portalOpenInstances = __webpack_require__(/*! ../helpers/portalOpenInstances */ \"(app-pages-browser)/./node_modules/react-modal/lib/helpers/portalOpenInstances.js\");\n\nvar _portalOpenInstances2 = _interopRequireDefault(_portalOpenInstances);\n\n__webpack_require__(/*! ../helpers/bodyTrap */ \"(app-pages-browser)/./node_modules/react-modal/lib/helpers/bodyTrap.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// so that our CSS is statically analyzable\nvar CLASS_NAMES = {\n  overlay: \"ReactModal__Overlay\",\n  content: \"ReactModal__Content\"\n};\n\n/**\n * We need to support the deprecated `KeyboardEvent.keyCode` in addition to\n * `KeyboardEvent.code` for apps that still support IE11. Can be removed when\n * `react-modal` only supports React >18 (which dropped IE support).\n */\nvar isTabKey = function isTabKey(event) {\n  return event.code === \"Tab\" || event.keyCode === 9;\n};\nvar isEscKey = function isEscKey(event) {\n  return event.code === \"Escape\" || event.keyCode === 27;\n};\n\nvar ariaHiddenInstances = 0;\n\nvar ModalPortal = function (_Component) {\n  _inherits(ModalPortal, _Component);\n\n  function ModalPortal(props) {\n    _classCallCheck(this, ModalPortal);\n\n    var _this = _possibleConstructorReturn(this, (ModalPortal.__proto__ || Object.getPrototypeOf(ModalPortal)).call(this, props));\n\n    _this.setOverlayRef = function (overlay) {\n      _this.overlay = overlay;\n      _this.props.overlayRef && _this.props.overlayRef(overlay);\n    };\n\n    _this.setContentRef = function (content) {\n      _this.content = content;\n      _this.props.contentRef && _this.props.contentRef(content);\n    };\n\n    _this.afterClose = function () {\n      var _this$props = _this.props,\n          appElement = _this$props.appElement,\n          ariaHideApp = _this$props.ariaHideApp,\n          htmlOpenClassName = _this$props.htmlOpenClassName,\n          bodyOpenClassName = _this$props.bodyOpenClassName,\n          parentSelector = _this$props.parentSelector;\n\n\n      var parentDocument = parentSelector && parentSelector().ownerDocument || document;\n\n      // Remove classes.\n      bodyOpenClassName && classList.remove(parentDocument.body, bodyOpenClassName);\n\n      htmlOpenClassName && classList.remove(parentDocument.getElementsByTagName(\"html\")[0], htmlOpenClassName);\n\n      // Reset aria-hidden attribute if all modals have been removed\n      if (ariaHideApp && ariaHiddenInstances > 0) {\n        ariaHiddenInstances -= 1;\n\n        if (ariaHiddenInstances === 0) {\n          ariaAppHider.show(appElement);\n        }\n      }\n\n      if (_this.props.shouldFocusAfterRender) {\n        if (_this.props.shouldReturnFocusAfterClose) {\n          focusManager.returnFocus(_this.props.preventScroll);\n          focusManager.teardownScopedFocus();\n        } else {\n          focusManager.popWithoutFocus();\n        }\n      }\n\n      if (_this.props.onAfterClose) {\n        _this.props.onAfterClose();\n      }\n\n      _portalOpenInstances2.default.deregister(_this);\n    };\n\n    _this.open = function () {\n      _this.beforeOpen();\n      if (_this.state.afterOpen && _this.state.beforeClose) {\n        clearTimeout(_this.closeTimer);\n        _this.setState({ beforeClose: false });\n      } else {\n        if (_this.props.shouldFocusAfterRender) {\n          focusManager.setupScopedFocus(_this.node);\n          focusManager.markForFocusLater();\n        }\n\n        _this.setState({ isOpen: true }, function () {\n          _this.openAnimationFrame = requestAnimationFrame(function () {\n            _this.setState({ afterOpen: true });\n\n            if (_this.props.isOpen && _this.props.onAfterOpen) {\n              _this.props.onAfterOpen({\n                overlayEl: _this.overlay,\n                contentEl: _this.content\n              });\n            }\n          });\n        });\n      }\n    };\n\n    _this.close = function () {\n      if (_this.props.closeTimeoutMS > 0) {\n        _this.closeWithTimeout();\n      } else {\n        _this.closeWithoutTimeout();\n      }\n    };\n\n    _this.focusContent = function () {\n      return _this.content && !_this.contentHasFocus() && _this.content.focus({ preventScroll: true });\n    };\n\n    _this.closeWithTimeout = function () {\n      var closesAt = Date.now() + _this.props.closeTimeoutMS;\n      _this.setState({ beforeClose: true, closesAt: closesAt }, function () {\n        _this.closeTimer = setTimeout(_this.closeWithoutTimeout, _this.state.closesAt - Date.now());\n      });\n    };\n\n    _this.closeWithoutTimeout = function () {\n      _this.setState({\n        beforeClose: false,\n        isOpen: false,\n        afterOpen: false,\n        closesAt: null\n      }, _this.afterClose);\n    };\n\n    _this.handleKeyDown = function (event) {\n      if (isTabKey(event)) {\n        (0, _scopeTab2.default)(_this.content, event);\n      }\n\n      if (_this.props.shouldCloseOnEsc && isEscKey(event)) {\n        event.stopPropagation();\n        _this.requestClose(event);\n      }\n    };\n\n    _this.handleOverlayOnClick = function (event) {\n      if (_this.shouldClose === null) {\n        _this.shouldClose = true;\n      }\n\n      if (_this.shouldClose && _this.props.shouldCloseOnOverlayClick) {\n        if (_this.ownerHandlesClose()) {\n          _this.requestClose(event);\n        } else {\n          _this.focusContent();\n        }\n      }\n      _this.shouldClose = null;\n    };\n\n    _this.handleContentOnMouseUp = function () {\n      _this.shouldClose = false;\n    };\n\n    _this.handleOverlayOnMouseDown = function (event) {\n      if (!_this.props.shouldCloseOnOverlayClick && event.target == _this.overlay) {\n        event.preventDefault();\n      }\n    };\n\n    _this.handleContentOnClick = function () {\n      _this.shouldClose = false;\n    };\n\n    _this.handleContentOnMouseDown = function () {\n      _this.shouldClose = false;\n    };\n\n    _this.requestClose = function (event) {\n      return _this.ownerHandlesClose() && _this.props.onRequestClose(event);\n    };\n\n    _this.ownerHandlesClose = function () {\n      return _this.props.onRequestClose;\n    };\n\n    _this.shouldBeClosed = function () {\n      return !_this.state.isOpen && !_this.state.beforeClose;\n    };\n\n    _this.contentHasFocus = function () {\n      return document.activeElement === _this.content || _this.content.contains(document.activeElement);\n    };\n\n    _this.buildClassName = function (which, additional) {\n      var classNames = (typeof additional === \"undefined\" ? \"undefined\" : _typeof(additional)) === \"object\" ? additional : {\n        base: CLASS_NAMES[which],\n        afterOpen: CLASS_NAMES[which] + \"--after-open\",\n        beforeClose: CLASS_NAMES[which] + \"--before-close\"\n      };\n      var className = classNames.base;\n      if (_this.state.afterOpen) {\n        className = className + \" \" + classNames.afterOpen;\n      }\n      if (_this.state.beforeClose) {\n        className = className + \" \" + classNames.beforeClose;\n      }\n      return typeof additional === \"string\" && additional ? className + \" \" + additional : className;\n    };\n\n    _this.attributesFromObject = function (prefix, items) {\n      return Object.keys(items).reduce(function (acc, name) {\n        acc[prefix + \"-\" + name] = items[name];\n        return acc;\n      }, {});\n    };\n\n    _this.state = {\n      afterOpen: false,\n      beforeClose: false\n    };\n\n    _this.shouldClose = null;\n    _this.moveFromContentToOverlay = null;\n    return _this;\n  }\n\n  _createClass(ModalPortal, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.isOpen) {\n        this.open();\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      if (true) {\n        if (prevProps.bodyOpenClassName !== this.props.bodyOpenClassName) {\n          // eslint-disable-next-line no-console\n          console.warn('React-Modal: \"bodyOpenClassName\" prop has been modified. ' + \"This may cause unexpected behavior when multiple modals are open.\");\n        }\n        if (prevProps.htmlOpenClassName !== this.props.htmlOpenClassName) {\n          // eslint-disable-next-line no-console\n          console.warn('React-Modal: \"htmlOpenClassName\" prop has been modified. ' + \"This may cause unexpected behavior when multiple modals are open.\");\n        }\n      }\n\n      if (this.props.isOpen && !prevProps.isOpen) {\n        this.open();\n      } else if (!this.props.isOpen && prevProps.isOpen) {\n        this.close();\n      }\n\n      // Focus only needs to be set once when the modal is being opened\n      if (this.props.shouldFocusAfterRender && this.state.isOpen && !prevState.isOpen) {\n        this.focusContent();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.state.isOpen) {\n        this.afterClose();\n      }\n      clearTimeout(this.closeTimer);\n      cancelAnimationFrame(this.openAnimationFrame);\n    }\n  }, {\n    key: \"beforeOpen\",\n    value: function beforeOpen() {\n      var _props = this.props,\n          appElement = _props.appElement,\n          ariaHideApp = _props.ariaHideApp,\n          htmlOpenClassName = _props.htmlOpenClassName,\n          bodyOpenClassName = _props.bodyOpenClassName,\n          parentSelector = _props.parentSelector;\n\n\n      var parentDocument = parentSelector && parentSelector().ownerDocument || document;\n\n      // Add classes.\n      bodyOpenClassName && classList.add(parentDocument.body, bodyOpenClassName);\n\n      htmlOpenClassName && classList.add(parentDocument.getElementsByTagName(\"html\")[0], htmlOpenClassName);\n\n      if (ariaHideApp) {\n        ariaHiddenInstances += 1;\n        ariaAppHider.hide(appElement);\n      }\n\n      _portalOpenInstances2.default.register(this);\n    }\n\n    // Don't steal focus from inner elements\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _props2 = this.props,\n          id = _props2.id,\n          className = _props2.className,\n          overlayClassName = _props2.overlayClassName,\n          defaultStyles = _props2.defaultStyles,\n          children = _props2.children;\n\n      var contentStyles = className ? {} : defaultStyles.content;\n      var overlayStyles = overlayClassName ? {} : defaultStyles.overlay;\n\n      if (this.shouldBeClosed()) {\n        return null;\n      }\n\n      var overlayProps = {\n        ref: this.setOverlayRef,\n        className: this.buildClassName(\"overlay\", overlayClassName),\n        style: _extends({}, overlayStyles, this.props.style.overlay),\n        onClick: this.handleOverlayOnClick,\n        onMouseDown: this.handleOverlayOnMouseDown\n      };\n\n      var contentProps = _extends({\n        id: id,\n        ref: this.setContentRef,\n        style: _extends({}, contentStyles, this.props.style.content),\n        className: this.buildClassName(\"content\", className),\n        tabIndex: \"-1\",\n        onKeyDown: this.handleKeyDown,\n        onMouseDown: this.handleContentOnMouseDown,\n        onMouseUp: this.handleContentOnMouseUp,\n        onClick: this.handleContentOnClick,\n        role: this.props.role,\n        \"aria-label\": this.props.contentLabel\n      }, this.attributesFromObject(\"aria\", _extends({ modal: true }, this.props.aria)), this.attributesFromObject(\"data\", this.props.data || {}), {\n        \"data-testid\": this.props.testId\n      });\n\n      var contentElement = this.props.contentElement(contentProps, children);\n      return this.props.overlayElement(overlayProps, contentElement);\n    }\n  }]);\n\n  return ModalPortal;\n}(_react.Component);\n\nModalPortal.defaultProps = {\n  style: {\n    overlay: {},\n    content: {}\n  },\n  defaultStyles: {}\n};\nModalPortal.propTypes = {\n  isOpen: _propTypes2.default.bool.isRequired,\n  defaultStyles: _propTypes2.default.shape({\n    content: _propTypes2.default.object,\n    overlay: _propTypes2.default.object\n  }),\n  style: _propTypes2.default.shape({\n    content: _propTypes2.default.object,\n    overlay: _propTypes2.default.object\n  }),\n  className: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),\n  overlayClassName: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),\n  parentSelector: _propTypes2.default.func,\n  bodyOpenClassName: _propTypes2.default.string,\n  htmlOpenClassName: _propTypes2.default.string,\n  ariaHideApp: _propTypes2.default.bool,\n  appElement: _propTypes2.default.oneOfType([_propTypes2.default.instanceOf(_safeHTMLElement2.default), _propTypes2.default.instanceOf(_safeHTMLElement.SafeHTMLCollection), _propTypes2.default.instanceOf(_safeHTMLElement.SafeNodeList), _propTypes2.default.arrayOf(_propTypes2.default.instanceOf(_safeHTMLElement2.default))]),\n  onAfterOpen: _propTypes2.default.func,\n  onAfterClose: _propTypes2.default.func,\n  onRequestClose: _propTypes2.default.func,\n  closeTimeoutMS: _propTypes2.default.number,\n  shouldFocusAfterRender: _propTypes2.default.bool,\n  shouldCloseOnOverlayClick: _propTypes2.default.bool,\n  shouldReturnFocusAfterClose: _propTypes2.default.bool,\n  preventScroll: _propTypes2.default.bool,\n  role: _propTypes2.default.string,\n  contentLabel: _propTypes2.default.string,\n  aria: _propTypes2.default.object,\n  data: _propTypes2.default.object,\n  children: _propTypes2.default.node,\n  shouldCloseOnEsc: _propTypes2.default.bool,\n  overlayRef: _propTypes2.default.func,\n  contentRef: _propTypes2.default.func,\n  id: _propTypes2.default.string,\n  overlayElement: _propTypes2.default.func,\n  contentElement: _propTypes2.default.func,\n  testId: _propTypes2.default.string\n};\nexports[\"default\"] = ModalPortal;\nmodule.exports = exports[\"default\"];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9saWIvY29tcG9uZW50cy9Nb2RhbFBvcnRhbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7O0FBRUYsb0RBQW9ELGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCxpQ0FBaUM7O0FBRWhQLHFHQUFxRyxxQkFBcUIsbUJBQW1COztBQUU3SSxpQ0FBaUMsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsK0RBQStELHlEQUF5RCxxRUFBcUUsNkRBQTZELHdCQUF3Qjs7QUFFampCLGFBQWEsbUJBQU8sQ0FBQyxtRkFBTzs7QUFFNUIsaUJBQWlCLG1CQUFPLENBQUMsMEVBQVk7O0FBRXJDOztBQUVBLG9CQUFvQixtQkFBTyxDQUFDLDJHQUF5Qjs7QUFFckQ7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsbUdBQXFCOztBQUU3Qzs7QUFFQSxvQkFBb0IsbUJBQU8sQ0FBQywyR0FBeUI7O0FBRXJEOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLHFHQUFzQjs7QUFFL0M7O0FBRUEsdUJBQXVCLG1CQUFPLENBQUMsaUhBQTRCOztBQUUzRDs7QUFFQSwyQkFBMkIsbUJBQU8sQ0FBQyx5SEFBZ0M7O0FBRW5FOztBQUVBLG1CQUFPLENBQUMsbUdBQXFCOztBQUU3Qix3Q0FBd0MsNkJBQTZCLGNBQWMsT0FBTyxpQkFBaUIsbUJBQW1CLHVCQUF1QixnRkFBZ0Ysc0JBQXNCOztBQUUzUCx1Q0FBdUMsdUNBQXVDOztBQUU5RSxrREFBa0QsMENBQTBDOztBQUU1RixrREFBa0QsYUFBYSx5RkFBeUY7O0FBRXhKLDJDQUEyQywrREFBK0QsdUdBQXVHLHlFQUF5RSxlQUFlLDBFQUEwRSxHQUFHOztBQUV0WDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL2xpYi9jb21wb25lbnRzL01vZGFsUG9ydGFsLmpzP2QwZTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcblxudmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlKFwicHJvcC10eXBlc1wiKTtcblxudmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxudmFyIF9mb2N1c01hbmFnZXIgPSByZXF1aXJlKFwiLi4vaGVscGVycy9mb2N1c01hbmFnZXJcIik7XG5cbnZhciBmb2N1c01hbmFnZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfZm9jdXNNYW5hZ2VyKTtcblxudmFyIF9zY29wZVRhYiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3Njb3BlVGFiXCIpO1xuXG52YXIgX3Njb3BlVGFiMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Njb3BlVGFiKTtcblxudmFyIF9hcmlhQXBwSGlkZXIgPSByZXF1aXJlKFwiLi4vaGVscGVycy9hcmlhQXBwSGlkZXJcIik7XG5cbnZhciBhcmlhQXBwSGlkZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfYXJpYUFwcEhpZGVyKTtcblxudmFyIF9jbGFzc0xpc3QgPSByZXF1aXJlKFwiLi4vaGVscGVycy9jbGFzc0xpc3RcIik7XG5cbnZhciBjbGFzc0xpc3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfY2xhc3NMaXN0KTtcblxudmFyIF9zYWZlSFRNTEVsZW1lbnQgPSByZXF1aXJlKFwiLi4vaGVscGVycy9zYWZlSFRNTEVsZW1lbnRcIik7XG5cbnZhciBfc2FmZUhUTUxFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NhZmVIVE1MRWxlbWVudCk7XG5cbnZhciBfcG9ydGFsT3Blbkluc3RhbmNlcyA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3BvcnRhbE9wZW5JbnN0YW5jZXNcIik7XG5cbnZhciBfcG9ydGFsT3Blbkluc3RhbmNlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3J0YWxPcGVuSW5zdGFuY2VzKTtcblxucmVxdWlyZShcIi4uL2hlbHBlcnMvYm9keVRyYXBcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLy8gc28gdGhhdCBvdXIgQ1NTIGlzIHN0YXRpY2FsbHkgYW5hbHl6YWJsZVxudmFyIENMQVNTX05BTUVTID0ge1xuICBvdmVybGF5OiBcIlJlYWN0TW9kYWxfX092ZXJsYXlcIixcbiAgY29udGVudDogXCJSZWFjdE1vZGFsX19Db250ZW50XCJcbn07XG5cbi8qKlxuICogV2UgbmVlZCB0byBzdXBwb3J0IHRoZSBkZXByZWNhdGVkIGBLZXlib2FyZEV2ZW50LmtleUNvZGVgIGluIGFkZGl0aW9uIHRvXG4gKiBgS2V5Ym9hcmRFdmVudC5jb2RlYCBmb3IgYXBwcyB0aGF0IHN0aWxsIHN1cHBvcnQgSUUxMS4gQ2FuIGJlIHJlbW92ZWQgd2hlblxuICogYHJlYWN0LW1vZGFsYCBvbmx5IHN1cHBvcnRzIFJlYWN0ID4xOCAod2hpY2ggZHJvcHBlZCBJRSBzdXBwb3J0KS5cbiAqL1xudmFyIGlzVGFiS2V5ID0gZnVuY3Rpb24gaXNUYWJLZXkoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LmNvZGUgPT09IFwiVGFiXCIgfHwgZXZlbnQua2V5Q29kZSA9PT0gOTtcbn07XG52YXIgaXNFc2NLZXkgPSBmdW5jdGlvbiBpc0VzY0tleShldmVudCkge1xuICByZXR1cm4gZXZlbnQuY29kZSA9PT0gXCJFc2NhcGVcIiB8fCBldmVudC5rZXlDb2RlID09PSAyNztcbn07XG5cbnZhciBhcmlhSGlkZGVuSW5zdGFuY2VzID0gMDtcblxudmFyIE1vZGFsUG9ydGFsID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1vZGFsUG9ydGFsLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBNb2RhbFBvcnRhbChwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNb2RhbFBvcnRhbCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTW9kYWxQb3J0YWwuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihNb2RhbFBvcnRhbCkpLmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgIF90aGlzLnNldE92ZXJsYXlSZWYgPSBmdW5jdGlvbiAob3ZlcmxheSkge1xuICAgICAgX3RoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICBfdGhpcy5wcm9wcy5vdmVybGF5UmVmICYmIF90aGlzLnByb3BzLm92ZXJsYXlSZWYob3ZlcmxheSk7XG4gICAgfTtcblxuICAgIF90aGlzLnNldENvbnRlbnRSZWYgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgX3RoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICBfdGhpcy5wcm9wcy5jb250ZW50UmVmICYmIF90aGlzLnByb3BzLmNvbnRlbnRSZWYoY29udGVudCk7XG4gICAgfTtcblxuICAgIF90aGlzLmFmdGVyQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBhcHBFbGVtZW50ID0gX3RoaXMkcHJvcHMuYXBwRWxlbWVudCxcbiAgICAgICAgICBhcmlhSGlkZUFwcCA9IF90aGlzJHByb3BzLmFyaWFIaWRlQXBwLFxuICAgICAgICAgIGh0bWxPcGVuQ2xhc3NOYW1lID0gX3RoaXMkcHJvcHMuaHRtbE9wZW5DbGFzc05hbWUsXG4gICAgICAgICAgYm9keU9wZW5DbGFzc05hbWUgPSBfdGhpcyRwcm9wcy5ib2R5T3BlbkNsYXNzTmFtZSxcbiAgICAgICAgICBwYXJlbnRTZWxlY3RvciA9IF90aGlzJHByb3BzLnBhcmVudFNlbGVjdG9yO1xuXG5cbiAgICAgIHZhciBwYXJlbnREb2N1bWVudCA9IHBhcmVudFNlbGVjdG9yICYmIHBhcmVudFNlbGVjdG9yKCkub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcblxuICAgICAgLy8gUmVtb3ZlIGNsYXNzZXMuXG4gICAgICBib2R5T3BlbkNsYXNzTmFtZSAmJiBjbGFzc0xpc3QucmVtb3ZlKHBhcmVudERvY3VtZW50LmJvZHksIGJvZHlPcGVuQ2xhc3NOYW1lKTtcblxuICAgICAgaHRtbE9wZW5DbGFzc05hbWUgJiYgY2xhc3NMaXN0LnJlbW92ZShwYXJlbnREb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImh0bWxcIilbMF0sIGh0bWxPcGVuQ2xhc3NOYW1lKTtcblxuICAgICAgLy8gUmVzZXQgYXJpYS1oaWRkZW4gYXR0cmlidXRlIGlmIGFsbCBtb2RhbHMgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgIGlmIChhcmlhSGlkZUFwcCAmJiBhcmlhSGlkZGVuSW5zdGFuY2VzID4gMCkge1xuICAgICAgICBhcmlhSGlkZGVuSW5zdGFuY2VzIC09IDE7XG5cbiAgICAgICAgaWYgKGFyaWFIaWRkZW5JbnN0YW5jZXMgPT09IDApIHtcbiAgICAgICAgICBhcmlhQXBwSGlkZXIuc2hvdyhhcHBFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMucHJvcHMuc2hvdWxkRm9jdXNBZnRlclJlbmRlcikge1xuICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2hvdWxkUmV0dXJuRm9jdXNBZnRlckNsb3NlKSB7XG4gICAgICAgICAgZm9jdXNNYW5hZ2VyLnJldHVybkZvY3VzKF90aGlzLnByb3BzLnByZXZlbnRTY3JvbGwpO1xuICAgICAgICAgIGZvY3VzTWFuYWdlci50ZWFyZG93blNjb3BlZEZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9jdXNNYW5hZ2VyLnBvcFdpdGhvdXRGb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkFmdGVyQ2xvc2UpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25BZnRlckNsb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIF9wb3J0YWxPcGVuSW5zdGFuY2VzMi5kZWZhdWx0LmRlcmVnaXN0ZXIoX3RoaXMpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuYmVmb3JlT3BlbigpO1xuICAgICAgaWYgKF90aGlzLnN0YXRlLmFmdGVyT3BlbiAmJiBfdGhpcy5zdGF0ZS5iZWZvcmVDbG9zZSkge1xuICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMuY2xvc2VUaW1lcik7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKHsgYmVmb3JlQ2xvc2U6IGZhbHNlIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKF90aGlzLnByb3BzLnNob3VsZEZvY3VzQWZ0ZXJSZW5kZXIpIHtcbiAgICAgICAgICBmb2N1c01hbmFnZXIuc2V0dXBTY29wZWRGb2N1cyhfdGhpcy5ub2RlKTtcbiAgICAgICAgICBmb2N1c01hbmFnZXIubWFya0ZvckZvY3VzTGF0ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLnNldFN0YXRlKHsgaXNPcGVuOiB0cnVlIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5vcGVuQW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBhZnRlck9wZW46IHRydWUgfSk7XG5cbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5pc09wZW4gJiYgX3RoaXMucHJvcHMub25BZnRlck9wZW4pIHtcbiAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25BZnRlck9wZW4oe1xuICAgICAgICAgICAgICAgIG92ZXJsYXlFbDogX3RoaXMub3ZlcmxheSxcbiAgICAgICAgICAgICAgICBjb250ZW50RWw6IF90aGlzLmNvbnRlbnRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5jbG9zZVRpbWVvdXRNUyA+IDApIHtcbiAgICAgICAgX3RoaXMuY2xvc2VXaXRoVGltZW91dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuY2xvc2VXaXRob3V0VGltZW91dCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5mb2N1c0NvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuY29udGVudCAmJiAhX3RoaXMuY29udGVudEhhc0ZvY3VzKCkgJiYgX3RoaXMuY29udGVudC5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLmNsb3NlV2l0aFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2xvc2VzQXQgPSBEYXRlLm5vdygpICsgX3RoaXMucHJvcHMuY2xvc2VUaW1lb3V0TVM7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7IGJlZm9yZUNsb3NlOiB0cnVlLCBjbG9zZXNBdDogY2xvc2VzQXQgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5jbG9zZVRpbWVyID0gc2V0VGltZW91dChfdGhpcy5jbG9zZVdpdGhvdXRUaW1lb3V0LCBfdGhpcy5zdGF0ZS5jbG9zZXNBdCAtIERhdGUubm93KCkpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLmNsb3NlV2l0aG91dFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGJlZm9yZUNsb3NlOiBmYWxzZSxcbiAgICAgICAgaXNPcGVuOiBmYWxzZSxcbiAgICAgICAgYWZ0ZXJPcGVuOiBmYWxzZSxcbiAgICAgICAgY2xvc2VzQXQ6IG51bGxcbiAgICAgIH0sIF90aGlzLmFmdGVyQ2xvc2UpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVLZXlEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoaXNUYWJLZXkoZXZlbnQpKSB7XG4gICAgICAgICgwLCBfc2NvcGVUYWIyLmRlZmF1bHQpKF90aGlzLmNvbnRlbnQsIGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLnByb3BzLnNob3VsZENsb3NlT25Fc2MgJiYgaXNFc2NLZXkoZXZlbnQpKSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0Q2xvc2UoZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVPdmVybGF5T25DbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKF90aGlzLnNob3VsZENsb3NlID09PSBudWxsKSB7XG4gICAgICAgIF90aGlzLnNob3VsZENsb3NlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLnNob3VsZENsb3NlICYmIF90aGlzLnByb3BzLnNob3VsZENsb3NlT25PdmVybGF5Q2xpY2spIHtcbiAgICAgICAgaWYgKF90aGlzLm93bmVySGFuZGxlc0Nsb3NlKCkpIHtcbiAgICAgICAgICBfdGhpcy5yZXF1ZXN0Q2xvc2UoZXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLmZvY3VzQ29udGVudCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfdGhpcy5zaG91bGRDbG9zZSA9IG51bGw7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZUNvbnRlbnRPbk1vdXNlVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zaG91bGRDbG9zZSA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVPdmVybGF5T25Nb3VzZURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICghX3RoaXMucHJvcHMuc2hvdWxkQ2xvc2VPbk92ZXJsYXlDbGljayAmJiBldmVudC50YXJnZXQgPT0gX3RoaXMub3ZlcmxheSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVDb250ZW50T25DbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNob3VsZENsb3NlID0gZmFsc2U7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZUNvbnRlbnRPbk1vdXNlRG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNob3VsZENsb3NlID0gZmFsc2U7XG4gICAgfTtcblxuICAgIF90aGlzLnJlcXVlc3RDbG9zZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIF90aGlzLm93bmVySGFuZGxlc0Nsb3NlKCkgJiYgX3RoaXMucHJvcHMub25SZXF1ZXN0Q2xvc2UoZXZlbnQpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vd25lckhhbmRsZXNDbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5vblJlcXVlc3RDbG9zZTtcbiAgICB9O1xuXG4gICAgX3RoaXMuc2hvdWxkQmVDbG9zZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIV90aGlzLnN0YXRlLmlzT3BlbiAmJiAhX3RoaXMuc3RhdGUuYmVmb3JlQ2xvc2U7XG4gICAgfTtcblxuICAgIF90aGlzLmNvbnRlbnRIYXNGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBfdGhpcy5jb250ZW50IHx8IF90aGlzLmNvbnRlbnQuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG4gICAgfTtcblxuICAgIF90aGlzLmJ1aWxkQ2xhc3NOYW1lID0gZnVuY3Rpb24gKHdoaWNoLCBhZGRpdGlvbmFsKSB7XG4gICAgICB2YXIgY2xhc3NOYW1lcyA9ICh0eXBlb2YgYWRkaXRpb25hbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGFkZGl0aW9uYWwpKSA9PT0gXCJvYmplY3RcIiA/IGFkZGl0aW9uYWwgOiB7XG4gICAgICAgIGJhc2U6IENMQVNTX05BTUVTW3doaWNoXSxcbiAgICAgICAgYWZ0ZXJPcGVuOiBDTEFTU19OQU1FU1t3aGljaF0gKyBcIi0tYWZ0ZXItb3BlblwiLFxuICAgICAgICBiZWZvcmVDbG9zZTogQ0xBU1NfTkFNRVNbd2hpY2hdICsgXCItLWJlZm9yZS1jbG9zZVwiXG4gICAgICB9O1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXMuYmFzZTtcbiAgICAgIGlmIChfdGhpcy5zdGF0ZS5hZnRlck9wZW4pIHtcbiAgICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lICsgXCIgXCIgKyBjbGFzc05hbWVzLmFmdGVyT3BlbjtcbiAgICAgIH1cbiAgICAgIGlmIChfdGhpcy5zdGF0ZS5iZWZvcmVDbG9zZSkge1xuICAgICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZXMuYmVmb3JlQ2xvc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIGFkZGl0aW9uYWwgPT09IFwic3RyaW5nXCIgJiYgYWRkaXRpb25hbCA/IGNsYXNzTmFtZSArIFwiIFwiICsgYWRkaXRpb25hbCA6IGNsYXNzTmFtZTtcbiAgICB9O1xuXG4gICAgX3RoaXMuYXR0cmlidXRlc0Zyb21PYmplY3QgPSBmdW5jdGlvbiAocHJlZml4LCBpdGVtcykge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGl0ZW1zKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgbmFtZSkge1xuICAgICAgICBhY2NbcHJlZml4ICsgXCItXCIgKyBuYW1lXSA9IGl0ZW1zW25hbWVdO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pO1xuICAgIH07XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGFmdGVyT3BlbjogZmFsc2UsXG4gICAgICBiZWZvcmVDbG9zZTogZmFsc2VcbiAgICB9O1xuXG4gICAgX3RoaXMuc2hvdWxkQ2xvc2UgPSBudWxsO1xuICAgIF90aGlzLm1vdmVGcm9tQ29udGVudFRvT3ZlcmxheSA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1vZGFsUG9ydGFsLCBbe1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmlzT3Blbikge1xuICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAocHJldlByb3BzLmJvZHlPcGVuQ2xhc3NOYW1lICE9PSB0aGlzLnByb3BzLmJvZHlPcGVuQ2xhc3NOYW1lKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1JlYWN0LU1vZGFsOiBcImJvZHlPcGVuQ2xhc3NOYW1lXCIgcHJvcCBoYXMgYmVlbiBtb2RpZmllZC4gJyArIFwiVGhpcyBtYXkgY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvciB3aGVuIG11bHRpcGxlIG1vZGFscyBhcmUgb3Blbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZQcm9wcy5odG1sT3BlbkNsYXNzTmFtZSAhPT0gdGhpcy5wcm9wcy5odG1sT3BlbkNsYXNzTmFtZSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS53YXJuKCdSZWFjdC1Nb2RhbDogXCJodG1sT3BlbkNsYXNzTmFtZVwiIHByb3AgaGFzIGJlZW4gbW9kaWZpZWQuICcgKyBcIlRoaXMgbWF5IGNhdXNlIHVuZXhwZWN0ZWQgYmVoYXZpb3Igd2hlbiBtdWx0aXBsZSBtb2RhbHMgYXJlIG9wZW4uXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLmlzT3BlbiAmJiAhcHJldlByb3BzLmlzT3Blbikge1xuICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMucHJvcHMuaXNPcGVuICYmIHByZXZQcm9wcy5pc09wZW4pIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBGb2N1cyBvbmx5IG5lZWRzIHRvIGJlIHNldCBvbmNlIHdoZW4gdGhlIG1vZGFsIGlzIGJlaW5nIG9wZW5lZFxuICAgICAgaWYgKHRoaXMucHJvcHMuc2hvdWxkRm9jdXNBZnRlclJlbmRlciAmJiB0aGlzLnN0YXRlLmlzT3BlbiAmJiAhcHJldlN0YXRlLmlzT3Blbikge1xuICAgICAgICB0aGlzLmZvY3VzQ29udGVudCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmlzT3Blbikge1xuICAgICAgICB0aGlzLmFmdGVyQ2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNsb3NlVGltZXIpO1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5vcGVuQW5pbWF0aW9uRnJhbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiZWZvcmVPcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJlZm9yZU9wZW4oKSB7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBhcHBFbGVtZW50ID0gX3Byb3BzLmFwcEVsZW1lbnQsXG4gICAgICAgICAgYXJpYUhpZGVBcHAgPSBfcHJvcHMuYXJpYUhpZGVBcHAsXG4gICAgICAgICAgaHRtbE9wZW5DbGFzc05hbWUgPSBfcHJvcHMuaHRtbE9wZW5DbGFzc05hbWUsXG4gICAgICAgICAgYm9keU9wZW5DbGFzc05hbWUgPSBfcHJvcHMuYm9keU9wZW5DbGFzc05hbWUsXG4gICAgICAgICAgcGFyZW50U2VsZWN0b3IgPSBfcHJvcHMucGFyZW50U2VsZWN0b3I7XG5cblxuICAgICAgdmFyIHBhcmVudERvY3VtZW50ID0gcGFyZW50U2VsZWN0b3IgJiYgcGFyZW50U2VsZWN0b3IoKS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuXG4gICAgICAvLyBBZGQgY2xhc3Nlcy5cbiAgICAgIGJvZHlPcGVuQ2xhc3NOYW1lICYmIGNsYXNzTGlzdC5hZGQocGFyZW50RG9jdW1lbnQuYm9keSwgYm9keU9wZW5DbGFzc05hbWUpO1xuXG4gICAgICBodG1sT3BlbkNsYXNzTmFtZSAmJiBjbGFzc0xpc3QuYWRkKHBhcmVudERvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaHRtbFwiKVswXSwgaHRtbE9wZW5DbGFzc05hbWUpO1xuXG4gICAgICBpZiAoYXJpYUhpZGVBcHApIHtcbiAgICAgICAgYXJpYUhpZGRlbkluc3RhbmNlcyArPSAxO1xuICAgICAgICBhcmlhQXBwSGlkZXIuaGlkZShhcHBFbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgX3BvcnRhbE9wZW5JbnN0YW5jZXMyLmRlZmF1bHQucmVnaXN0ZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gRG9uJ3Qgc3RlYWwgZm9jdXMgZnJvbSBpbm5lciBlbGVtZW50c1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBpZCA9IF9wcm9wczIuaWQsXG4gICAgICAgICAgY2xhc3NOYW1lID0gX3Byb3BzMi5jbGFzc05hbWUsXG4gICAgICAgICAgb3ZlcmxheUNsYXNzTmFtZSA9IF9wcm9wczIub3ZlcmxheUNsYXNzTmFtZSxcbiAgICAgICAgICBkZWZhdWx0U3R5bGVzID0gX3Byb3BzMi5kZWZhdWx0U3R5bGVzLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3Byb3BzMi5jaGlsZHJlbjtcblxuICAgICAgdmFyIGNvbnRlbnRTdHlsZXMgPSBjbGFzc05hbWUgPyB7fSA6IGRlZmF1bHRTdHlsZXMuY29udGVudDtcbiAgICAgIHZhciBvdmVybGF5U3R5bGVzID0gb3ZlcmxheUNsYXNzTmFtZSA/IHt9IDogZGVmYXVsdFN0eWxlcy5vdmVybGF5O1xuXG4gICAgICBpZiAodGhpcy5zaG91bGRCZUNsb3NlZCgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3ZlcmxheVByb3BzID0ge1xuICAgICAgICByZWY6IHRoaXMuc2V0T3ZlcmxheVJlZixcbiAgICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ2xhc3NOYW1lKFwib3ZlcmxheVwiLCBvdmVybGF5Q2xhc3NOYW1lKSxcbiAgICAgICAgc3R5bGU6IF9leHRlbmRzKHt9LCBvdmVybGF5U3R5bGVzLCB0aGlzLnByb3BzLnN0eWxlLm92ZXJsYXkpLFxuICAgICAgICBvbkNsaWNrOiB0aGlzLmhhbmRsZU92ZXJsYXlPbkNsaWNrLFxuICAgICAgICBvbk1vdXNlRG93bjogdGhpcy5oYW5kbGVPdmVybGF5T25Nb3VzZURvd25cbiAgICAgIH07XG5cbiAgICAgIHZhciBjb250ZW50UHJvcHMgPSBfZXh0ZW5kcyh7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgcmVmOiB0aGlzLnNldENvbnRlbnRSZWYsXG4gICAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgY29udGVudFN0eWxlcywgdGhpcy5wcm9wcy5zdHlsZS5jb250ZW50KSxcbiAgICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ2xhc3NOYW1lKFwiY29udGVudFwiLCBjbGFzc05hbWUpLFxuICAgICAgICB0YWJJbmRleDogXCItMVwiLFxuICAgICAgICBvbktleURvd246IHRoaXMuaGFuZGxlS2V5RG93bixcbiAgICAgICAgb25Nb3VzZURvd246IHRoaXMuaGFuZGxlQ29udGVudE9uTW91c2VEb3duLFxuICAgICAgICBvbk1vdXNlVXA6IHRoaXMuaGFuZGxlQ29udGVudE9uTW91c2VVcCxcbiAgICAgICAgb25DbGljazogdGhpcy5oYW5kbGVDb250ZW50T25DbGljayxcbiAgICAgICAgcm9sZTogdGhpcy5wcm9wcy5yb2xlLFxuICAgICAgICBcImFyaWEtbGFiZWxcIjogdGhpcy5wcm9wcy5jb250ZW50TGFiZWxcbiAgICAgIH0sIHRoaXMuYXR0cmlidXRlc0Zyb21PYmplY3QoXCJhcmlhXCIsIF9leHRlbmRzKHsgbW9kYWw6IHRydWUgfSwgdGhpcy5wcm9wcy5hcmlhKSksIHRoaXMuYXR0cmlidXRlc0Zyb21PYmplY3QoXCJkYXRhXCIsIHRoaXMucHJvcHMuZGF0YSB8fCB7fSksIHtcbiAgICAgICAgXCJkYXRhLXRlc3RpZFwiOiB0aGlzLnByb3BzLnRlc3RJZFxuICAgICAgfSk7XG5cbiAgICAgIHZhciBjb250ZW50RWxlbWVudCA9IHRoaXMucHJvcHMuY29udGVudEVsZW1lbnQoY29udGVudFByb3BzLCBjaGlsZHJlbik7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5vdmVybGF5RWxlbWVudChvdmVybGF5UHJvcHMsIGNvbnRlbnRFbGVtZW50KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTW9kYWxQb3J0YWw7XG59KF9yZWFjdC5Db21wb25lbnQpO1xuXG5Nb2RhbFBvcnRhbC5kZWZhdWx0UHJvcHMgPSB7XG4gIHN0eWxlOiB7XG4gICAgb3ZlcmxheToge30sXG4gICAgY29udGVudDoge31cbiAgfSxcbiAgZGVmYXVsdFN0eWxlczoge31cbn07XG5Nb2RhbFBvcnRhbC5wcm9wVHlwZXMgPSB7XG4gIGlzT3BlbjogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLmlzUmVxdWlyZWQsXG4gIGRlZmF1bHRTdHlsZXM6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc2hhcGUoe1xuICAgIGNvbnRlbnQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0LFxuICAgIG92ZXJsYXk6IF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0XG4gIH0pLFxuICBzdHlsZTogX3Byb3BUeXBlczIuZGVmYXVsdC5zaGFwZSh7XG4gICAgY29udGVudDogX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QsXG4gICAgb3ZlcmxheTogX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3RcbiAgfSksXG4gIGNsYXNzTmFtZTogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLCBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdF0pLFxuICBvdmVybGF5Q2xhc3NOYW1lOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsIF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0XSksXG4gIHBhcmVudFNlbGVjdG9yOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG4gIGJvZHlPcGVuQ2xhc3NOYW1lOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcbiAgaHRtbE9wZW5DbGFzc05hbWU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxuICBhcmlhSGlkZUFwcDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuICBhcHBFbGVtZW50OiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlczIuZGVmYXVsdC5pbnN0YW5jZU9mKF9zYWZlSFRNTEVsZW1lbnQyLmRlZmF1bHQpLCBfcHJvcFR5cGVzMi5kZWZhdWx0Lmluc3RhbmNlT2YoX3NhZmVIVE1MRWxlbWVudC5TYWZlSFRNTENvbGxlY3Rpb24pLCBfcHJvcFR5cGVzMi5kZWZhdWx0Lmluc3RhbmNlT2YoX3NhZmVIVE1MRWxlbWVudC5TYWZlTm9kZUxpc3QpLCBfcHJvcFR5cGVzMi5kZWZhdWx0LmFycmF5T2YoX3Byb3BUeXBlczIuZGVmYXVsdC5pbnN0YW5jZU9mKF9zYWZlSFRNTEVsZW1lbnQyLmRlZmF1bHQpKV0pLFxuICBvbkFmdGVyT3BlbjogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxuICBvbkFmdGVyQ2xvc2U6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcbiAgb25SZXF1ZXN0Q2xvc2U6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcbiAgY2xvc2VUaW1lb3V0TVM6IF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyLFxuICBzaG91bGRGb2N1c0FmdGVyUmVuZGVyOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXG4gIHNob3VsZENsb3NlT25PdmVybGF5Q2xpY2s6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcbiAgc2hvdWxkUmV0dXJuRm9jdXNBZnRlckNsb3NlOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXG4gIHByZXZlbnRTY3JvbGw6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcbiAgcm9sZTogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXG4gIGNvbnRlbnRMYWJlbDogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXG4gIGFyaWE6IF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0LFxuICBkYXRhOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdCxcbiAgY2hpbGRyZW46IF9wcm9wVHlwZXMyLmRlZmF1bHQubm9kZSxcbiAgc2hvdWxkQ2xvc2VPbkVzYzogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuICBvdmVybGF5UmVmOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG4gIGNvbnRlbnRSZWY6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcbiAgaWQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxuICBvdmVybGF5RWxlbWVudDogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxuICBjb250ZW50RWxlbWVudDogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxuICB0ZXN0SWQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gTW9kYWxQb3J0YWw7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-modal/lib/components/ModalPortal.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-modal/lib/helpers/ariaAppHider.js":
/*!**************************************************************!*\
  !*** ./node_modules/react-modal/lib/helpers/ariaAppHider.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.resetState = resetState;\nexports.log = log;\nexports.assertNodeList = assertNodeList;\nexports.setElement = setElement;\nexports.validateElement = validateElement;\nexports.hide = hide;\nexports.show = show;\nexports.documentNotReadyOrSSRTesting = documentNotReadyOrSSRTesting;\n\nvar _warning = __webpack_require__(/*! warning */ \"(app-pages-browser)/./node_modules/warning/warning.js\");\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nvar _safeHTMLElement = __webpack_require__(/*! ./safeHTMLElement */ \"(app-pages-browser)/./node_modules/react-modal/lib/helpers/safeHTMLElement.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar globalElement = null;\n\n/* eslint-disable no-console */\n/* istanbul ignore next */\nfunction resetState() {\n  if (globalElement) {\n    if (globalElement.removeAttribute) {\n      globalElement.removeAttribute(\"aria-hidden\");\n    } else if (globalElement.length != null) {\n      globalElement.forEach(function (element) {\n        return element.removeAttribute(\"aria-hidden\");\n      });\n    } else {\n      document.querySelectorAll(globalElement).forEach(function (element) {\n        return element.removeAttribute(\"aria-hidden\");\n      });\n    }\n  }\n  globalElement = null;\n}\n\n/* istanbul ignore next */\nfunction log() {\n  if (true) {\n    var check = globalElement || {};\n    console.log(\"ariaAppHider ----------\");\n    console.log(check.nodeName, check.className, check.id);\n    console.log(\"end ariaAppHider ----------\");\n  }\n}\n/* eslint-enable no-console */\n\nfunction assertNodeList(nodeList, selector) {\n  if (!nodeList || !nodeList.length) {\n    throw new Error(\"react-modal: No elements were found for selector \" + selector + \".\");\n  }\n}\n\nfunction setElement(element) {\n  var useElement = element;\n  if (typeof useElement === \"string\" && _safeHTMLElement.canUseDOM) {\n    var el = document.querySelectorAll(useElement);\n    assertNodeList(el, useElement);\n    useElement = el;\n  }\n  globalElement = useElement || globalElement;\n  return globalElement;\n}\n\nfunction validateElement(appElement) {\n  var el = appElement || globalElement;\n  if (el) {\n    return Array.isArray(el) || el instanceof HTMLCollection || el instanceof NodeList ? el : [el];\n  } else {\n    (0, _warning2.default)(false, [\"react-modal: App element is not defined.\", \"Please use `Modal.setAppElement(el)` or set `appElement={el}`.\", \"This is needed so screen readers don't see main content\", \"when modal is opened. It is not recommended, but you can opt-out\", \"by setting `ariaHideApp={false}`.\"].join(\" \"));\n\n    return [];\n  }\n}\n\nfunction hide(appElement) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = validateElement(appElement)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var el = _step.value;\n\n      el.setAttribute(\"aria-hidden\", \"true\");\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n\nfunction show(appElement) {\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = validateElement(appElement)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var el = _step2.value;\n\n      el.removeAttribute(\"aria-hidden\");\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n}\n\nfunction documentNotReadyOrSSRTesting() {\n  globalElement = null;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9saWIvaGVscGVycy9hcmlhQXBwSGlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCO0FBQ2xCLFdBQVc7QUFDWCxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCLHVCQUF1QjtBQUN2QixZQUFZO0FBQ1osWUFBWTtBQUNaLG9DQUFvQzs7QUFFcEMsZUFBZSxtQkFBTyxDQUFDLHNFQUFTOztBQUVoQzs7QUFFQSx1QkFBdUIsbUJBQU8sQ0FBQyx3R0FBbUI7O0FBRWxELHVDQUF1Qyx1Q0FBdUM7O0FBRTlFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0oseUlBQXlJLEdBQUcsOEpBQThKLE1BQU07O0FBRWhUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdGQUFnRixnRUFBZ0U7QUFDaEo7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtGQUFrRixtRUFBbUU7QUFDcko7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL2xpYi9oZWxwZXJzL2FyaWFBcHBIaWRlci5qcz83MTAxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZXNldFN0YXRlID0gcmVzZXRTdGF0ZTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5hc3NlcnROb2RlTGlzdCA9IGFzc2VydE5vZGVMaXN0O1xuZXhwb3J0cy5zZXRFbGVtZW50ID0gc2V0RWxlbWVudDtcbmV4cG9ydHMudmFsaWRhdGVFbGVtZW50ID0gdmFsaWRhdGVFbGVtZW50O1xuZXhwb3J0cy5oaWRlID0gaGlkZTtcbmV4cG9ydHMuc2hvdyA9IHNob3c7XG5leHBvcnRzLmRvY3VtZW50Tm90UmVhZHlPclNTUlRlc3RpbmcgPSBkb2N1bWVudE5vdFJlYWR5T3JTU1JUZXN0aW5nO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKFwid2FybmluZ1wiKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX3NhZmVIVE1MRWxlbWVudCA9IHJlcXVpcmUoXCIuL3NhZmVIVE1MRWxlbWVudFwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGdsb2JhbEVsZW1lbnQgPSBudWxsO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gcmVzZXRTdGF0ZSgpIHtcbiAgaWYgKGdsb2JhbEVsZW1lbnQpIHtcbiAgICBpZiAoZ2xvYmFsRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUpIHtcbiAgICAgIGdsb2JhbEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIik7XG4gICAgfSBlbHNlIGlmIChnbG9iYWxFbGVtZW50Lmxlbmd0aCAhPSBudWxsKSB7XG4gICAgICBnbG9iYWxFbGVtZW50LmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChnbG9iYWxFbGVtZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdsb2JhbEVsZW1lbnQgPSBudWxsO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gbG9nKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFyIGNoZWNrID0gZ2xvYmFsRWxlbWVudCB8fCB7fTtcbiAgICBjb25zb2xlLmxvZyhcImFyaWFBcHBIaWRlciAtLS0tLS0tLS0tXCIpO1xuICAgIGNvbnNvbGUubG9nKGNoZWNrLm5vZGVOYW1lLCBjaGVjay5jbGFzc05hbWUsIGNoZWNrLmlkKTtcbiAgICBjb25zb2xlLmxvZyhcImVuZCBhcmlhQXBwSGlkZXIgLS0tLS0tLS0tLVwiKTtcbiAgfVxufVxuLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cbmZ1bmN0aW9uIGFzc2VydE5vZGVMaXN0KG5vZGVMaXN0LCBzZWxlY3Rvcikge1xuICBpZiAoIW5vZGVMaXN0IHx8ICFub2RlTGlzdC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWFjdC1tb2RhbDogTm8gZWxlbWVudHMgd2VyZSBmb3VuZCBmb3Igc2VsZWN0b3IgXCIgKyBzZWxlY3RvciArIFwiLlwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRFbGVtZW50KGVsZW1lbnQpIHtcbiAgdmFyIHVzZUVsZW1lbnQgPSBlbGVtZW50O1xuICBpZiAodHlwZW9mIHVzZUVsZW1lbnQgPT09IFwic3RyaW5nXCIgJiYgX3NhZmVIVE1MRWxlbWVudC5jYW5Vc2VET00pIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHVzZUVsZW1lbnQpO1xuICAgIGFzc2VydE5vZGVMaXN0KGVsLCB1c2VFbGVtZW50KTtcbiAgICB1c2VFbGVtZW50ID0gZWw7XG4gIH1cbiAgZ2xvYmFsRWxlbWVudCA9IHVzZUVsZW1lbnQgfHwgZ2xvYmFsRWxlbWVudDtcbiAgcmV0dXJuIGdsb2JhbEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRWxlbWVudChhcHBFbGVtZW50KSB7XG4gIHZhciBlbCA9IGFwcEVsZW1lbnQgfHwgZ2xvYmFsRWxlbWVudDtcbiAgaWYgKGVsKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZWwpIHx8IGVsIGluc3RhbmNlb2YgSFRNTENvbGxlY3Rpb24gfHwgZWwgaW5zdGFuY2VvZiBOb2RlTGlzdCA/IGVsIDogW2VsXTtcbiAgfSBlbHNlIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCBbXCJyZWFjdC1tb2RhbDogQXBwIGVsZW1lbnQgaXMgbm90IGRlZmluZWQuXCIsIFwiUGxlYXNlIHVzZSBgTW9kYWwuc2V0QXBwRWxlbWVudChlbClgIG9yIHNldCBgYXBwRWxlbWVudD17ZWx9YC5cIiwgXCJUaGlzIGlzIG5lZWRlZCBzbyBzY3JlZW4gcmVhZGVycyBkb24ndCBzZWUgbWFpbiBjb250ZW50XCIsIFwid2hlbiBtb2RhbCBpcyBvcGVuZWQuIEl0IGlzIG5vdCByZWNvbW1lbmRlZCwgYnV0IHlvdSBjYW4gb3B0LW91dFwiLCBcImJ5IHNldHRpbmcgYGFyaWFIaWRlQXBwPXtmYWxzZX1gLlwiXS5qb2luKFwiIFwiKSk7XG5cbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuZnVuY3Rpb24gaGlkZShhcHBFbGVtZW50KSB7XG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHZhbGlkYXRlRWxlbWVudChhcHBFbGVtZW50KVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgIHZhciBlbCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzaG93KGFwcEVsZW1lbnQpIHtcbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IHZhbGlkYXRlRWxlbWVudChhcHBFbGVtZW50KVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgdmFyIGVsID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkb2N1bWVudE5vdFJlYWR5T3JTU1JUZXN0aW5nKCkge1xuICBnbG9iYWxFbGVtZW50ID0gbnVsbDtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-modal/lib/helpers/ariaAppHider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-modal/lib/helpers/bodyTrap.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-modal/lib/helpers/bodyTrap.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.resetState = resetState;\nexports.log = log;\n\nvar _portalOpenInstances = __webpack_require__(/*! ./portalOpenInstances */ \"(app-pages-browser)/./node_modules/react-modal/lib/helpers/portalOpenInstances.js\");\n\nvar _portalOpenInstances2 = _interopRequireDefault(_portalOpenInstances);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Body focus trap see Issue #742\n\nvar before = void 0,\n    after = void 0,\n    instances = [];\n\n/* eslint-disable no-console */\n/* istanbul ignore next */\nfunction resetState() {\n  var _arr = [before, after];\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var item = _arr[_i];\n    if (!item) continue;\n    item.parentNode && item.parentNode.removeChild(item);\n  }\n  before = after = null;\n  instances = [];\n}\n\n/* istanbul ignore next */\nfunction log() {\n  console.log(\"bodyTrap ----------\");\n  console.log(instances.length);\n  var _arr2 = [before, after];\n  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n    var item = _arr2[_i2];\n    var check = item || {};\n    console.log(check.nodeName, check.className, check.id);\n  }\n  console.log(\"edn bodyTrap ----------\");\n}\n/* eslint-enable no-console */\n\nfunction focusContent() {\n  if (instances.length === 0) {\n    if (true) {\n      // eslint-disable-next-line no-console\n      console.warn(\"React-Modal: Open instances > 0 expected\");\n    }\n    return;\n  }\n  instances[instances.length - 1].focusContent();\n}\n\nfunction bodyTrap(eventType, openInstances) {\n  if (!before && !after) {\n    before = document.createElement(\"div\");\n    before.setAttribute(\"data-react-modal-body-trap\", \"\");\n    before.style.position = \"absolute\";\n    before.style.opacity = \"0\";\n    before.setAttribute(\"tabindex\", \"0\");\n    before.addEventListener(\"focus\", focusContent);\n    after = before.cloneNode();\n    after.addEventListener(\"focus\", focusContent);\n  }\n\n  instances = openInstances;\n\n  if (instances.length > 0) {\n    // Add focus trap\n    if (document.body.firstChild !== before) {\n      document.body.insertBefore(before, document.body.firstChild);\n    }\n    if (document.body.lastChild !== after) {\n      document.body.appendChild(after);\n    }\n  } else {\n    // Remove focus trap\n    if (before.parentElement) {\n      before.parentElement.removeChild(before);\n    }\n    if (after.parentElement) {\n      after.parentElement.removeChild(after);\n    }\n  }\n}\n\n_portalOpenInstances2.default.subscribe(bodyTrap);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9saWIvaGVscGVycy9ib2R5VHJhcC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7QUFDbEIsV0FBVzs7QUFFWCwyQkFBMkIsbUJBQU8sQ0FBQyxnSEFBdUI7O0FBRTFEOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL2xpYi9oZWxwZXJzL2JvZHlUcmFwLmpzPzYyNjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJlc2V0U3RhdGUgPSByZXNldFN0YXRlO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5cbnZhciBfcG9ydGFsT3Blbkluc3RhbmNlcyA9IHJlcXVpcmUoXCIuL3BvcnRhbE9wZW5JbnN0YW5jZXNcIik7XG5cbnZhciBfcG9ydGFsT3Blbkluc3RhbmNlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3J0YWxPcGVuSW5zdGFuY2VzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gQm9keSBmb2N1cyB0cmFwIHNlZSBJc3N1ZSAjNzQyXG5cbnZhciBiZWZvcmUgPSB2b2lkIDAsXG4gICAgYWZ0ZXIgPSB2b2lkIDAsXG4gICAgaW5zdGFuY2VzID0gW107XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiByZXNldFN0YXRlKCkge1xuICB2YXIgX2FyciA9IFtiZWZvcmUsIGFmdGVyXTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgX2Fyci5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgaXRlbSA9IF9hcnJbX2ldO1xuICAgIGlmICghaXRlbSkgY29udGludWU7XG4gICAgaXRlbS5wYXJlbnROb2RlICYmIGl0ZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpdGVtKTtcbiAgfVxuICBiZWZvcmUgPSBhZnRlciA9IG51bGw7XG4gIGluc3RhbmNlcyA9IFtdO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gbG9nKCkge1xuICBjb25zb2xlLmxvZyhcImJvZHlUcmFwIC0tLS0tLS0tLS1cIik7XG4gIGNvbnNvbGUubG9nKGluc3RhbmNlcy5sZW5ndGgpO1xuICB2YXIgX2FycjIgPSBbYmVmb3JlLCBhZnRlcl07XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IF9hcnIyLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgaXRlbSA9IF9hcnIyW19pMl07XG4gICAgdmFyIGNoZWNrID0gaXRlbSB8fCB7fTtcbiAgICBjb25zb2xlLmxvZyhjaGVjay5ub2RlTmFtZSwgY2hlY2suY2xhc3NOYW1lLCBjaGVjay5pZCk7XG4gIH1cbiAgY29uc29sZS5sb2coXCJlZG4gYm9keVRyYXAgLS0tLS0tLS0tLVwiKTtcbn1cbi8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuXG5mdW5jdGlvbiBmb2N1c0NvbnRlbnQoKSB7XG4gIGlmIChpbnN0YW5jZXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcIlJlYWN0LU1vZGFsOiBPcGVuIGluc3RhbmNlcyA+IDAgZXhwZWN0ZWRcIik7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpbnN0YW5jZXNbaW5zdGFuY2VzLmxlbmd0aCAtIDFdLmZvY3VzQ29udGVudCgpO1xufVxuXG5mdW5jdGlvbiBib2R5VHJhcChldmVudFR5cGUsIG9wZW5JbnN0YW5jZXMpIHtcbiAgaWYgKCFiZWZvcmUgJiYgIWFmdGVyKSB7XG4gICAgYmVmb3JlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBiZWZvcmUuc2V0QXR0cmlidXRlKFwiZGF0YS1yZWFjdC1tb2RhbC1ib2R5LXRyYXBcIiwgXCJcIik7XG4gICAgYmVmb3JlLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIGJlZm9yZS5zdHlsZS5vcGFjaXR5ID0gXCIwXCI7XG4gICAgYmVmb3JlLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKTtcbiAgICBiZWZvcmUuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGZvY3VzQ29udGVudCk7XG4gICAgYWZ0ZXIgPSBiZWZvcmUuY2xvbmVOb2RlKCk7XG4gICAgYWZ0ZXIuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGZvY3VzQ29udGVudCk7XG4gIH1cblxuICBpbnN0YW5jZXMgPSBvcGVuSW5zdGFuY2VzO1xuXG4gIGlmIChpbnN0YW5jZXMubGVuZ3RoID4gMCkge1xuICAgIC8vIEFkZCBmb2N1cyB0cmFwXG4gICAgaWYgKGRvY3VtZW50LmJvZHkuZmlyc3RDaGlsZCAhPT0gYmVmb3JlKSB7XG4gICAgICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZShiZWZvcmUsIGRvY3VtZW50LmJvZHkuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIGlmIChkb2N1bWVudC5ib2R5Lmxhc3RDaGlsZCAhPT0gYWZ0ZXIpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYWZ0ZXIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBSZW1vdmUgZm9jdXMgdHJhcFxuICAgIGlmIChiZWZvcmUucGFyZW50RWxlbWVudCkge1xuICAgICAgYmVmb3JlLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoYmVmb3JlKTtcbiAgICB9XG4gICAgaWYgKGFmdGVyLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIGFmdGVyLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoYWZ0ZXIpO1xuICAgIH1cbiAgfVxufVxuXG5fcG9ydGFsT3Blbkluc3RhbmNlczIuZGVmYXVsdC5zdWJzY3JpYmUoYm9keVRyYXApOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-modal/lib/helpers/bodyTrap.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-modal/lib/helpers/classList.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-modal/lib/helpers/classList.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.resetState = resetState;\nexports.log = log;\nvar htmlClassList = {};\nvar docBodyClassList = {};\n\n/* eslint-disable no-console */\n/* istanbul ignore next */\nfunction removeClass(at, cls) {\n  at.classList.remove(cls);\n}\n\n/* istanbul ignore next */\nfunction resetState() {\n  var htmlElement = document.getElementsByTagName(\"html\")[0];\n  for (var cls in htmlClassList) {\n    removeClass(htmlElement, htmlClassList[cls]);\n  }\n\n  var body = document.body;\n  for (var _cls in docBodyClassList) {\n    removeClass(body, docBodyClassList[_cls]);\n  }\n\n  htmlClassList = {};\n  docBodyClassList = {};\n}\n\n/* istanbul ignore next */\nfunction log() {\n  if (true) {\n    var classes = document.getElementsByTagName(\"html\")[0].className;\n    var buffer = \"Show tracked classes:\\n\\n\";\n\n    buffer += \"<html /> (\" + classes + \"):\\n  \";\n    for (var x in htmlClassList) {\n      buffer += \"  \" + x + \" \" + htmlClassList[x] + \"\\n  \";\n    }\n\n    classes = document.body.className;\n\n    buffer += \"\\n\\ndoc.body (\" + classes + \"):\\n  \";\n    for (var _x in docBodyClassList) {\n      buffer += \"  \" + _x + \" \" + docBodyClassList[_x] + \"\\n  \";\n    }\n\n    buffer += \"\\n\";\n\n    console.log(buffer);\n  }\n}\n/* eslint-enable no-console */\n\n/**\n * Track the number of reference of a class.\n * @param {object} poll The poll to receive the reference.\n * @param {string} className The class name.\n * @return {string}\n */\nvar incrementReference = function incrementReference(poll, className) {\n  if (!poll[className]) {\n    poll[className] = 0;\n  }\n  poll[className] += 1;\n  return className;\n};\n\n/**\n * Drop the reference of a class.\n * @param {object} poll The poll to receive the reference.\n * @param {string} className The class name.\n * @return {string}\n */\nvar decrementReference = function decrementReference(poll, className) {\n  if (poll[className]) {\n    poll[className] -= 1;\n  }\n  return className;\n};\n\n/**\n * Track a class and add to the given class list.\n * @param {Object} classListRef A class list of an element.\n * @param {Object} poll         The poll to be used.\n * @param {Array}  classes      The list of classes to be tracked.\n */\nvar trackClass = function trackClass(classListRef, poll, classes) {\n  classes.forEach(function (className) {\n    incrementReference(poll, className);\n    classListRef.add(className);\n  });\n};\n\n/**\n * Untrack a class and remove from the given class list if the reference\n * reaches 0.\n * @param {Object} classListRef A class list of an element.\n * @param {Object} poll         The poll to be used.\n * @param {Array}  classes      The list of classes to be untracked.\n */\nvar untrackClass = function untrackClass(classListRef, poll, classes) {\n  classes.forEach(function (className) {\n    decrementReference(poll, className);\n    poll[className] === 0 && classListRef.remove(className);\n  });\n};\n\n/**\n * Public inferface to add classes to the document.body.\n * @param {string} bodyClass The class string to be added.\n *                           It may contain more then one class\n *                           with ' ' as separator.\n */\nvar add = exports.add = function add(element, classString) {\n  return trackClass(element.classList, element.nodeName.toLowerCase() == \"html\" ? htmlClassList : docBodyClassList, classString.split(\" \"));\n};\n\n/**\n * Public inferface to remove classes from the document.body.\n * @param {string} bodyClass The class string to be added.\n *                           It may contain more then one class\n *                           with ' ' as separator.\n */\nvar remove = exports.remove = function remove(element, classString) {\n  return untrackClass(element.classList, element.nodeName.toLowerCase() == \"html\" ? htmlClassList : docBodyClassList, classString.split(\" \"));\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9saWIvaGVscGVycy9jbGFzc0xpc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCO0FBQ2xCLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbGliL2hlbHBlcnMvY2xhc3NMaXN0LmpzPzdkYTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJlc2V0U3RhdGUgPSByZXNldFN0YXRlO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG52YXIgaHRtbENsYXNzTGlzdCA9IHt9O1xudmFyIGRvY0JvZHlDbGFzc0xpc3QgPSB7fTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGF0LCBjbHMpIHtcbiAgYXQuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gcmVzZXRTdGF0ZSgpIHtcbiAgdmFyIGh0bWxFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJodG1sXCIpWzBdO1xuICBmb3IgKHZhciBjbHMgaW4gaHRtbENsYXNzTGlzdCkge1xuICAgIHJlbW92ZUNsYXNzKGh0bWxFbGVtZW50LCBodG1sQ2xhc3NMaXN0W2Nsc10pO1xuICB9XG5cbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICBmb3IgKHZhciBfY2xzIGluIGRvY0JvZHlDbGFzc0xpc3QpIHtcbiAgICByZW1vdmVDbGFzcyhib2R5LCBkb2NCb2R5Q2xhc3NMaXN0W19jbHNdKTtcbiAgfVxuXG4gIGh0bWxDbGFzc0xpc3QgPSB7fTtcbiAgZG9jQm9keUNsYXNzTGlzdCA9IHt9O1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gbG9nKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFyIGNsYXNzZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImh0bWxcIilbMF0uY2xhc3NOYW1lO1xuICAgIHZhciBidWZmZXIgPSBcIlNob3cgdHJhY2tlZCBjbGFzc2VzOlxcblxcblwiO1xuXG4gICAgYnVmZmVyICs9IFwiPGh0bWwgLz4gKFwiICsgY2xhc3NlcyArIFwiKTpcXG4gIFwiO1xuICAgIGZvciAodmFyIHggaW4gaHRtbENsYXNzTGlzdCkge1xuICAgICAgYnVmZmVyICs9IFwiICBcIiArIHggKyBcIiBcIiArIGh0bWxDbGFzc0xpc3RbeF0gKyBcIlxcbiAgXCI7XG4gICAgfVxuXG4gICAgY2xhc3NlcyA9IGRvY3VtZW50LmJvZHkuY2xhc3NOYW1lO1xuXG4gICAgYnVmZmVyICs9IFwiXFxuXFxuZG9jLmJvZHkgKFwiICsgY2xhc3NlcyArIFwiKTpcXG4gIFwiO1xuICAgIGZvciAodmFyIF94IGluIGRvY0JvZHlDbGFzc0xpc3QpIHtcbiAgICAgIGJ1ZmZlciArPSBcIiAgXCIgKyBfeCArIFwiIFwiICsgZG9jQm9keUNsYXNzTGlzdFtfeF0gKyBcIlxcbiAgXCI7XG4gICAgfVxuXG4gICAgYnVmZmVyICs9IFwiXFxuXCI7XG5cbiAgICBjb25zb2xlLmxvZyhidWZmZXIpO1xuICB9XG59XG4vKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cblxuLyoqXG4gKiBUcmFjayB0aGUgbnVtYmVyIG9mIHJlZmVyZW5jZSBvZiBhIGNsYXNzLlxuICogQHBhcmFtIHtvYmplY3R9IHBvbGwgVGhlIHBvbGwgdG8gcmVjZWl2ZSB0aGUgcmVmZXJlbmNlLlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBUaGUgY2xhc3MgbmFtZS5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xudmFyIGluY3JlbWVudFJlZmVyZW5jZSA9IGZ1bmN0aW9uIGluY3JlbWVudFJlZmVyZW5jZShwb2xsLCBjbGFzc05hbWUpIHtcbiAgaWYgKCFwb2xsW2NsYXNzTmFtZV0pIHtcbiAgICBwb2xsW2NsYXNzTmFtZV0gPSAwO1xuICB9XG4gIHBvbGxbY2xhc3NOYW1lXSArPSAxO1xuICByZXR1cm4gY2xhc3NOYW1lO1xufTtcblxuLyoqXG4gKiBEcm9wIHRoZSByZWZlcmVuY2Ugb2YgYSBjbGFzcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwb2xsIFRoZSBwb2xsIHRvIHJlY2VpdmUgdGhlIHJlZmVyZW5jZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgVGhlIGNsYXNzIG5hbWUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbnZhciBkZWNyZW1lbnRSZWZlcmVuY2UgPSBmdW5jdGlvbiBkZWNyZW1lbnRSZWZlcmVuY2UocG9sbCwgY2xhc3NOYW1lKSB7XG4gIGlmIChwb2xsW2NsYXNzTmFtZV0pIHtcbiAgICBwb2xsW2NsYXNzTmFtZV0gLT0gMTtcbiAgfVxuICByZXR1cm4gY2xhc3NOYW1lO1xufTtcblxuLyoqXG4gKiBUcmFjayBhIGNsYXNzIGFuZCBhZGQgdG8gdGhlIGdpdmVuIGNsYXNzIGxpc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gY2xhc3NMaXN0UmVmIEEgY2xhc3MgbGlzdCBvZiBhbiBlbGVtZW50LlxuICogQHBhcmFtIHtPYmplY3R9IHBvbGwgICAgICAgICBUaGUgcG9sbCB0byBiZSB1c2VkLlxuICogQHBhcmFtIHtBcnJheX0gIGNsYXNzZXMgICAgICBUaGUgbGlzdCBvZiBjbGFzc2VzIHRvIGJlIHRyYWNrZWQuXG4gKi9cbnZhciB0cmFja0NsYXNzID0gZnVuY3Rpb24gdHJhY2tDbGFzcyhjbGFzc0xpc3RSZWYsIHBvbGwsIGNsYXNzZXMpIHtcbiAgY2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICBpbmNyZW1lbnRSZWZlcmVuY2UocG9sbCwgY2xhc3NOYW1lKTtcbiAgICBjbGFzc0xpc3RSZWYuYWRkKGNsYXNzTmFtZSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBVbnRyYWNrIGEgY2xhc3MgYW5kIHJlbW92ZSBmcm9tIHRoZSBnaXZlbiBjbGFzcyBsaXN0IGlmIHRoZSByZWZlcmVuY2VcbiAqIHJlYWNoZXMgMC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjbGFzc0xpc3RSZWYgQSBjbGFzcyBsaXN0IG9mIGFuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gcG9sbCAgICAgICAgIFRoZSBwb2xsIHRvIGJlIHVzZWQuXG4gKiBAcGFyYW0ge0FycmF5fSAgY2xhc3NlcyAgICAgIFRoZSBsaXN0IG9mIGNsYXNzZXMgdG8gYmUgdW50cmFja2VkLlxuICovXG52YXIgdW50cmFja0NsYXNzID0gZnVuY3Rpb24gdW50cmFja0NsYXNzKGNsYXNzTGlzdFJlZiwgcG9sbCwgY2xhc3Nlcykge1xuICBjbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgIGRlY3JlbWVudFJlZmVyZW5jZShwb2xsLCBjbGFzc05hbWUpO1xuICAgIHBvbGxbY2xhc3NOYW1lXSA9PT0gMCAmJiBjbGFzc0xpc3RSZWYucmVtb3ZlKGNsYXNzTmFtZSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBQdWJsaWMgaW5mZXJmYWNlIHRvIGFkZCBjbGFzc2VzIHRvIHRoZSBkb2N1bWVudC5ib2R5LlxuICogQHBhcmFtIHtzdHJpbmd9IGJvZHlDbGFzcyBUaGUgY2xhc3Mgc3RyaW5nIHRvIGJlIGFkZGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBJdCBtYXkgY29udGFpbiBtb3JlIHRoZW4gb25lIGNsYXNzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggJyAnIGFzIHNlcGFyYXRvci5cbiAqL1xudmFyIGFkZCA9IGV4cG9ydHMuYWRkID0gZnVuY3Rpb24gYWRkKGVsZW1lbnQsIGNsYXNzU3RyaW5nKSB7XG4gIHJldHVybiB0cmFja0NsYXNzKGVsZW1lbnQuY2xhc3NMaXN0LCBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gXCJodG1sXCIgPyBodG1sQ2xhc3NMaXN0IDogZG9jQm9keUNsYXNzTGlzdCwgY2xhc3NTdHJpbmcuc3BsaXQoXCIgXCIpKTtcbn07XG5cbi8qKlxuICogUHVibGljIGluZmVyZmFjZSB0byByZW1vdmUgY2xhc3NlcyBmcm9tIHRoZSBkb2N1bWVudC5ib2R5LlxuICogQHBhcmFtIHtzdHJpbmd9IGJvZHlDbGFzcyBUaGUgY2xhc3Mgc3RyaW5nIHRvIGJlIGFkZGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBJdCBtYXkgY29udGFpbiBtb3JlIHRoZW4gb25lIGNsYXNzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggJyAnIGFzIHNlcGFyYXRvci5cbiAqL1xudmFyIHJlbW92ZSA9IGV4cG9ydHMucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGVsZW1lbnQsIGNsYXNzU3RyaW5nKSB7XG4gIHJldHVybiB1bnRyYWNrQ2xhc3MoZWxlbWVudC5jbGFzc0xpc3QsIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSBcImh0bWxcIiA/IGh0bWxDbGFzc0xpc3QgOiBkb2NCb2R5Q2xhc3NMaXN0LCBjbGFzc1N0cmluZy5zcGxpdChcIiBcIikpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-modal/lib/helpers/classList.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-modal/lib/helpers/focusManager.js":
/*!**************************************************************!*\
  !*** ./node_modules/react-modal/lib/helpers/focusManager.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.resetState = resetState;\nexports.log = log;\nexports.handleBlur = handleBlur;\nexports.handleFocus = handleFocus;\nexports.markForFocusLater = markForFocusLater;\nexports.returnFocus = returnFocus;\nexports.popWithoutFocus = popWithoutFocus;\nexports.setupScopedFocus = setupScopedFocus;\nexports.teardownScopedFocus = teardownScopedFocus;\n\nvar _tabbable = __webpack_require__(/*! ../helpers/tabbable */ \"(app-pages-browser)/./node_modules/react-modal/lib/helpers/tabbable.js\");\n\nvar _tabbable2 = _interopRequireDefault(_tabbable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar focusLaterElements = [];\nvar modalElement = null;\nvar needToFocus = false;\n\n/* eslint-disable no-console */\n/* istanbul ignore next */\nfunction resetState() {\n  focusLaterElements = [];\n}\n\n/* istanbul ignore next */\nfunction log() {\n  if (true) {\n    console.log(\"focusManager ----------\");\n    focusLaterElements.forEach(function (f) {\n      var check = f || {};\n      console.log(check.nodeName, check.className, check.id);\n    });\n    console.log(\"end focusManager ----------\");\n  }\n}\n/* eslint-enable no-console */\n\nfunction handleBlur() {\n  needToFocus = true;\n}\n\nfunction handleFocus() {\n  if (needToFocus) {\n    needToFocus = false;\n    if (!modalElement) {\n      return;\n    }\n    // need to see how jQuery shims document.on('focusin') so we don't need the\n    // setTimeout, firefox doesn't support focusin, if it did, we could focus\n    // the element outside of a setTimeout. Side-effect of this implementation\n    // is that the document.body gets focus, and then we focus our element right\n    // after, seems fine.\n    setTimeout(function () {\n      if (modalElement.contains(document.activeElement)) {\n        return;\n      }\n      var el = (0, _tabbable2.default)(modalElement)[0] || modalElement;\n      el.focus();\n    }, 0);\n  }\n}\n\nfunction markForFocusLater() {\n  focusLaterElements.push(document.activeElement);\n}\n\n/* eslint-disable no-console */\nfunction returnFocus() {\n  var preventScroll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n  var toFocus = null;\n  try {\n    if (focusLaterElements.length !== 0) {\n      toFocus = focusLaterElements.pop();\n      toFocus.focus({ preventScroll: preventScroll });\n    }\n    return;\n  } catch (e) {\n    console.warn([\"You tried to return focus to\", toFocus, \"but it is not in the DOM anymore\"].join(\" \"));\n  }\n}\n/* eslint-enable no-console */\n\nfunction popWithoutFocus() {\n  focusLaterElements.length > 0 && focusLaterElements.pop();\n}\n\nfunction setupScopedFocus(element) {\n  modalElement = element;\n\n  if (window.addEventListener) {\n    window.addEventListener(\"blur\", handleBlur, false);\n    document.addEventListener(\"focus\", handleFocus, true);\n  } else {\n    window.attachEvent(\"onBlur\", handleBlur);\n    document.attachEvent(\"onFocus\", handleFocus);\n  }\n}\n\nfunction teardownScopedFocus() {\n  modalElement = null;\n\n  if (window.addEventListener) {\n    window.removeEventListener(\"blur\", handleBlur);\n    document.removeEventListener(\"focus\", handleFocus);\n  } else {\n    window.detachEvent(\"onBlur\", handleBlur);\n    document.detachEvent(\"onFocus\", handleFocus);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9saWIvaGVscGVycy9mb2N1c01hbmFnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCO0FBQ2xCLFdBQVc7QUFDWCxrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLHlCQUF5QjtBQUN6QixtQkFBbUI7QUFDbkIsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4QiwyQkFBMkI7O0FBRTNCLGdCQUFnQixtQkFBTyxDQUFDLG1HQUFxQjs7QUFFN0M7O0FBRUEsdUNBQXVDLHVDQUF1Qzs7QUFFOUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbGliL2hlbHBlcnMvZm9jdXNNYW5hZ2VyLmpzPzMzOTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJlc2V0U3RhdGUgPSByZXNldFN0YXRlO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmhhbmRsZUJsdXIgPSBoYW5kbGVCbHVyO1xuZXhwb3J0cy5oYW5kbGVGb2N1cyA9IGhhbmRsZUZvY3VzO1xuZXhwb3J0cy5tYXJrRm9yRm9jdXNMYXRlciA9IG1hcmtGb3JGb2N1c0xhdGVyO1xuZXhwb3J0cy5yZXR1cm5Gb2N1cyA9IHJldHVybkZvY3VzO1xuZXhwb3J0cy5wb3BXaXRob3V0Rm9jdXMgPSBwb3BXaXRob3V0Rm9jdXM7XG5leHBvcnRzLnNldHVwU2NvcGVkRm9jdXMgPSBzZXR1cFNjb3BlZEZvY3VzO1xuZXhwb3J0cy50ZWFyZG93blNjb3BlZEZvY3VzID0gdGVhcmRvd25TY29wZWRGb2N1cztcblxudmFyIF90YWJiYWJsZSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3RhYmJhYmxlXCIpO1xuXG52YXIgX3RhYmJhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhYmJhYmxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGZvY3VzTGF0ZXJFbGVtZW50cyA9IFtdO1xudmFyIG1vZGFsRWxlbWVudCA9IG51bGw7XG52YXIgbmVlZFRvRm9jdXMgPSBmYWxzZTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIHJlc2V0U3RhdGUoKSB7XG4gIGZvY3VzTGF0ZXJFbGVtZW50cyA9IFtdO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gbG9nKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc29sZS5sb2coXCJmb2N1c01hbmFnZXIgLS0tLS0tLS0tLVwiKTtcbiAgICBmb2N1c0xhdGVyRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgdmFyIGNoZWNrID0gZiB8fCB7fTtcbiAgICAgIGNvbnNvbGUubG9nKGNoZWNrLm5vZGVOYW1lLCBjaGVjay5jbGFzc05hbWUsIGNoZWNrLmlkKTtcbiAgICB9KTtcbiAgICBjb25zb2xlLmxvZyhcImVuZCBmb2N1c01hbmFnZXIgLS0tLS0tLS0tLVwiKTtcbiAgfVxufVxuLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cbmZ1bmN0aW9uIGhhbmRsZUJsdXIoKSB7XG4gIG5lZWRUb0ZvY3VzID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlRm9jdXMoKSB7XG4gIGlmIChuZWVkVG9Gb2N1cykge1xuICAgIG5lZWRUb0ZvY3VzID0gZmFsc2U7XG4gICAgaWYgKCFtb2RhbEVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gbmVlZCB0byBzZWUgaG93IGpRdWVyeSBzaGltcyBkb2N1bWVudC5vbignZm9jdXNpbicpIHNvIHdlIGRvbid0IG5lZWQgdGhlXG4gICAgLy8gc2V0VGltZW91dCwgZmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgZm9jdXNpbiwgaWYgaXQgZGlkLCB3ZSBjb3VsZCBmb2N1c1xuICAgIC8vIHRoZSBlbGVtZW50IG91dHNpZGUgb2YgYSBzZXRUaW1lb3V0LiBTaWRlLWVmZmVjdCBvZiB0aGlzIGltcGxlbWVudGF0aW9uXG4gICAgLy8gaXMgdGhhdCB0aGUgZG9jdW1lbnQuYm9keSBnZXRzIGZvY3VzLCBhbmQgdGhlbiB3ZSBmb2N1cyBvdXIgZWxlbWVudCByaWdodFxuICAgIC8vIGFmdGVyLCBzZWVtcyBmaW5lLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG1vZGFsRWxlbWVudC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZWwgPSAoMCwgX3RhYmJhYmxlMi5kZWZhdWx0KShtb2RhbEVsZW1lbnQpWzBdIHx8IG1vZGFsRWxlbWVudDtcbiAgICAgIGVsLmZvY3VzKCk7XG4gICAgfSwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya0ZvckZvY3VzTGF0ZXIoKSB7XG4gIGZvY3VzTGF0ZXJFbGVtZW50cy5wdXNoKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG5mdW5jdGlvbiByZXR1cm5Gb2N1cygpIHtcbiAgdmFyIHByZXZlbnRTY3JvbGwgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gIHZhciB0b0ZvY3VzID0gbnVsbDtcbiAgdHJ5IHtcbiAgICBpZiAoZm9jdXNMYXRlckVsZW1lbnRzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdG9Gb2N1cyA9IGZvY3VzTGF0ZXJFbGVtZW50cy5wb3AoKTtcbiAgICAgIHRvRm9jdXMuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiBwcmV2ZW50U2Nyb2xsIH0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLndhcm4oW1wiWW91IHRyaWVkIHRvIHJldHVybiBmb2N1cyB0b1wiLCB0b0ZvY3VzLCBcImJ1dCBpdCBpcyBub3QgaW4gdGhlIERPTSBhbnltb3JlXCJdLmpvaW4oXCIgXCIpKTtcbiAgfVxufVxuLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cbmZ1bmN0aW9uIHBvcFdpdGhvdXRGb2N1cygpIHtcbiAgZm9jdXNMYXRlckVsZW1lbnRzLmxlbmd0aCA+IDAgJiYgZm9jdXNMYXRlckVsZW1lbnRzLnBvcCgpO1xufVxuXG5mdW5jdGlvbiBzZXR1cFNjb3BlZEZvY3VzKGVsZW1lbnQpIHtcbiAgbW9kYWxFbGVtZW50ID0gZWxlbWVudDtcblxuICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgaGFuZGxlQmx1ciwgZmFsc2UpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBoYW5kbGVGb2N1cywgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LmF0dGFjaEV2ZW50KFwib25CbHVyXCIsIGhhbmRsZUJsdXIpO1xuICAgIGRvY3VtZW50LmF0dGFjaEV2ZW50KFwib25Gb2N1c1wiLCBoYW5kbGVGb2N1cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVhcmRvd25TY29wZWRGb2N1cygpIHtcbiAgbW9kYWxFbGVtZW50ID0gbnVsbDtcblxuICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgaGFuZGxlQmx1cik7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGhhbmRsZUZvY3VzKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuZGV0YWNoRXZlbnQoXCJvbkJsdXJcIiwgaGFuZGxlQmx1cik7XG4gICAgZG9jdW1lbnQuZGV0YWNoRXZlbnQoXCJvbkZvY3VzXCIsIGhhbmRsZUZvY3VzKTtcbiAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-modal/lib/helpers/focusManager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-modal/lib/helpers/portalOpenInstances.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react-modal/lib/helpers/portalOpenInstances.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.log = log;\nexports.resetState = resetState;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Tracks portals that are open and emits events to subscribers\n\nvar PortalOpenInstances = function PortalOpenInstances() {\n  var _this = this;\n\n  _classCallCheck(this, PortalOpenInstances);\n\n  this.register = function (openInstance) {\n    if (_this.openInstances.indexOf(openInstance) !== -1) {\n      if (true) {\n        // eslint-disable-next-line no-console\n        console.warn(\"React-Modal: Cannot register modal instance that's already open\");\n      }\n      return;\n    }\n    _this.openInstances.push(openInstance);\n    _this.emit(\"register\");\n  };\n\n  this.deregister = function (openInstance) {\n    var index = _this.openInstances.indexOf(openInstance);\n    if (index === -1) {\n      if (true) {\n        // eslint-disable-next-line no-console\n        console.warn(\"React-Modal: Unable to deregister \" + openInstance + \" as \" + \"it was never registered\");\n      }\n      return;\n    }\n    _this.openInstances.splice(index, 1);\n    _this.emit(\"deregister\");\n  };\n\n  this.subscribe = function (callback) {\n    _this.subscribers.push(callback);\n  };\n\n  this.emit = function (eventType) {\n    _this.subscribers.forEach(function (subscriber) {\n      return subscriber(eventType,\n      // shallow copy to avoid accidental mutation\n      _this.openInstances.slice());\n    });\n  };\n\n  this.openInstances = [];\n  this.subscribers = [];\n};\n\nvar portalOpenInstances = new PortalOpenInstances();\n\n/* eslint-disable no-console */\n/* istanbul ignore next */\nfunction log() {\n  console.log(\"portalOpenInstances ----------\");\n  console.log(portalOpenInstances.openInstances.length);\n  portalOpenInstances.openInstances.forEach(function (p) {\n    return console.log(p);\n  });\n  console.log(\"end portalOpenInstances ----------\");\n}\n\n/* istanbul ignore next */\nfunction resetState() {\n  portalOpenInstances = new PortalOpenInstances();\n}\n/* eslint-enable no-console */\n\nexports[\"default\"] = portalOpenInstances;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9saWIvaGVscGVycy9wb3J0YWxPcGVuSW5zdGFuY2VzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLFdBQVc7QUFDWCxrQkFBa0I7O0FBRWxCLGtEQUFrRCwwQ0FBMEM7O0FBRTVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQXFDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbGliL2hlbHBlcnMvcG9ydGFsT3Blbkluc3RhbmNlcy5qcz9hYTFlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLnJlc2V0U3RhdGUgPSByZXNldFN0YXRlO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vLyBUcmFja3MgcG9ydGFscyB0aGF0IGFyZSBvcGVuIGFuZCBlbWl0cyBldmVudHMgdG8gc3Vic2NyaWJlcnNcblxudmFyIFBvcnRhbE9wZW5JbnN0YW5jZXMgPSBmdW5jdGlvbiBQb3J0YWxPcGVuSW5zdGFuY2VzKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb3J0YWxPcGVuSW5zdGFuY2VzKTtcblxuICB0aGlzLnJlZ2lzdGVyID0gZnVuY3Rpb24gKG9wZW5JbnN0YW5jZSkge1xuICAgIGlmIChfdGhpcy5vcGVuSW5zdGFuY2VzLmluZGV4T2Yob3Blbkluc3RhbmNlKSAhPT0gLTEpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKFwiUmVhY3QtTW9kYWw6IENhbm5vdCByZWdpc3RlciBtb2RhbCBpbnN0YW5jZSB0aGF0J3MgYWxyZWFkeSBvcGVuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfdGhpcy5vcGVuSW5zdGFuY2VzLnB1c2gob3Blbkluc3RhbmNlKTtcbiAgICBfdGhpcy5lbWl0KFwicmVnaXN0ZXJcIik7XG4gIH07XG5cbiAgdGhpcy5kZXJlZ2lzdGVyID0gZnVuY3Rpb24gKG9wZW5JbnN0YW5jZSkge1xuICAgIHZhciBpbmRleCA9IF90aGlzLm9wZW5JbnN0YW5jZXMuaW5kZXhPZihvcGVuSW5zdGFuY2UpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKFwiUmVhY3QtTW9kYWw6IFVuYWJsZSB0byBkZXJlZ2lzdGVyIFwiICsgb3Blbkluc3RhbmNlICsgXCIgYXMgXCIgKyBcIml0IHdhcyBuZXZlciByZWdpc3RlcmVkXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfdGhpcy5vcGVuSW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgX3RoaXMuZW1pdChcImRlcmVnaXN0ZXJcIik7XG4gIH07XG5cbiAgdGhpcy5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBfdGhpcy5zdWJzY3JpYmVycy5wdXNoKGNhbGxiYWNrKTtcbiAgfTtcblxuICB0aGlzLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG4gICAgX3RoaXMuc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgcmV0dXJuIHN1YnNjcmliZXIoZXZlbnRUeXBlLFxuICAgICAgLy8gc2hhbGxvdyBjb3B5IHRvIGF2b2lkIGFjY2lkZW50YWwgbXV0YXRpb25cbiAgICAgIF90aGlzLm9wZW5JbnN0YW5jZXMuc2xpY2UoKSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdGhpcy5vcGVuSW5zdGFuY2VzID0gW107XG4gIHRoaXMuc3Vic2NyaWJlcnMgPSBbXTtcbn07XG5cbnZhciBwb3J0YWxPcGVuSW5zdGFuY2VzID0gbmV3IFBvcnRhbE9wZW5JbnN0YW5jZXMoKTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGxvZygpIHtcbiAgY29uc29sZS5sb2coXCJwb3J0YWxPcGVuSW5zdGFuY2VzIC0tLS0tLS0tLS1cIik7XG4gIGNvbnNvbGUubG9nKHBvcnRhbE9wZW5JbnN0YW5jZXMub3Blbkluc3RhbmNlcy5sZW5ndGgpO1xuICBwb3J0YWxPcGVuSW5zdGFuY2VzLm9wZW5JbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBjb25zb2xlLmxvZyhwKTtcbiAgfSk7XG4gIGNvbnNvbGUubG9nKFwiZW5kIHBvcnRhbE9wZW5JbnN0YW5jZXMgLS0tLS0tLS0tLVwiKTtcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIHJlc2V0U3RhdGUoKSB7XG4gIHBvcnRhbE9wZW5JbnN0YW5jZXMgPSBuZXcgUG9ydGFsT3Blbkluc3RhbmNlcygpO1xufVxuLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IHBvcnRhbE9wZW5JbnN0YW5jZXM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-modal/lib/helpers/portalOpenInstances.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-modal/lib/helpers/safeHTMLElement.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-modal/lib/helpers/safeHTMLElement.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.canUseDOM = exports.SafeNodeList = exports.SafeHTMLCollection = undefined;\n\nvar _exenv = __webpack_require__(/*! exenv */ \"(app-pages-browser)/./node_modules/exenv/index.js\");\n\nvar _exenv2 = _interopRequireDefault(_exenv);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar EE = _exenv2.default;\n\nvar SafeHTMLElement = EE.canUseDOM ? window.HTMLElement : {};\n\nvar SafeHTMLCollection = exports.SafeHTMLCollection = EE.canUseDOM ? window.HTMLCollection : {};\n\nvar SafeNodeList = exports.SafeNodeList = EE.canUseDOM ? window.NodeList : {};\n\nvar canUseDOM = exports.canUseDOM = EE.canUseDOM;\n\nexports[\"default\"] = SafeHTMLElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9saWIvaGVscGVycy9zYWZlSFRNTEVsZW1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaUJBQWlCLEdBQUcsb0JBQW9CLEdBQUcsMEJBQTBCOztBQUVyRSxhQUFhLG1CQUFPLENBQUMsZ0VBQU87O0FBRTVCOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFOztBQUVBOztBQUVBLHlCQUF5QiwwQkFBMEI7O0FBRW5ELG1CQUFtQixvQkFBb0I7O0FBRXZDLGdCQUFnQixpQkFBaUI7O0FBRWpDLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9saWIvaGVscGVycy9zYWZlSFRNTEVsZW1lbnQuanM/MWQyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY2FuVXNlRE9NID0gZXhwb3J0cy5TYWZlTm9kZUxpc3QgPSBleHBvcnRzLlNhZmVIVE1MQ29sbGVjdGlvbiA9IHVuZGVmaW5lZDtcblxudmFyIF9leGVudiA9IHJlcXVpcmUoXCJleGVudlwiKTtcblxudmFyIF9leGVudjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leGVudik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBFRSA9IF9leGVudjIuZGVmYXVsdDtcblxudmFyIFNhZmVIVE1MRWxlbWVudCA9IEVFLmNhblVzZURPTSA/IHdpbmRvdy5IVE1MRWxlbWVudCA6IHt9O1xuXG52YXIgU2FmZUhUTUxDb2xsZWN0aW9uID0gZXhwb3J0cy5TYWZlSFRNTENvbGxlY3Rpb24gPSBFRS5jYW5Vc2VET00gPyB3aW5kb3cuSFRNTENvbGxlY3Rpb24gOiB7fTtcblxudmFyIFNhZmVOb2RlTGlzdCA9IGV4cG9ydHMuU2FmZU5vZGVMaXN0ID0gRUUuY2FuVXNlRE9NID8gd2luZG93Lk5vZGVMaXN0IDoge307XG5cbnZhciBjYW5Vc2VET00gPSBleHBvcnRzLmNhblVzZURPTSA9IEVFLmNhblVzZURPTTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU2FmZUhUTUxFbGVtZW50OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-modal/lib/helpers/safeHTMLElement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-modal/lib/helpers/scopeTab.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-modal/lib/helpers/scopeTab.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = scopeTab;\n\nvar _tabbable = __webpack_require__(/*! ./tabbable */ \"(app-pages-browser)/./node_modules/react-modal/lib/helpers/tabbable.js\");\n\nvar _tabbable2 = _interopRequireDefault(_tabbable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getActiveElement() {\n  var el = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;\n\n  return el.activeElement.shadowRoot ? getActiveElement(el.activeElement.shadowRoot) : el.activeElement;\n}\n\nfunction scopeTab(node, event) {\n  var tabbable = (0, _tabbable2.default)(node);\n\n  if (!tabbable.length) {\n    // Do nothing, since there are no elements that can receive focus.\n    event.preventDefault();\n    return;\n  }\n\n  var target = void 0;\n\n  var shiftKey = event.shiftKey;\n  var head = tabbable[0];\n  var tail = tabbable[tabbable.length - 1];\n  var activeElement = getActiveElement();\n\n  // proceed with default browser behavior on tab.\n  // Focus on last element on shift + tab.\n  if (node === activeElement) {\n    if (!shiftKey) return;\n    target = tail;\n  }\n\n  if (tail === activeElement && !shiftKey) {\n    target = head;\n  }\n\n  if (head === activeElement && shiftKey) {\n    target = tail;\n  }\n\n  if (target) {\n    event.preventDefault();\n    target.focus();\n    return;\n  }\n\n  // Safari radio issue.\n  //\n  // Safari does not move the focus to the radio button,\n  // so we need to force it to really walk through all elements.\n  //\n  // This is very error prone, since we are trying to guess\n  // if it is a safari browser from the first occurence between\n  // chrome or safari.\n  //\n  // The chrome user agent contains the first ocurrence\n  // as the 'chrome/version' and later the 'safari/version'.\n  var checkSafari = /(\\bChrome\\b|\\bSafari\\b)\\//.exec(navigator.userAgent);\n  var isSafariDesktop = checkSafari != null && checkSafari[1] != \"Chrome\" && /\\biPod\\b|\\biPad\\b/g.exec(navigator.userAgent) == null;\n\n  // If we are not in safari desktop, let the browser control\n  // the focus\n  if (!isSafariDesktop) return;\n\n  var x = tabbable.indexOf(activeElement);\n\n  if (x > -1) {\n    x += shiftKey ? -1 : 1;\n  }\n\n  target = tabbable[x];\n\n  // If the tabbable element does not exist,\n  // focus head/tail based on shiftKey\n  if (typeof target === \"undefined\") {\n    event.preventDefault();\n    target = shiftKey ? tail : head;\n    target.focus();\n    return;\n  }\n\n  event.preventDefault();\n\n  target.focus();\n}\nmodule.exports = exports[\"default\"];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9saWIvaGVscGVycy9zY29wZVRhYi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTs7QUFFZixnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBWTs7QUFFcEM7O0FBRUEsdUNBQXVDLHVDQUF1Qzs7QUFFOUU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL2xpYi9oZWxwZXJzL3Njb3BlVGFiLmpzPzc0ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBzY29wZVRhYjtcblxudmFyIF90YWJiYWJsZSA9IHJlcXVpcmUoXCIuL3RhYmJhYmxlXCIpO1xuXG52YXIgX3RhYmJhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhYmJhYmxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudCgpIHtcbiAgdmFyIGVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBkb2N1bWVudDtcblxuICByZXR1cm4gZWwuYWN0aXZlRWxlbWVudC5zaGFkb3dSb290ID8gZ2V0QWN0aXZlRWxlbWVudChlbC5hY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QpIDogZWwuYWN0aXZlRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gc2NvcGVUYWIobm9kZSwgZXZlbnQpIHtcbiAgdmFyIHRhYmJhYmxlID0gKDAsIF90YWJiYWJsZTIuZGVmYXVsdCkobm9kZSk7XG5cbiAgaWYgKCF0YWJiYWJsZS5sZW5ndGgpIHtcbiAgICAvLyBEbyBub3RoaW5nLCBzaW5jZSB0aGVyZSBhcmUgbm8gZWxlbWVudHMgdGhhdCBjYW4gcmVjZWl2ZSBmb2N1cy5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0YXJnZXQgPSB2b2lkIDA7XG5cbiAgdmFyIHNoaWZ0S2V5ID0gZXZlbnQuc2hpZnRLZXk7XG4gIHZhciBoZWFkID0gdGFiYmFibGVbMF07XG4gIHZhciB0YWlsID0gdGFiYmFibGVbdGFiYmFibGUubGVuZ3RoIC0gMV07XG4gIHZhciBhY3RpdmVFbGVtZW50ID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuXG4gIC8vIHByb2NlZWQgd2l0aCBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3Igb24gdGFiLlxuICAvLyBGb2N1cyBvbiBsYXN0IGVsZW1lbnQgb24gc2hpZnQgKyB0YWIuXG4gIGlmIChub2RlID09PSBhY3RpdmVFbGVtZW50KSB7XG4gICAgaWYgKCFzaGlmdEtleSkgcmV0dXJuO1xuICAgIHRhcmdldCA9IHRhaWw7XG4gIH1cblxuICBpZiAodGFpbCA9PT0gYWN0aXZlRWxlbWVudCAmJiAhc2hpZnRLZXkpIHtcbiAgICB0YXJnZXQgPSBoZWFkO1xuICB9XG5cbiAgaWYgKGhlYWQgPT09IGFjdGl2ZUVsZW1lbnQgJiYgc2hpZnRLZXkpIHtcbiAgICB0YXJnZXQgPSB0YWlsO1xuICB9XG5cbiAgaWYgKHRhcmdldCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gU2FmYXJpIHJhZGlvIGlzc3VlLlxuICAvL1xuICAvLyBTYWZhcmkgZG9lcyBub3QgbW92ZSB0aGUgZm9jdXMgdG8gdGhlIHJhZGlvIGJ1dHRvbixcbiAgLy8gc28gd2UgbmVlZCB0byBmb3JjZSBpdCB0byByZWFsbHkgd2FsayB0aHJvdWdoIGFsbCBlbGVtZW50cy5cbiAgLy9cbiAgLy8gVGhpcyBpcyB2ZXJ5IGVycm9yIHByb25lLCBzaW5jZSB3ZSBhcmUgdHJ5aW5nIHRvIGd1ZXNzXG4gIC8vIGlmIGl0IGlzIGEgc2FmYXJpIGJyb3dzZXIgZnJvbSB0aGUgZmlyc3Qgb2NjdXJlbmNlIGJldHdlZW5cbiAgLy8gY2hyb21lIG9yIHNhZmFyaS5cbiAgLy9cbiAgLy8gVGhlIGNocm9tZSB1c2VyIGFnZW50IGNvbnRhaW5zIHRoZSBmaXJzdCBvY3VycmVuY2VcbiAgLy8gYXMgdGhlICdjaHJvbWUvdmVyc2lvbicgYW5kIGxhdGVyIHRoZSAnc2FmYXJpL3ZlcnNpb24nLlxuICB2YXIgY2hlY2tTYWZhcmkgPSAvKFxcYkNocm9tZVxcYnxcXGJTYWZhcmlcXGIpXFwvLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB2YXIgaXNTYWZhcmlEZXNrdG9wID0gY2hlY2tTYWZhcmkgIT0gbnVsbCAmJiBjaGVja1NhZmFyaVsxXSAhPSBcIkNocm9tZVwiICYmIC9cXGJpUG9kXFxifFxcYmlQYWRcXGIvZy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpID09IG51bGw7XG5cbiAgLy8gSWYgd2UgYXJlIG5vdCBpbiBzYWZhcmkgZGVza3RvcCwgbGV0IHRoZSBicm93c2VyIGNvbnRyb2xcbiAgLy8gdGhlIGZvY3VzXG4gIGlmICghaXNTYWZhcmlEZXNrdG9wKSByZXR1cm47XG5cbiAgdmFyIHggPSB0YWJiYWJsZS5pbmRleE9mKGFjdGl2ZUVsZW1lbnQpO1xuXG4gIGlmICh4ID4gLTEpIHtcbiAgICB4ICs9IHNoaWZ0S2V5ID8gLTEgOiAxO1xuICB9XG5cbiAgdGFyZ2V0ID0gdGFiYmFibGVbeF07XG5cbiAgLy8gSWYgdGhlIHRhYmJhYmxlIGVsZW1lbnQgZG9lcyBub3QgZXhpc3QsXG4gIC8vIGZvY3VzIGhlYWQvdGFpbCBiYXNlZCBvbiBzaGlmdEtleVxuICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGFyZ2V0ID0gc2hpZnRLZXkgPyB0YWlsIDogaGVhZDtcbiAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIHRhcmdldC5mb2N1cygpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-modal/lib/helpers/scopeTab.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-modal/lib/helpers/tabbable.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-modal/lib/helpers/tabbable.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = findTabbableDescendants;\n/*!\n * Adapted from jQuery UI core\n *\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/category/ui-core/\n */\n\nvar DISPLAY_NONE = \"none\";\nvar DISPLAY_CONTENTS = \"contents\";\n\nvar tabbableNode = /input|select|textarea|button|object|iframe/;\n\nfunction isNotOverflowing(element, style) {\n  return style.getPropertyValue(\"overflow\") !== \"visible\" ||\n  // if 'overflow: visible' set, check if there is actually any overflow\n  element.scrollWidth <= 0 && element.scrollHeight <= 0;\n}\n\nfunction hidesContents(element) {\n  var zeroSize = element.offsetWidth <= 0 && element.offsetHeight <= 0;\n\n  // If the node is empty, this is good enough\n  if (zeroSize && !element.innerHTML) return true;\n\n  try {\n    // Otherwise we need to check some styles\n    var style = window.getComputedStyle(element);\n    var displayValue = style.getPropertyValue(\"display\");\n    return zeroSize ? displayValue !== DISPLAY_CONTENTS && isNotOverflowing(element, style) : displayValue === DISPLAY_NONE;\n  } catch (exception) {\n    // eslint-disable-next-line no-console\n    console.warn(\"Failed to inspect element style\");\n    return false;\n  }\n}\n\nfunction visible(element) {\n  var parentElement = element;\n  var rootNode = element.getRootNode && element.getRootNode();\n  while (parentElement) {\n    if (parentElement === document.body) break;\n\n    // if we are not hidden yet, skip to checking outside the Web Component\n    if (rootNode && parentElement === rootNode) parentElement = rootNode.host.parentNode;\n\n    if (hidesContents(parentElement)) return false;\n    parentElement = parentElement.parentNode;\n  }\n  return true;\n}\n\nfunction focusable(element, isTabIndexNotNaN) {\n  var nodeName = element.nodeName.toLowerCase();\n  var res = tabbableNode.test(nodeName) && !element.disabled || (nodeName === \"a\" ? element.href || isTabIndexNotNaN : isTabIndexNotNaN);\n  return res && visible(element);\n}\n\nfunction tabbable(element) {\n  var tabIndex = element.getAttribute(\"tabindex\");\n  if (tabIndex === null) tabIndex = undefined;\n  var isTabIndexNaN = isNaN(tabIndex);\n  return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);\n}\n\nfunction findTabbableDescendants(element) {\n  var descendants = [].slice.call(element.querySelectorAll(\"*\"), 0).reduce(function (finished, el) {\n    return finished.concat(!el.shadowRoot ? [el] : findTabbableDescendants(el.shadowRoot));\n  }, []);\n  return descendants.filter(tabbable);\n}\nmodule.exports = exports[\"default\"];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9saWIvaGVscGVycy90YWJiYWJsZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbGliL2hlbHBlcnMvdGFiYmFibGUuanM/OWExMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZpbmRUYWJiYWJsZURlc2NlbmRhbnRzO1xuLyohXG4gKiBBZGFwdGVkIGZyb20galF1ZXJ5IFVJIGNvcmVcbiAqXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2NhdGVnb3J5L3VpLWNvcmUvXG4gKi9cblxudmFyIERJU1BMQVlfTk9ORSA9IFwibm9uZVwiO1xudmFyIERJU1BMQVlfQ09OVEVOVFMgPSBcImNvbnRlbnRzXCI7XG5cbnZhciB0YWJiYWJsZU5vZGUgPSAvaW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbnxvYmplY3R8aWZyYW1lLztcblxuZnVuY3Rpb24gaXNOb3RPdmVyZmxvd2luZyhlbGVtZW50LCBzdHlsZSkge1xuICByZXR1cm4gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIm92ZXJmbG93XCIpICE9PSBcInZpc2libGVcIiB8fFxuICAvLyBpZiAnb3ZlcmZsb3c6IHZpc2libGUnIHNldCwgY2hlY2sgaWYgdGhlcmUgaXMgYWN0dWFsbHkgYW55IG92ZXJmbG93XG4gIGVsZW1lbnQuc2Nyb2xsV2lkdGggPD0gMCAmJiBlbGVtZW50LnNjcm9sbEhlaWdodCA8PSAwO1xufVxuXG5mdW5jdGlvbiBoaWRlc0NvbnRlbnRzKGVsZW1lbnQpIHtcbiAgdmFyIHplcm9TaXplID0gZWxlbWVudC5vZmZzZXRXaWR0aCA8PSAwICYmIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IDw9IDA7XG5cbiAgLy8gSWYgdGhlIG5vZGUgaXMgZW1wdHksIHRoaXMgaXMgZ29vZCBlbm91Z2hcbiAgaWYgKHplcm9TaXplICYmICFlbGVtZW50LmlubmVySFRNTCkgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICAvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byBjaGVjayBzb21lIHN0eWxlc1xuICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIHZhciBkaXNwbGF5VmFsdWUgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiZGlzcGxheVwiKTtcbiAgICByZXR1cm4gemVyb1NpemUgPyBkaXNwbGF5VmFsdWUgIT09IERJU1BMQVlfQ09OVEVOVFMgJiYgaXNOb3RPdmVyZmxvd2luZyhlbGVtZW50LCBzdHlsZSkgOiBkaXNwbGF5VmFsdWUgPT09IERJU1BMQVlfTk9ORTtcbiAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gaW5zcGVjdCBlbGVtZW50IHN0eWxlXCIpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2aXNpYmxlKGVsZW1lbnQpIHtcbiAgdmFyIHBhcmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICB2YXIgcm9vdE5vZGUgPSBlbGVtZW50LmdldFJvb3ROb2RlICYmIGVsZW1lbnQuZ2V0Um9vdE5vZGUoKTtcbiAgd2hpbGUgKHBhcmVudEVsZW1lbnQpIHtcbiAgICBpZiAocGFyZW50RWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSkgYnJlYWs7XG5cbiAgICAvLyBpZiB3ZSBhcmUgbm90IGhpZGRlbiB5ZXQsIHNraXAgdG8gY2hlY2tpbmcgb3V0c2lkZSB0aGUgV2ViIENvbXBvbmVudFxuICAgIGlmIChyb290Tm9kZSAmJiBwYXJlbnRFbGVtZW50ID09PSByb290Tm9kZSkgcGFyZW50RWxlbWVudCA9IHJvb3ROb2RlLmhvc3QucGFyZW50Tm9kZTtcblxuICAgIGlmIChoaWRlc0NvbnRlbnRzKHBhcmVudEVsZW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gICAgcGFyZW50RWxlbWVudCA9IHBhcmVudEVsZW1lbnQucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZm9jdXNhYmxlKGVsZW1lbnQsIGlzVGFiSW5kZXhOb3ROYU4pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgcmVzID0gdGFiYmFibGVOb2RlLnRlc3Qobm9kZU5hbWUpICYmICFlbGVtZW50LmRpc2FibGVkIHx8IChub2RlTmFtZSA9PT0gXCJhXCIgPyBlbGVtZW50LmhyZWYgfHwgaXNUYWJJbmRleE5vdE5hTiA6IGlzVGFiSW5kZXhOb3ROYU4pO1xuICByZXR1cm4gcmVzICYmIHZpc2libGUoZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIHRhYmJhYmxlKGVsZW1lbnQpIHtcbiAgdmFyIHRhYkluZGV4ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKTtcbiAgaWYgKHRhYkluZGV4ID09PSBudWxsKSB0YWJJbmRleCA9IHVuZGVmaW5lZDtcbiAgdmFyIGlzVGFiSW5kZXhOYU4gPSBpc05hTih0YWJJbmRleCk7XG4gIHJldHVybiAoaXNUYWJJbmRleE5hTiB8fCB0YWJJbmRleCA+PSAwKSAmJiBmb2N1c2FibGUoZWxlbWVudCwgIWlzVGFiSW5kZXhOYU4pO1xufVxuXG5mdW5jdGlvbiBmaW5kVGFiYmFibGVEZXNjZW5kYW50cyhlbGVtZW50KSB7XG4gIHZhciBkZXNjZW5kYW50cyA9IFtdLnNsaWNlLmNhbGwoZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKSwgMCkucmVkdWNlKGZ1bmN0aW9uIChmaW5pc2hlZCwgZWwpIHtcbiAgICByZXR1cm4gZmluaXNoZWQuY29uY2F0KCFlbC5zaGFkb3dSb290ID8gW2VsXSA6IGZpbmRUYWJiYWJsZURlc2NlbmRhbnRzKGVsLnNoYWRvd1Jvb3QpKTtcbiAgfSwgW10pO1xuICByZXR1cm4gZGVzY2VuZGFudHMuZmlsdGVyKHRhYmJhYmxlKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-modal/lib/helpers/tabbable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-modal/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/react-modal/lib/index.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar _Modal = __webpack_require__(/*! ./components/Modal */ \"(app-pages-browser)/./node_modules/react-modal/lib/components/Modal.js\");\n\nvar _Modal2 = _interopRequireDefault(_Modal);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports[\"default\"] = _Modal2.default;\nmodule.exports = exports[\"default\"];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDOztBQUVGLGFBQWEsbUJBQU8sQ0FBQyxrR0FBb0I7O0FBRXpDOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL2xpYi9pbmRleC5qcz8zYzE4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX01vZGFsID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9Nb2RhbFwiKTtcblxudmFyIF9Nb2RhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Nb2RhbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9Nb2RhbDIuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-modal/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/warning/warning.js":
/*!*****************************************!*\
  !*** ./node_modules/warning/warning.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar __DEV__ = \"development\" !== 'production';\n\nvar warning = function() {};\n\nif (__DEV__) {\n  var printWarning = function printWarning(format, args) {\n    var len = arguments.length;\n    args = new Array(len > 1 ? len - 1 : 0);\n    for (var key = 1; key < len; key++) {\n      args[key - 1] = arguments[key];\n    }\n    var argIndex = 0;\n    var message = 'Warning: ' +\n      format.replace(/%s/g, function() {\n        return args[argIndex++];\n      });\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  }\n\n  warning = function(condition, format, args) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    if (format === undefined) {\n      throw new Error(\n          '`warning(condition, format, ...args)` requires a warning ' +\n          'message argument'\n      );\n    }\n    if (!condition) {\n      printWarning.apply(null, [format].concat(args));\n    }\n  };\n}\n\nmodule.exports = warning;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93YXJuaW5nL3dhcm5pbmcuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGFBQW9COztBQUVsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy93YXJuaW5nL3dhcm5pbmcuanM/MWE1OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIF9fREVWX18gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nO1xuXG52YXIgd2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChfX0RFVl9fKSB7XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0LCBhcmdzKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gPiAxID8gbGVuIC0gMSA6IDApO1xuICAgIGZvciAodmFyIGtleSA9IDE7IGtleSA8IGxlbjsga2V5KyspIHtcbiAgICAgIGFyZ3Nba2V5IC0gMV0gPSBhcmd1bWVudHNba2V5XTtcbiAgICB9XG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICtcbiAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9XG5cbiAgd2FybmluZyA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhcmdzKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gPiAyID8gbGVuIC0gMiA6IDApO1xuICAgIGZvciAodmFyIGtleSA9IDI7IGtleSA8IGxlbjsga2V5KyspIHtcbiAgICAgIGFyZ3Nba2V5IC0gMl0gPSBhcmd1bWVudHNba2V5XTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgK1xuICAgICAgICAgICdtZXNzYWdlIGFyZ3VtZW50J1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHByaW50V2FybmluZy5hcHBseShudWxsLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/warning/warning.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"17678d880a6b\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2dsb2JhbHMuY3NzPzBkYzgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIxNzY3OGQ4ODBhNmJcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/ClientWrapper.js":
/*!******************************!*\
  !*** ./app/ClientWrapper.js ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ClientWrapper; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction ClientWrapper(param) {\n    let { children } = param;\n    _s();\n    const [cart, setCart] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const storedCart = JSON.parse(localStorage.getItem(\"cart\") || \"[]\");\n        setCart(storedCart);\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        localStorage.setItem(\"cart\", JSON.stringify(cart));\n    }, [\n        cart\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: children\n    }, void 0, false);\n}\n_s(ClientWrapper, \"gPYbNUmWK8tVVPcrFDrHV23HVlE=\");\n_c = ClientWrapper;\nvar _c;\n$RefreshReg$(_c, \"ClientWrapper\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9DbGllbnRXcmFwcGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUVtRDtBQUVwQyxTQUFTRyxjQUFjLEtBQVk7UUFBWixFQUFFQyxRQUFRLEVBQUUsR0FBWjs7SUFDbEMsTUFBTSxDQUFDQyxNQUFNQyxRQUFRLEdBQUdKLCtDQUFRQSxDQUFDLEVBQUU7SUFFbkNELGdEQUFTQSxDQUFDO1FBQ04sTUFBTU0sYUFBYUMsS0FBS0MsS0FBSyxDQUFDQyxhQUFhQyxPQUFPLENBQUMsV0FBVztRQUM5REwsUUFBUUM7SUFDWixHQUFHLEVBQUU7SUFFTE4sZ0RBQVNBLENBQUM7UUFDTlMsYUFBYUUsT0FBTyxDQUFDLFFBQVFKLEtBQUtLLFNBQVMsQ0FBQ1I7SUFDaEQsR0FBRztRQUFDQTtLQUFLO0lBRVQscUJBQ0k7a0JBQ0tEOztBQUdiO0dBakJ3QkQ7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL0NsaWVudFdyYXBwZXIuanM/NzE2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcclxuXHJcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2xpZW50V3JhcHBlcih7IGNoaWxkcmVuIH0pIHtcclxuICAgIGNvbnN0IFtjYXJ0LCBzZXRDYXJ0XSA9IHVzZVN0YXRlKFtdKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN0b3JlZENhcnQgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjYXJ0JykgfHwgJ1tdJyk7XHJcbiAgICAgICAgc2V0Q2FydChzdG9yZWRDYXJ0KTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjYXJ0JywgSlNPTi5zdHJpbmdpZnkoY2FydCkpO1xyXG4gICAgfSwgW2NhcnRdKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDw+XHJcbiAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICA8Lz5cclxuICAgICk7XHJcbn1cclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJDbGllbnRXcmFwcGVyIiwiY2hpbGRyZW4iLCJjYXJ0Iiwic2V0Q2FydCIsInN0b3JlZENhcnQiLCJKU09OIiwicGFyc2UiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic2V0SXRlbSIsInN0cmluZ2lmeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/ClientWrapper.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/header.js":
/*!***********************!*\
  !*** ./app/header.js ***!
  \***********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Header; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _appwrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../appwrite */ \"(app-pages-browser)/./appwrite.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react_modal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-modal */ \"(app-pages-browser)/./node_modules/react-modal/lib/index.js\");\n/* harmony import */ var react_modal__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_modal__WEBPACK_IMPORTED_MODULE_4__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nfunction Header(param) {\n    let { cart, setCart } = param;\n    _s();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_3__.useRouter)();\n    const [modalIsOpen, setModalIsOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        async function fetchUser() {\n            try {\n                const user = await _appwrite__WEBPACK_IMPORTED_MODULE_2__.account.get();\n                setUser(user);\n            } catch (error) {\n                console.error(\"User not logged in\", error);\n            }\n        }\n        fetchUser();\n    }, []);\n    const openModal = ()=>{\n        setModalIsOpen(true);\n    };\n    const closeModal = ()=>{\n        setModalIsOpen(false);\n    };\n    const removeFromCart = (itemId)=>{\n        const updatedCart = cart.filter((item)=>item.id !== itemId);\n        setCart(updatedCart);\n        localStorage.setItem(\"cart\", JSON.stringify(updatedCart));\n    };\n    const clearCart = ()=>{\n        setCart([]);\n        localStorage.setItem(\"cart\", JSON.stringify([]));\n    };\n    const placeOrder = ()=>{\n        console.log(\"Order placed:\", cart);\n        clearCart();\n        closeModal();\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n                className: \"bg-white border-gray-200\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex flex-wrap justify-between items-center mx-auto max-w-screen-xl p-4\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                            href: \"/\",\n                            className: \"flex items-center\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"self-center text-2xl font-semibold whitespace-nowrap\",\n                                children: \"SportClub\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                                lineNumber: 54,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                            lineNumber: 53,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    href: \"tel:5541251234\",\n                                    className: \"mr-6 text-sm text-gray-500 hover:underline\",\n                                    children: \"(555) 412-1234\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                                    lineNumber: 57,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: openModal,\n                                    className: \"text-sm text-blue-600 hover:underline\",\n                                    children: [\n                                        \"Cart (\",\n                                        cart ? cart.length : 0,\n                                        \")\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                                    lineNumber: 58,\n                                    columnNumber: 13\n                                }, this),\n                                user ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                        href: \"/account\",\n                                        className: \"text-sm text-blue-600 hover:underline ml-4\",\n                                        children: \"Personal Account\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                                        lineNumber: 61,\n                                        columnNumber: 17\n                                    }, this)\n                                }, void 0, false) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                            href: \"/login\",\n                                            className: \"text-sm text-blue-600 hover:underline ml-4\",\n                                            children: \"Login\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                                            lineNumber: 65,\n                                            columnNumber: 17\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                            href: \"/register\",\n                                            className: \"text-sm text-blue-600 hover:underline ml-4\",\n                                            children: \"Register\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                                            lineNumber: 66,\n                                            columnNumber: 17\n                                        }, this)\n                                    ]\n                                }, void 0, true)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                            lineNumber: 56,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                    lineNumber: 52,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                lineNumber: 51,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n                className: \"bg-gray-50\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"max-w-screen-xl px-4 py-3 mx-auto\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex items-center\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                            className: \"flex flex-row font-medium mt-0 mr-6 space-x-8 text-sm\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                        href: \"/\",\n                                        className: \"text-gray-900 hover:underline\",\n                                        children: \"\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                                        lineNumber: 76,\n                                        columnNumber: 19\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                                    lineNumber: 76,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                        href: \"/house\",\n                                        className: \"text-gray-900 hover:underline\",\n                                        children: \"\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                                        lineNumber: 77,\n                                        columnNumber: 19\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                                    lineNumber: 77,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                        href: \"/fight\",\n                                        className: \"text-gray-900 hover:underline\",\n                                        children: \" \"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                                        lineNumber: 78,\n                                        columnNumber: 19\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                                    lineNumber: 78,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                        href: \"/relax\",\n                                        className: \"text-gray-900 hover:underline\",\n                                        children: \"\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                                        lineNumber: 79,\n                                        columnNumber: 19\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                                    lineNumber: 79,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                        href: \"/outside\",\n                                        className: \"text-gray-900 hover:underline\",\n                                        children: \"\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                                        lineNumber: 80,\n                                        columnNumber: 19\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                                    lineNumber: 80,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                            lineNumber: 75,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                        lineNumber: 74,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                    lineNumber: 73,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                lineNumber: 72,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((react_modal__WEBPACK_IMPORTED_MODULE_4___default()), {\n                isOpen: modalIsOpen,\n                onRequestClose: closeModal,\n                contentLabel: \"Cart Modal\",\n                className: \"modal\",\n                overlayClassName: \"overlay\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        children: \"Shopping Cart\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                        lineNumber: 93,\n                        columnNumber: 9\n                    }, this),\n                    cart && cart.length > 0 ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                                children: cart.map((item)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                        className: \"mb-4 flex justify-between items-center\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                children: [\n                                                    item.title,\n                                                    \" - \",\n                                                    item.price,\n                                                    \" .\"\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                                                lineNumber: 99,\n                                                columnNumber: 19\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                onClick: ()=>removeFromCart(item.id),\n                                                className: \"text-red-600 hover:underline\",\n                                                children: \"Remove\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                                                lineNumber: 100,\n                                                columnNumber: 19\n                                            }, this)\n                                        ]\n                                    }, item.id, true, {\n                                        fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                                        lineNumber: 98,\n                                        columnNumber: 17\n                                    }, this))\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                                lineNumber: 96,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: clearCart,\n                                className: \"w-full bg-red-600 text-white py-2 rounded hover:bg-red-700 transition-colors\",\n                                children: \"Clear Cart\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                                lineNumber: 104,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: placeOrder,\n                                className: \"w-full bg-green-600 text-white py-2 rounded hover:bg-green-700 transition-colors mt-4\",\n                                children: \"Place Order\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                                lineNumber: 105,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-center text-gray-500\",\n                        children: \"Your cart is empty\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                        lineNumber: 108,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: closeModal,\n                        className: \"mt-4 bg-blue-500 text-white py-2 px-4 rounded\",\n                        children: \"Close\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                        lineNumber: 110,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n                lineNumber: 86,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\SITRIX\\\\OneDrive\\\\ \\\\netavto\\\\  (2)\\\\sport_club\\\\app\\\\header.js\",\n        lineNumber: 50,\n        columnNumber: 5\n    }, this);\n}\n_s(Header, \"SkEoVHzS64VEsUJOf9qvx2lD52c=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_3__.useRouter\n    ];\n});\n_c = Header;\nvar _c;\n$RefreshReg$(_c, \"Header\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Ozs7Ozs7Ozs7Ozs7OzBCQU16RSw4REFBQzlCLG9EQUFLQTtnQkFDSndDLFFBQVFqQztnQkFDUmtDLGdCQUFnQjNCO2dCQUNoQjRCLGNBQWE7Z0JBQ2JaLFdBQVU7Z0JBQ1ZhLGtCQUFpQjs7a0NBRWpCLDhEQUFDQztrQ0FBRzs7Ozs7O29CQUNIMUMsUUFBUUEsS0FBS21DLE1BQU0sR0FBRyxrQkFDckI7OzBDQUNFLDhEQUFDQzswQ0FDRXBDLEtBQUsyQyxHQUFHLENBQUMxQixDQUFBQSxxQkFDUiw4REFBQ29CO3dDQUFpQlQsV0FBVTs7MERBQzFCLDhEQUFDSTs7b0RBQU1mLEtBQUsyQixLQUFLO29EQUFDO29EQUFJM0IsS0FBSzRCLEtBQUs7b0RBQUM7Ozs7Ozs7MERBQ2pDLDhEQUFDWjtnREFBT0MsU0FBUyxJQUFNckIsZUFBZUksS0FBS0MsRUFBRTtnREFBR1UsV0FBVTswREFBK0I7Ozs7Ozs7dUNBRmxGWCxLQUFLQyxFQUFFOzs7Ozs7Ozs7OzBDQU1wQiw4REFBQ2U7Z0NBQU9DLFNBQVNYO2dDQUFXSyxXQUFVOzBDQUErRTs7Ozs7OzBDQUNySCw4REFBQ0s7Z0NBQU9DLFNBQVNWO2dDQUFZSSxXQUFVOzBDQUF3Rjs7Ozs7OztxREFHakksOERBQUNrQjt3QkFBRWxCLFdBQVU7a0NBQTRCOzs7Ozs7a0NBRTNDLDhEQUFDSzt3QkFBT0MsU0FBU3RCO3dCQUFZZ0IsV0FBVTtrQ0FBZ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUkvRjtHQTNHd0I3Qjs7UUFFUEYsc0RBQVNBOzs7S0FGRkUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2hlYWRlci5qcz83N2Y5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBhY2NvdW50IH0gZnJvbSAnLi4vYXBwd3JpdGUnO1xuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJztcbmltcG9ydCBNb2RhbCBmcm9tICdyZWFjdC1tb2RhbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhlYWRlcih7IGNhcnQsIHNldENhcnQgfSkge1xuICBjb25zdCBbdXNlciwgc2V0VXNlcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XG4gIGNvbnN0IFttb2RhbElzT3Blbiwgc2V0TW9kYWxJc09wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hVc2VyKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGFjY291bnQuZ2V0KCk7XG4gICAgICAgIHNldFVzZXIodXNlcik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVXNlciBub3QgbG9nZ2VkIGluXCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmV0Y2hVc2VyKCk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBvcGVuTW9kYWwgPSAoKSA9PiB7XG4gICAgc2V0TW9kYWxJc09wZW4odHJ1ZSk7XG4gIH07XG5cbiAgY29uc3QgY2xvc2VNb2RhbCA9ICgpID0+IHtcbiAgICBzZXRNb2RhbElzT3BlbihmYWxzZSk7XG4gIH07XG5cbiAgY29uc3QgcmVtb3ZlRnJvbUNhcnQgPSAoaXRlbUlkKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlZENhcnQgPSBjYXJ0LmZpbHRlcihpdGVtID0+IGl0ZW0uaWQgIT09IGl0ZW1JZCk7XG4gICAgc2V0Q2FydCh1cGRhdGVkQ2FydCk7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJjYXJ0XCIsIEpTT04uc3RyaW5naWZ5KHVwZGF0ZWRDYXJ0KSk7XG4gIH07XG5cbiAgY29uc3QgY2xlYXJDYXJ0ID0gKCkgPT4ge1xuICAgIHNldENhcnQoW10pO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiY2FydFwiLCBKU09OLnN0cmluZ2lmeShbXSkpO1xuICB9O1xuXG4gIGNvbnN0IHBsYWNlT3JkZXIgPSAoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ09yZGVyIHBsYWNlZDonLCBjYXJ0KTtcbiAgICBjbGVhckNhcnQoKTtcbiAgICBjbG9zZU1vZGFsKCk7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8aGVhZGVyPlxuICAgICAgPG5hdiBjbGFzc05hbWU9XCJiZy13aGl0ZSBib3JkZXItZ3JheS0yMDBcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtd3JhcCBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtY2VudGVyIG14LWF1dG8gbWF4LXctc2NyZWVuLXhsIHAtNFwiPlxuICAgICAgICAgIDxhIGhyZWY9XCIvXCIgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInNlbGYtY2VudGVyIHRleHQtMnhsIGZvbnQtc2VtaWJvbGQgd2hpdGVzcGFjZS1ub3dyYXBcIj5TcG9ydENsdWI8L3NwYW4+XG4gICAgICAgICAgPC9hPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICAgIDxhIGhyZWY9XCJ0ZWw6NTU0MTI1MTIzNFwiIGNsYXNzTmFtZT1cIm1yLTYgdGV4dC1zbSB0ZXh0LWdyYXktNTAwIGhvdmVyOnVuZGVybGluZVwiPig1NTUpIDQxMi0xMjM0PC9hPlxuICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtvcGVuTW9kYWx9IGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1ibHVlLTYwMCBob3Zlcjp1bmRlcmxpbmVcIj5DYXJ0ICh7Y2FydCA/IGNhcnQubGVuZ3RoIDogMH0pPC9idXR0b24+XG4gICAgICAgICAgICB7dXNlciA/IChcbiAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICA8YSBocmVmPVwiL2FjY291bnRcIiBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtYmx1ZS02MDAgaG92ZXI6dW5kZXJsaW5lIG1sLTRcIj5QZXJzb25hbCBBY2NvdW50PC9hPlxuICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cIi9sb2dpblwiIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1ibHVlLTYwMCBob3Zlcjp1bmRlcmxpbmUgbWwtNFwiPkxvZ2luPC9hPlxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XCIvcmVnaXN0ZXJcIiBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtYmx1ZS02MDAgaG92ZXI6dW5kZXJsaW5lIG1sLTRcIj5SZWdpc3RlcjwvYT5cbiAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvbmF2PlxuICAgICAgPG5hdiBjbGFzc05hbWU9XCJiZy1ncmF5LTUwXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWF4LXctc2NyZWVuLXhsIHB4LTQgcHktMyBteC1hdXRvXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlclwiPlxuICAgICAgICAgICAgPHVsIGNsYXNzTmFtZT1cImZsZXggZmxleC1yb3cgZm9udC1tZWRpdW0gbXQtMCBtci02IHNwYWNlLXgtOCB0ZXh0LXNtXCI+XG4gICAgICAgICAgICAgIDxsaT48YSBocmVmPVwiL1wiIGNsYXNzTmFtZT1cInRleHQtZ3JheS05MDAgaG92ZXI6dW5kZXJsaW5lXCI+0JPQu9Cw0LLQvdCw0Y88L2E+PC9saT5cbiAgICAgICAgICAgICAgPGxpPjxhIGhyZWY9XCIvaG91c2VcIiBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktOTAwIGhvdmVyOnVuZGVybGluZVwiPtCk0LjRgtC90LXRgTwvYT48L2xpPlxuICAgICAgICAgICAgICA8bGk+PGEgaHJlZj1cIi9maWdodFwiIGNsYXNzTmFtZT1cInRleHQtZ3JheS05MDAgaG92ZXI6dW5kZXJsaW5lXCI+0JvQtdCz0LrQsNGPINCw0YLQu9C10YLQuNC60LA8L2E+PC9saT5cbiAgICAgICAgICAgICAgPGxpPjxhIGhyZWY9XCIvcmVsYXhcIiBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktOTAwIGhvdmVyOnVuZGVybGluZVwiPtCe0YLQtNGL0YU8L2E+PC9saT5cbiAgICAgICAgICAgICAgPGxpPjxhIGhyZWY9XCIvb3V0c2lkZVwiIGNsYXNzTmFtZT1cInRleHQtZ3JheS05MDAgaG92ZXI6dW5kZXJsaW5lXCI+0KLRgNC10L3QsNC20LXRgNGLPC9hPjwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvbmF2PlxuXG4gICAgICA8TW9kYWxcbiAgICAgICAgaXNPcGVuPXttb2RhbElzT3Blbn1cbiAgICAgICAgb25SZXF1ZXN0Q2xvc2U9e2Nsb3NlTW9kYWx9XG4gICAgICAgIGNvbnRlbnRMYWJlbD1cIkNhcnQgTW9kYWxcIlxuICAgICAgICBjbGFzc05hbWU9XCJtb2RhbFwiXG4gICAgICAgIG92ZXJsYXlDbGFzc05hbWU9XCJvdmVybGF5XCJcbiAgICAgID5cbiAgICAgICAgPGgyPlNob3BwaW5nIENhcnQ8L2gyPlxuICAgICAgICB7Y2FydCAmJiBjYXJ0Lmxlbmd0aCA+IDAgPyAoXG4gICAgICAgICAgPD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAge2NhcnQubWFwKGl0ZW0gPT4gKFxuICAgICAgICAgICAgICAgIDxsaSBrZXk9e2l0ZW0uaWR9IGNsYXNzTmFtZT1cIm1iLTQgZmxleCBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICA8c3Bhbj57aXRlbS50aXRsZX0gLSB7aXRlbS5wcmljZX0g0YDRg9CxLjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gcmVtb3ZlRnJvbUNhcnQoaXRlbS5pZCl9IGNsYXNzTmFtZT1cInRleHQtcmVkLTYwMCBob3Zlcjp1bmRlcmxpbmVcIj5SZW1vdmU8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e2NsZWFyQ2FydH0gY2xhc3NOYW1lPVwidy1mdWxsIGJnLXJlZC02MDAgdGV4dC13aGl0ZSBweS0yIHJvdW5kZWQgaG92ZXI6YmctcmVkLTcwMCB0cmFuc2l0aW9uLWNvbG9yc1wiPkNsZWFyIENhcnQ8L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17cGxhY2VPcmRlcn0gY2xhc3NOYW1lPVwidy1mdWxsIGJnLWdyZWVuLTYwMCB0ZXh0LXdoaXRlIHB5LTIgcm91bmRlZCBob3ZlcjpiZy1ncmVlbi03MDAgdHJhbnNpdGlvbi1jb2xvcnMgbXQtNFwiPlBsYWNlIE9yZGVyPC9idXR0b24+XG4gICAgICAgICAgPC8+XG4gICAgICAgICkgOiAoXG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXIgdGV4dC1ncmF5LTUwMFwiPllvdXIgY2FydCBpcyBlbXB0eTwvcD5cbiAgICAgICAgKX1cbiAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtjbG9zZU1vZGFsfSBjbGFzc05hbWU9XCJtdC00IGJnLWJsdWUtNTAwIHRleHQtd2hpdGUgcHktMiBweC00IHJvdW5kZWRcIj5DbG9zZTwvYnV0dG9uPlxuICAgICAgPC9Nb2RhbD5cbiAgICA8L2hlYWRlcj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiYWNjb3VudCIsInVzZVJvdXRlciIsIk1vZGFsIiwiSGVhZGVyIiwiY2FydCIsInNldENhcnQiLCJ1c2VyIiwic2V0VXNlciIsInJvdXRlciIsIm1vZGFsSXNPcGVuIiwic2V0TW9kYWxJc09wZW4iLCJmZXRjaFVzZXIiLCJnZXQiLCJlcnJvciIsImNvbnNvbGUiLCJvcGVuTW9kYWwiLCJjbG9zZU1vZGFsIiwicmVtb3ZlRnJvbUNhcnQiLCJpdGVtSWQiLCJ1cGRhdGVkQ2FydCIsImZpbHRlciIsIml0ZW0iLCJpZCIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJKU09OIiwic3RyaW5naWZ5IiwiY2xlYXJDYXJ0IiwicGxhY2VPcmRlciIsImxvZyIsImhlYWRlciIsIm5hdiIsImNsYXNzTmFtZSIsImRpdiIsImEiLCJocmVmIiwic3BhbiIsImJ1dHRvbiIsIm9uQ2xpY2siLCJsZW5ndGgiLCJ1bCIsImxpIiwiaXNPcGVuIiwib25SZXF1ZXN0Q2xvc2UiLCJjb250ZW50TGFiZWwiLCJvdmVybGF5Q2xhc3NOYW1lIiwiaDIiLCJtYXAiLCJ0aXRsZSIsInByaWNlIiwicCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/header.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./appwrite.js":
/*!*********************!*\
  !*** ./appwrite.js ***!
  \*********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   COLLECTION_PURCHASES: function() { return /* binding */ COLLECTION_PURCHASES; },\n/* harmony export */   DATABASE_ID: function() { return /* binding */ DATABASE_ID; },\n/* harmony export */   ID: function() { return /* reexport safe */ appwrite__WEBPACK_IMPORTED_MODULE_0__.ID; },\n/* harmony export */   account: function() { return /* binding */ account; },\n/* harmony export */   client: function() { return /* binding */ client; },\n/* harmony export */   databases: function() { return /* binding */ databases; },\n/* harmony export */   storage: function() { return /* binding */ storage; }\n/* harmony export */ });\n/* harmony import */ var appwrite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! appwrite */ \"(app-pages-browser)/./node_modules/appwrite/dist/esm/sdk.js\");\n\nconst client = new appwrite__WEBPACK_IMPORTED_MODULE_0__.Client().setEndpoint(\"https://cloud.appwrite.io/v1\").setProject(\"665ee8cf002301f949ac\");\nconst account = new appwrite__WEBPACK_IMPORTED_MODULE_0__.Account(client);\nconst databases = new appwrite__WEBPACK_IMPORTED_MODULE_0__.Databases(client);\nconst storage = new appwrite__WEBPACK_IMPORTED_MODULE_0__.Storage(client);\nconst DATABASE_ID = \"66655893003896c51ade\";\nconst COLLECTION_PURCHASES = \"666558a90025d1d5e7d4\";\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcHdyaXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQW1FO0FBRTVELE1BQU1LLFNBQVMsSUFBSUosNENBQU1BLEdBQzdCSyxXQUFXLENBQUMsZ0NBQ1pDLFVBQVUsQ0FBQyx3QkFBd0I7QUFFL0IsTUFBTUMsVUFBVSxJQUFJUiw2Q0FBT0EsQ0FBQ0ssUUFBUTtBQUNwQyxNQUFNSSxZQUFZLElBQUlQLCtDQUFTQSxDQUFDRyxRQUFRO0FBQ3hDLE1BQU1LLFVBQVUsSUFBSU4sNkNBQU9BLENBQUNDLFFBQVE7QUFFcEMsTUFBTU0sY0FBYyx1QkFBdUI7QUFDM0MsTUFBTUMsdUJBQXVCLHVCQUF1QjtBQUU3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHB3cml0ZS5qcz9jMTYyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFjY291bnQsIENsaWVudCwgRGF0YWJhc2VzLCBJRCwgU3RvcmFnZSB9IGZyb20gJ2FwcHdyaXRlJztcblxuZXhwb3J0IGNvbnN0IGNsaWVudCA9IG5ldyBDbGllbnQoKVxuICAuc2V0RW5kcG9pbnQoJ2h0dHBzOi8vY2xvdWQuYXBwd3JpdGUuaW8vdjEnKSBcbiAgLnNldFByb2plY3QoJzY2NWVlOGNmMDAyMzAxZjk0OWFjJyk7IFxuXG5leHBvcnQgY29uc3QgYWNjb3VudCA9IG5ldyBBY2NvdW50KGNsaWVudCk7XG5leHBvcnQgY29uc3QgZGF0YWJhc2VzID0gbmV3IERhdGFiYXNlcyhjbGllbnQpO1xuZXhwb3J0IGNvbnN0IHN0b3JhZ2UgPSBuZXcgU3RvcmFnZShjbGllbnQpO1xuXG5leHBvcnQgY29uc3QgREFUQUJBU0VfSUQgPSAnNjY2NTU4OTMwMDM4OTZjNTFhZGUnOyBcbmV4cG9ydCBjb25zdCBDT0xMRUNUSU9OX1BVUkNIQVNFUyA9ICc2NjY1NThhOTAwMjVkMWQ1ZTdkNCc7IFxuXG5leHBvcnQgeyBJRCB9O1xuIl0sIm5hbWVzIjpbIkFjY291bnQiLCJDbGllbnQiLCJEYXRhYmFzZXMiLCJJRCIsIlN0b3JhZ2UiLCJjbGllbnQiLCJzZXRFbmRwb2ludCIsInNldFByb2plY3QiLCJhY2NvdW50IiwiZGF0YWJhc2VzIiwic3RvcmFnZSIsIkRBVEFCQVNFX0lEIiwiQ09MTEVDVElPTl9QVVJDSEFTRVMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./appwrite.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.js\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"inter\"}":
/*!********************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"app\\layout.js","import":"Inter","arguments":[{"subsets":["latin"]}],"variableName":"inter"} ***!
  \********************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__Inter_aaf875', '__Inter_Fallback_aaf875'\",\"fontStyle\":\"normal\"},\"className\":\"__className_aaf875\"};\n    if(true) {\n      // 1717923454873\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwiYXBwXFxcXGxheW91dC5qc1wiLFwiaW1wb3J0XCI6XCJJbnRlclwiLFwiYXJndW1lbnRzXCI6W3tcInN1YnNldHNcIjpbXCJsYXRpblwiXX1dLFwidmFyaWFibGVOYW1lXCI6XCJpbnRlclwifSIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtCQUFrQixTQUFTLGdGQUFnRjtBQUMzRyxPQUFPLElBQVU7QUFDakI7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyx3TUFBOEosY0FBYyxzREFBc0Q7QUFDaFEsTUFBTSxVQUFVO0FBQ2hCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9mb250L2dvb2dsZS90YXJnZXQuY3NzP2VjNjMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcInN0eWxlXCI6e1wiZm9udEZhbWlseVwiOlwiJ19fSW50ZXJfYWFmODc1JywgJ19fSW50ZXJfRmFsbGJhY2tfYWFmODc1J1wiLFwiZm9udFN0eWxlXCI6XCJub3JtYWxcIn0sXCJjbGFzc05hbWVcIjpcIl9fY2xhc3NOYW1lX2FhZjg3NVwifTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNzE3OTIzNDU0ODczXG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIkM6L1VzZXJzL1NJVFJJWC9PbmVEcml2ZS/QoNCw0LHQvtGH0LjQuSDRgdGC0L7Quy9uZXRhdnRvL9Cd0L7QstCw0Y8g0L/QsNC/0LrQsCAoMikvc3BvcnRfY2x1Yi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.js\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"inter\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz84NTJhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/NjNkYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/appwrite/dist/esm/sdk.js":
/*!***********************************************!*\
  !*** ./node_modules/appwrite/dist/esm/sdk.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: function() { return /* binding */ Account; },\n/* harmony export */   AppwriteException: function() { return /* binding */ AppwriteException; },\n/* harmony export */   AuthenticationFactor: function() { return /* binding */ AuthenticationFactor; },\n/* harmony export */   AuthenticatorType: function() { return /* binding */ AuthenticatorType; },\n/* harmony export */   Avatars: function() { return /* binding */ Avatars; },\n/* harmony export */   Browser: function() { return /* binding */ Browser; },\n/* harmony export */   Client: function() { return /* binding */ Client; },\n/* harmony export */   CreditCard: function() { return /* binding */ CreditCard; },\n/* harmony export */   Databases: function() { return /* binding */ Databases; },\n/* harmony export */   ExecutionMethod: function() { return /* binding */ ExecutionMethod; },\n/* harmony export */   Flag: function() { return /* binding */ Flag; },\n/* harmony export */   Functions: function() { return /* binding */ Functions; },\n/* harmony export */   Graphql: function() { return /* binding */ Graphql; },\n/* harmony export */   ID: function() { return /* binding */ ID; },\n/* harmony export */   ImageFormat: function() { return /* binding */ ImageFormat; },\n/* harmony export */   ImageGravity: function() { return /* binding */ ImageGravity; },\n/* harmony export */   Locale: function() { return /* binding */ Locale; },\n/* harmony export */   Messaging: function() { return /* binding */ Messaging; },\n/* harmony export */   OAuthProvider: function() { return /* binding */ OAuthProvider; },\n/* harmony export */   Permission: function() { return /* binding */ Permission; },\n/* harmony export */   Query: function() { return /* binding */ Query; },\n/* harmony export */   Role: function() { return /* binding */ Role; },\n/* harmony export */   Storage: function() { return /* binding */ Storage; },\n/* harmony export */   Teams: function() { return /* binding */ Teams; }\n/* harmony export */ });\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\n\nclass Service {\n    constructor(client) {\n        this.client = client;\n    }\n    static flatten(data, prefix = '') {\n        let output = {};\n        for (const [key, value] of Object.entries(data)) {\n            let finalKey = prefix ? prefix + '[' + key + ']' : key;\n            if (Array.isArray(value)) {\n                output = Object.assign(Object.assign({}, output), Service.flatten(value, finalKey));\n            }\n            else {\n                output[finalKey] = value;\n            }\n        }\n        return output;\n    }\n}\nService.CHUNK_SIZE = 5 * 1024 * 1024; // 5MB\n\nclass Query {\n    constructor(method, attribute, values) {\n        this.method = method;\n        this.attribute = attribute;\n        if (values !== undefined) {\n            if (Array.isArray(values)) {\n                this.values = values;\n            }\n            else {\n                this.values = [values];\n            }\n        }\n    }\n    toString() {\n        return JSON.stringify({\n            method: this.method,\n            attribute: this.attribute,\n            values: this.values,\n        });\n    }\n}\nQuery.equal = (attribute, value) => new Query(\"equal\", attribute, value).toString();\nQuery.notEqual = (attribute, value) => new Query(\"notEqual\", attribute, value).toString();\nQuery.lessThan = (attribute, value) => new Query(\"lessThan\", attribute, value).toString();\nQuery.lessThanEqual = (attribute, value) => new Query(\"lessThanEqual\", attribute, value).toString();\nQuery.greaterThan = (attribute, value) => new Query(\"greaterThan\", attribute, value).toString();\nQuery.greaterThanEqual = (attribute, value) => new Query(\"greaterThanEqual\", attribute, value).toString();\nQuery.isNull = (attribute) => new Query(\"isNull\", attribute).toString();\nQuery.isNotNull = (attribute) => new Query(\"isNotNull\", attribute).toString();\nQuery.between = (attribute, start, end) => new Query(\"between\", attribute, [start, end]).toString();\nQuery.startsWith = (attribute, value) => new Query(\"startsWith\", attribute, value).toString();\nQuery.endsWith = (attribute, value) => new Query(\"endsWith\", attribute, value).toString();\nQuery.select = (attributes) => new Query(\"select\", undefined, attributes).toString();\nQuery.search = (attribute, value) => new Query(\"search\", attribute, value).toString();\nQuery.orderDesc = (attribute) => new Query(\"orderDesc\", attribute).toString();\nQuery.orderAsc = (attribute) => new Query(\"orderAsc\", attribute).toString();\nQuery.cursorAfter = (documentId) => new Query(\"cursorAfter\", undefined, documentId).toString();\nQuery.cursorBefore = (documentId) => new Query(\"cursorBefore\", undefined, documentId).toString();\nQuery.limit = (limit) => new Query(\"limit\", undefined, limit).toString();\nQuery.offset = (offset) => new Query(\"offset\", undefined, offset).toString();\nQuery.contains = (attribute, value) => new Query(\"contains\", attribute, value).toString();\nQuery.or = (queries) => new Query(\"or\", undefined, queries.map((query) => JSON.parse(query))).toString();\nQuery.and = (queries) => new Query(\"and\", undefined, queries.map((query) => JSON.parse(query))).toString();\n\nclass AppwriteException extends Error {\n    constructor(message, code = 0, type = '', response = '') {\n        super(message);\n        this.name = 'AppwriteException';\n        this.message = message;\n        this.code = code;\n        this.type = type;\n        this.response = response;\n    }\n}\nclass Client {\n    constructor() {\n        this.config = {\n            endpoint: 'https://cloud.appwrite.io/v1',\n            endpointRealtime: '',\n            project: '',\n            jwt: '',\n            locale: '',\n            session: '',\n        };\n        this.headers = {\n            'x-sdk-name': 'Web',\n            'x-sdk-platform': 'client',\n            'x-sdk-language': 'web',\n            'x-sdk-version': '15.0.0',\n            'X-Appwrite-Response-Format': '1.5.0',\n        };\n        this.realtime = {\n            socket: undefined,\n            timeout: undefined,\n            url: '',\n            channels: new Set(),\n            subscriptions: new Map(),\n            subscriptionsCounter: 0,\n            reconnect: true,\n            reconnectAttempts: 0,\n            lastMessage: undefined,\n            connect: () => {\n                clearTimeout(this.realtime.timeout);\n                this.realtime.timeout = window === null || window === void 0 ? void 0 : window.setTimeout(() => {\n                    this.realtime.createSocket();\n                }, 50);\n            },\n            getTimeout: () => {\n                switch (true) {\n                    case this.realtime.reconnectAttempts < 5:\n                        return 1000;\n                    case this.realtime.reconnectAttempts < 15:\n                        return 5000;\n                    case this.realtime.reconnectAttempts < 100:\n                        return 10000;\n                    default:\n                        return 60000;\n                }\n            },\n            createSocket: () => {\n                var _a, _b, _c;\n                if (this.realtime.channels.size < 1) {\n                    this.realtime.reconnect = false;\n                    (_a = this.realtime.socket) === null || _a === void 0 ? void 0 : _a.close();\n                    return;\n                }\n                const channels = new URLSearchParams();\n                channels.set('project', this.config.project);\n                this.realtime.channels.forEach(channel => {\n                    channels.append('channels[]', channel);\n                });\n                const url = this.config.endpointRealtime + '/realtime?' + channels.toString();\n                if (url !== this.realtime.url || // Check if URL is present\n                    !this.realtime.socket || // Check if WebSocket has not been created\n                    ((_b = this.realtime.socket) === null || _b === void 0 ? void 0 : _b.readyState) > WebSocket.OPEN // Check if WebSocket is CLOSING (3) or CLOSED (4)\n                ) {\n                    if (this.realtime.socket &&\n                        ((_c = this.realtime.socket) === null || _c === void 0 ? void 0 : _c.readyState) < WebSocket.CLOSING // Close WebSocket if it is CONNECTING (0) or OPEN (1)\n                    ) {\n                        this.realtime.reconnect = false;\n                        this.realtime.socket.close();\n                    }\n                    this.realtime.url = url;\n                    this.realtime.socket = new WebSocket(url);\n                    this.realtime.socket.addEventListener('message', this.realtime.onMessage);\n                    this.realtime.socket.addEventListener('open', _event => {\n                        this.realtime.reconnectAttempts = 0;\n                    });\n                    this.realtime.socket.addEventListener('close', event => {\n                        var _a, _b, _c;\n                        if (!this.realtime.reconnect ||\n                            (((_b = (_a = this.realtime) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.type) === 'error' && // Check if last message was of type error\n                                ((_c = this.realtime) === null || _c === void 0 ? void 0 : _c.lastMessage.data).code === 1008 // Check for policy violation 1008\n                            )) {\n                            this.realtime.reconnect = true;\n                            return;\n                        }\n                        const timeout = this.realtime.getTimeout();\n                        console.error(`Realtime got disconnected. Reconnect will be attempted in ${timeout / 1000} seconds.`, event.reason);\n                        setTimeout(() => {\n                            this.realtime.reconnectAttempts++;\n                            this.realtime.createSocket();\n                        }, timeout);\n                    });\n                }\n            },\n            onMessage: (event) => {\n                var _a, _b;\n                try {\n                    const message = JSON.parse(event.data);\n                    this.realtime.lastMessage = message;\n                    switch (message.type) {\n                        case 'connected':\n                            const cookie = JSON.parse((_a = window.localStorage.getItem('cookieFallback')) !== null && _a !== void 0 ? _a : '{}');\n                            const session = cookie === null || cookie === void 0 ? void 0 : cookie[`a_session_${this.config.project}`];\n                            const messageData = message.data;\n                            if (session && !messageData.user) {\n                                (_b = this.realtime.socket) === null || _b === void 0 ? void 0 : _b.send(JSON.stringify({\n                                    type: 'authentication',\n                                    data: {\n                                        session\n                                    }\n                                }));\n                            }\n                            break;\n                        case 'event':\n                            let data = message.data;\n                            if (data === null || data === void 0 ? void 0 : data.channels) {\n                                const isSubscribed = data.channels.some(channel => this.realtime.channels.has(channel));\n                                if (!isSubscribed)\n                                    return;\n                                this.realtime.subscriptions.forEach(subscription => {\n                                    if (data.channels.some(channel => subscription.channels.includes(channel))) {\n                                        setTimeout(() => subscription.callback(data));\n                                    }\n                                });\n                            }\n                            break;\n                        case 'error':\n                            throw message.data;\n                        default:\n                            break;\n                    }\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            },\n            cleanUp: channels => {\n                this.realtime.channels.forEach(channel => {\n                    if (channels.includes(channel)) {\n                        let found = Array.from(this.realtime.subscriptions).some(([_key, subscription]) => {\n                            return subscription.channels.includes(channel);\n                        });\n                        if (!found) {\n                            this.realtime.channels.delete(channel);\n                        }\n                    }\n                });\n            }\n        };\n    }\n    /**\n     * Set Endpoint\n     *\n     * Your project endpoint\n     *\n     * @param {string} endpoint\n     *\n     * @returns {this}\n     */\n    setEndpoint(endpoint) {\n        this.config.endpoint = endpoint;\n        this.config.endpointRealtime = this.config.endpointRealtime || this.config.endpoint.replace('https://', 'wss://').replace('http://', 'ws://');\n        return this;\n    }\n    /**\n     * Set Realtime Endpoint\n     *\n     * @param {string} endpointRealtime\n     *\n     * @returns {this}\n     */\n    setEndpointRealtime(endpointRealtime) {\n        this.config.endpointRealtime = endpointRealtime;\n        return this;\n    }\n    /**\n     * Set Project\n     *\n     * Your project ID\n     *\n     * @param value string\n     *\n     * @return {this}\n     */\n    setProject(value) {\n        this.headers['X-Appwrite-Project'] = value;\n        this.config.project = value;\n        return this;\n    }\n    /**\n     * Set JWT\n     *\n     * Your secret JSON Web Token\n     *\n     * @param value string\n     *\n     * @return {this}\n     */\n    setJWT(value) {\n        this.headers['X-Appwrite-JWT'] = value;\n        this.config.jwt = value;\n        return this;\n    }\n    /**\n     * Set Locale\n     *\n     * @param value string\n     *\n     * @return {this}\n     */\n    setLocale(value) {\n        this.headers['X-Appwrite-Locale'] = value;\n        this.config.locale = value;\n        return this;\n    }\n    /**\n     * Set Session\n     *\n     * The user session to authenticate with\n     *\n     * @param value string\n     *\n     * @return {this}\n     */\n    setSession(value) {\n        this.headers['X-Appwrite-Session'] = value;\n        this.config.session = value;\n        return this;\n    }\n    /**\n     * Subscribes to Appwrite events and passes you the payload in realtime.\n     *\n     * @param {string|string[]} channels\n     * Channel to subscribe - pass a single channel as a string or multiple with an array of strings.\n     *\n     * Possible channels are:\n     * - account\n     * - collections\n     * - collections.[ID]\n     * - collections.[ID].documents\n     * - documents\n     * - documents.[ID]\n     * - files\n     * - files.[ID]\n     * - executions\n     * - executions.[ID]\n     * - functions.[ID]\n     * - teams\n     * - teams.[ID]\n     * - memberships\n     * - memberships.[ID]\n     * @param {(payload: RealtimeMessage) => void} callback Is called on every realtime update.\n     * @returns {() => void} Unsubscribes from events.\n     */\n    subscribe(channels, callback) {\n        let channelArray = typeof channels === 'string' ? [channels] : channels;\n        channelArray.forEach(channel => this.realtime.channels.add(channel));\n        const counter = this.realtime.subscriptionsCounter++;\n        this.realtime.subscriptions.set(counter, {\n            channels: channelArray,\n            callback\n        });\n        this.realtime.connect();\n        return () => {\n            this.realtime.subscriptions.delete(counter);\n            this.realtime.cleanUp(channelArray);\n            this.realtime.connect();\n        };\n    }\n    call(method, url, headers = {}, params = {}) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            method = method.toUpperCase();\n            headers = Object.assign({}, this.headers, headers);\n            let options = {\n                method,\n                headers,\n                credentials: 'include'\n            };\n            if (typeof window !== 'undefined' && window.localStorage) {\n                const cookieFallback = window.localStorage.getItem('cookieFallback');\n                if (cookieFallback) {\n                    headers['X-Fallback-Cookies'] = cookieFallback;\n                }\n            }\n            if (method === 'GET') {\n                for (const [key, value] of Object.entries(Service.flatten(params))) {\n                    url.searchParams.append(key, value);\n                }\n            }\n            else {\n                switch (headers['content-type']) {\n                    case 'application/json':\n                        options.body = JSON.stringify(params);\n                        break;\n                    case 'multipart/form-data':\n                        let formData = new FormData();\n                        for (const key in params) {\n                            if (Array.isArray(params[key])) {\n                                params[key].forEach((value) => {\n                                    formData.append(key + '[]', value);\n                                });\n                            }\n                            else {\n                                formData.append(key, params[key]);\n                            }\n                        }\n                        options.body = formData;\n                        delete headers['content-type'];\n                        break;\n                }\n            }\n            try {\n                let data = null;\n                const response = yield fetch(url.toString(), options);\n                if ((_a = response.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('application/json')) {\n                    data = yield response.json();\n                }\n                else {\n                    data = {\n                        message: yield response.text()\n                    };\n                }\n                if (400 <= response.status) {\n                    throw new AppwriteException(data === null || data === void 0 ? void 0 : data.message, response.status, data === null || data === void 0 ? void 0 : data.type, data);\n                }\n                const cookieFallback = response.headers.get('X-Fallback-Cookies');\n                if (typeof window !== 'undefined' && window.localStorage && cookieFallback) {\n                    window.console.warn('Appwrite is using localStorage for session management. Increase your security by adding a custom domain as your API endpoint.');\n                    window.localStorage.setItem('cookieFallback', cookieFallback);\n                }\n                return data;\n            }\n            catch (e) {\n                if (e instanceof AppwriteException) {\n                    throw e;\n                }\n                throw new AppwriteException(e.message);\n            }\n        });\n    }\n}\n\nclass Account extends Service {\n    constructor(client) {\n        super(client);\n    }\n    /**\n     * Get account\n     *\n     * Get the currently logged in user.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    get() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/account';\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create account\n     *\n     * Use this endpoint to allow a new user to register a new account in your\n     * project. After the user registration completes successfully, you can use\n     * the\n     * [/account/verfication](https://appwrite.io/docs/references/cloud/client-web/account#createVerification)\n     * route to start verifying the user email address. To allow the new user to\n     * login to their new account, you need to create a new [account\n     * session](https://appwrite.io/docs/references/cloud/client-web/account#createEmailSession).\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    create(userId, email, password, name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof userId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"userId\"');\n            }\n            if (typeof email === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"email\"');\n            }\n            if (typeof password === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"password\"');\n            }\n            const apiPath = '/account';\n            const payload = {};\n            if (typeof userId !== 'undefined') {\n                payload['userId'] = userId;\n            }\n            if (typeof email !== 'undefined') {\n                payload['email'] = email;\n            }\n            if (typeof password !== 'undefined') {\n                payload['password'] = password;\n            }\n            if (typeof name !== 'undefined') {\n                payload['name'] = name;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('post', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Update email\n     *\n     * Update currently logged in user account email address. After changing user\n     * address, the user confirmation status will get reset. A new confirmation\n     * email is not sent automatically however you can use the send confirmation\n     * email endpoint again to send the confirmation email. For security measures,\n     * user password is required to complete this request.\n     * This endpoint can also be used to convert an anonymous account to a normal\n     * one, by passing an email address and a new password.\n     *\n     *\n     * @param {string} email\n     * @param {string} password\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updateEmail(email, password) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof email === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"email\"');\n            }\n            if (typeof password === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"password\"');\n            }\n            const apiPath = '/account/email';\n            const payload = {};\n            if (typeof email !== 'undefined') {\n                payload['email'] = email;\n            }\n            if (typeof password !== 'undefined') {\n                payload['password'] = password;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('patch', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * List Identities\n     *\n     * Get the list of identities for the currently logged in user.\n     *\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    listIdentities(queries) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/account/identities';\n            const payload = {};\n            if (typeof queries !== 'undefined') {\n                payload['queries'] = queries;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Delete identity\n     *\n     * Delete an identity by its unique ID.\n     *\n     * @param {string} identityId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    deleteIdentity(identityId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof identityId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"identityId\"');\n            }\n            const apiPath = '/account/identities/{identityId}'.replace('{identityId}', identityId);\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('delete', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create JWT\n     *\n     * Use this endpoint to create a JSON Web Token. You can use the resulting JWT\n     * to authenticate on behalf of the current user when working with the\n     * Appwrite server-side API and SDKs. The JWT secret is valid for 15 minutes\n     * from its creation and will be invalid if the user will logout in that time\n     * frame.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    createJWT() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/account/jwt';\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('post', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * List logs\n     *\n     * Get the list of latest security activity logs for the currently logged in\n     * user. Each log returns user IP address, location and date and time of log.\n     *\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    listLogs(queries) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/account/logs';\n            const payload = {};\n            if (typeof queries !== 'undefined') {\n                payload['queries'] = queries;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Update MFA\n     *\n     * Enable or disable MFA on an account.\n     *\n     * @param {boolean} mfa\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updateMFA(mfa) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof mfa === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"mfa\"');\n            }\n            const apiPath = '/account/mfa';\n            const payload = {};\n            if (typeof mfa !== 'undefined') {\n                payload['mfa'] = mfa;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('patch', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Add Authenticator\n     *\n     * Add an authenticator app to be used as an MFA factor. Verify the\n     * authenticator using the [verify\n     * authenticator](/docs/references/cloud/client-web/account#updateMfaAuthenticator)\n     * method.\n     *\n     * @param {AuthenticatorType} type\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    createMfaAuthenticator(type) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof type === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"type\"');\n            }\n            const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('post', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Verify Authenticator\n     *\n     * Verify an authenticator app after adding it using the [add\n     * authenticator](/docs/references/cloud/client-web/account#createMfaAuthenticator)\n     * method. add\n     *\n     * @param {AuthenticatorType} type\n     * @param {string} otp\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updateMfaAuthenticator(type, otp) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof type === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"type\"');\n            }\n            if (typeof otp === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"otp\"');\n            }\n            const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n            const payload = {};\n            if (typeof otp !== 'undefined') {\n                payload['otp'] = otp;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('put', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Delete Authenticator\n     *\n     * Delete an authenticator for a user by ID.\n     *\n     * @param {AuthenticatorType} type\n     * @param {string} otp\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    deleteMfaAuthenticator(type, otp) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof type === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"type\"');\n            }\n            if (typeof otp === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"otp\"');\n            }\n            const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n            const payload = {};\n            if (typeof otp !== 'undefined') {\n                payload['otp'] = otp;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('delete', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create 2FA Challenge\n     *\n     * Begin the process of MFA verification after sign-in. Finish the flow with\n     * [updateMfaChallenge](/docs/references/cloud/client-web/account#updateMfaChallenge)\n     * method.\n     *\n     * @param {AuthenticationFactor} factor\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    createMfaChallenge(factor) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof factor === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"factor\"');\n            }\n            const apiPath = '/account/mfa/challenge';\n            const payload = {};\n            if (typeof factor !== 'undefined') {\n                payload['factor'] = factor;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('post', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create MFA Challenge (confirmation)\n     *\n     * Complete the MFA challenge by providing the one-time password. Finish the\n     * process of MFA verification by providing the one-time password. To begin\n     * the flow, use\n     * [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge)\n     * method.\n     *\n     * @param {string} challengeId\n     * @param {string} otp\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updateMfaChallenge(challengeId, otp) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof challengeId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"challengeId\"');\n            }\n            if (typeof otp === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"otp\"');\n            }\n            const apiPath = '/account/mfa/challenge';\n            const payload = {};\n            if (typeof challengeId !== 'undefined') {\n                payload['challengeId'] = challengeId;\n            }\n            if (typeof otp !== 'undefined') {\n                payload['otp'] = otp;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('put', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * List Factors\n     *\n     * List the factors available on the account to be used as a MFA challange.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    listMfaFactors() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/account/mfa/factors';\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Get MFA Recovery Codes\n     *\n     * Get recovery codes that can be used as backup for MFA flow. Before getting\n     * codes, they must be generated using\n     * [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes)\n     * method. An OTP challenge is required to read recovery codes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    getMfaRecoveryCodes() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/account/mfa/recovery-codes';\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create MFA Recovery Codes\n     *\n     * Generate recovery codes as backup for MFA flow. It's recommended to\n     * generate and show then immediately after user successfully adds their\n     * authehticator. Recovery codes can be used as a MFA verification type in\n     * [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge)\n     * method.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    createMfaRecoveryCodes() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/account/mfa/recovery-codes';\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('post', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Regenerate MFA Recovery Codes\n     *\n     * Regenerate recovery codes that can be used as backup for MFA flow. Before\n     * regenerating codes, they must be first generated using\n     * [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes)\n     * method. An OTP challenge is required to regenreate recovery codes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updateMfaRecoveryCodes() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/account/mfa/recovery-codes';\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('patch', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Update name\n     *\n     * Update currently logged in user account name.\n     *\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updateName(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof name === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"name\"');\n            }\n            const apiPath = '/account/name';\n            const payload = {};\n            if (typeof name !== 'undefined') {\n                payload['name'] = name;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('patch', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Update password\n     *\n     * Update currently logged in user password. For validation, user is required\n     * to pass in the new password, and the old password. For users created with\n     * OAuth, Team Invites and Magic URL, oldPassword is optional.\n     *\n     * @param {string} password\n     * @param {string} oldPassword\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updatePassword(password, oldPassword) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof password === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"password\"');\n            }\n            const apiPath = '/account/password';\n            const payload = {};\n            if (typeof password !== 'undefined') {\n                payload['password'] = password;\n            }\n            if (typeof oldPassword !== 'undefined') {\n                payload['oldPassword'] = oldPassword;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('patch', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Update phone\n     *\n     * Update the currently logged in user's phone number. After updating the\n     * phone number, the phone verification status will be reset. A confirmation\n     * SMS is not sent automatically, however you can use the [POST\n     * /account/verification/phone](https://appwrite.io/docs/references/cloud/client-web/account#createPhoneVerification)\n     * endpoint to send a confirmation SMS.\n     *\n     * @param {string} phone\n     * @param {string} password\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updatePhone(phone, password) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof phone === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"phone\"');\n            }\n            if (typeof password === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"password\"');\n            }\n            const apiPath = '/account/phone';\n            const payload = {};\n            if (typeof phone !== 'undefined') {\n                payload['phone'] = phone;\n            }\n            if (typeof password !== 'undefined') {\n                payload['password'] = password;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('patch', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Get account preferences\n     *\n     * Get the preferences as a key-value object for the currently logged in user.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    getPrefs() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/account/prefs';\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Update preferences\n     *\n     * Update currently logged in user account preferences. The object you pass is\n     * stored as is, and replaces any previous value. The maximum allowed prefs\n     * size is 64kB and throws error if exceeded.\n     *\n     * @param {Partial<Preferences>} prefs\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updatePrefs(prefs) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof prefs === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"prefs\"');\n            }\n            const apiPath = '/account/prefs';\n            const payload = {};\n            if (typeof prefs !== 'undefined') {\n                payload['prefs'] = prefs;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('patch', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create password recovery\n     *\n     * Sends the user an email with a temporary secret key for password reset.\n     * When the user clicks the confirmation link he is redirected back to your\n     * app password reset URL with the secret key and email address values\n     * attached to the URL query string. Use the query string params to submit a\n     * request to the [PUT\n     * /account/recovery](https://appwrite.io/docs/references/cloud/client-web/account#updateRecovery)\n     * endpoint to complete the process. The verification link sent to the user's\n     * email address is valid for 1 hour.\n     *\n     * @param {string} email\n     * @param {string} url\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    createRecovery(email, url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof email === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"email\"');\n            }\n            if (typeof url === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"url\"');\n            }\n            const apiPath = '/account/recovery';\n            const payload = {};\n            if (typeof email !== 'undefined') {\n                payload['email'] = email;\n            }\n            if (typeof url !== 'undefined') {\n                payload['url'] = url;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('post', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create password recovery (confirmation)\n     *\n     * Use this endpoint to complete the user account password reset. Both the\n     * **userId** and **secret** arguments will be passed as query parameters to\n     * the redirect URL you have provided when sending your request to the [POST\n     * /account/recovery](https://appwrite.io/docs/references/cloud/client-web/account#createRecovery)\n     * endpoint.\n     *\n     * Please note that in order to avoid a [Redirect\n     * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md)\n     * the only valid redirect URLs are the ones from domains you have set when\n     * adding your platforms in the console interface.\n     *\n     * @param {string} userId\n     * @param {string} secret\n     * @param {string} password\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updateRecovery(userId, secret, password) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof userId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"userId\"');\n            }\n            if (typeof secret === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"secret\"');\n            }\n            if (typeof password === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"password\"');\n            }\n            const apiPath = '/account/recovery';\n            const payload = {};\n            if (typeof userId !== 'undefined') {\n                payload['userId'] = userId;\n            }\n            if (typeof secret !== 'undefined') {\n                payload['secret'] = secret;\n            }\n            if (typeof password !== 'undefined') {\n                payload['password'] = password;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('put', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * List sessions\n     *\n     * Get the list of active sessions across different devices for the currently\n     * logged in user.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    listSessions() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/account/sessions';\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Delete sessions\n     *\n     * Delete all sessions from the user account and remove any sessions cookies\n     * from the end client.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    deleteSessions() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/account/sessions';\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('delete', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create anonymous session\n     *\n     * Use this endpoint to allow a new user to register an anonymous account in\n     * your project. This route will also create a new session for the user. To\n     * allow the new user to convert an anonymous account to a normal account, you\n     * need to update its [email and\n     * password](https://appwrite.io/docs/references/cloud/client-web/account#updateEmail)\n     * or create an [OAuth2\n     * session](https://appwrite.io/docs/references/cloud/client-web/account#CreateOAuth2Session).\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    createAnonymousSession() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/account/sessions/anonymous';\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('post', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create email password session\n     *\n     * Allow the user to login into their account by providing a valid email and\n     * password combination. This route will create a new session for the user.\n     *\n     * A user is limited to 10 active sessions at a time by default. [Learn more\n     * about session\n     * limits](https://appwrite.io/docs/authentication-security#limits).\n     *\n     * @param {string} email\n     * @param {string} password\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    createEmailPasswordSession(email, password) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof email === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"email\"');\n            }\n            if (typeof password === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"password\"');\n            }\n            const apiPath = '/account/sessions/email';\n            const payload = {};\n            if (typeof email !== 'undefined') {\n                payload['email'] = email;\n            }\n            if (typeof password !== 'undefined') {\n                payload['password'] = password;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('post', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Update magic URL session\n     *\n     * Use this endpoint to create a session from token. Provide the **userId**\n     * and **secret** parameters from the successful response of authentication\n     * flows initiated by token creation. For example, magic URL and phone login.\n     *\n     * @param {string} userId\n     * @param {string} secret\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updateMagicURLSession(userId, secret) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof userId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"userId\"');\n            }\n            if (typeof secret === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"secret\"');\n            }\n            const apiPath = '/account/sessions/magic-url';\n            const payload = {};\n            if (typeof userId !== 'undefined') {\n                payload['userId'] = userId;\n            }\n            if (typeof secret !== 'undefined') {\n                payload['secret'] = secret;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('put', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create OAuth2 session\n     *\n     * Allow the user to login to their account using the OAuth2 provider of their\n     * choice. Each OAuth2 provider should be enabled from the Appwrite console\n     * first. Use the success and failure arguments to provide a redirect URL's\n     * back to your app when login is completed.\n     *\n     * If there is already an active session, the new session will be attached to\n     * the logged-in account. If there are no active sessions, the server will\n     * attempt to look for a user with the same email address as the email\n     * received from the OAuth2 provider and attach the new session to the\n     * existing user. If no matching user is found - the server will create a new\n     * user.\n     *\n     * A user is limited to 10 active sessions at a time by default. [Learn more\n     * about session\n     * limits](https://appwrite.io/docs/authentication-security#limits).\n     *\n     *\n     * @param {OAuthProvider} provider\n     * @param {string} success\n     * @param {string} failure\n     * @param {string[]} scopes\n     * @throws {AppwriteException}\n     * @returns {void|string}\n    */\n    createOAuth2Session(provider, success, failure, scopes) {\n        if (typeof provider === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"provider\"');\n        }\n        const apiPath = '/account/sessions/oauth2/{provider}'.replace('{provider}', provider);\n        const payload = {};\n        if (typeof success !== 'undefined') {\n            payload['success'] = success;\n        }\n        if (typeof failure !== 'undefined') {\n            payload['failure'] = failure;\n        }\n        if (typeof scopes !== 'undefined') {\n            payload['scopes'] = scopes;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        if (typeof window !== 'undefined' && (window === null || window === void 0 ? void 0 : window.location)) {\n            window.location.href = uri.toString();\n        }\n        else {\n            return uri;\n        }\n    }\n    /**\n     * Update phone session\n     *\n     * Use this endpoint to create a session from token. Provide the **userId**\n     * and **secret** parameters from the successful response of authentication\n     * flows initiated by token creation. For example, magic URL and phone login.\n     *\n     * @param {string} userId\n     * @param {string} secret\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updatePhoneSession(userId, secret) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof userId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"userId\"');\n            }\n            if (typeof secret === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"secret\"');\n            }\n            const apiPath = '/account/sessions/phone';\n            const payload = {};\n            if (typeof userId !== 'undefined') {\n                payload['userId'] = userId;\n            }\n            if (typeof secret !== 'undefined') {\n                payload['secret'] = secret;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('put', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create session\n     *\n     * Use this endpoint to create a session from token. Provide the **userId**\n     * and **secret** parameters from the successful response of authentication\n     * flows initiated by token creation. For example, magic URL and phone login.\n     *\n     * @param {string} userId\n     * @param {string} secret\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    createSession(userId, secret) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof userId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"userId\"');\n            }\n            if (typeof secret === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"secret\"');\n            }\n            const apiPath = '/account/sessions/token';\n            const payload = {};\n            if (typeof userId !== 'undefined') {\n                payload['userId'] = userId;\n            }\n            if (typeof secret !== 'undefined') {\n                payload['secret'] = secret;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('post', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Get session\n     *\n     * Use this endpoint to get a logged in user's session using a Session ID.\n     * Inputting 'current' will return the current session being used.\n     *\n     * @param {string} sessionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    getSession(sessionId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof sessionId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"sessionId\"');\n            }\n            const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Update session\n     *\n     * Use this endpoint to extend a session's length. Extending a session is\n     * useful when session expiry is short. If the session was created using an\n     * OAuth provider, this endpoint refreshes the access token from the provider.\n     *\n     * @param {string} sessionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updateSession(sessionId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof sessionId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"sessionId\"');\n            }\n            const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('patch', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Delete session\n     *\n     * Logout the user. Use 'current' as the session ID to logout on this device,\n     * use a session ID to logout on another device. If you're looking to logout\n     * the user on all devices, use [Delete\n     * Sessions](https://appwrite.io/docs/references/cloud/client-web/account#deleteSessions)\n     * instead.\n     *\n     * @param {string} sessionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    deleteSession(sessionId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof sessionId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"sessionId\"');\n            }\n            const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('delete', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Update status\n     *\n     * Block the currently logged in user account. Behind the scene, the user\n     * record is not deleted but permanently blocked from any access. To\n     * completely delete a user, use the Users API instead.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updateStatus() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/account/status';\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('patch', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create push target\n     *\n     *\n     * @param {string} targetId\n     * @param {string} identifier\n     * @param {string} providerId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    createPushTarget(targetId, identifier, providerId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof targetId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"targetId\"');\n            }\n            if (typeof identifier === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"identifier\"');\n            }\n            const apiPath = '/account/targets/push';\n            const payload = {};\n            if (typeof targetId !== 'undefined') {\n                payload['targetId'] = targetId;\n            }\n            if (typeof identifier !== 'undefined') {\n                payload['identifier'] = identifier;\n            }\n            if (typeof providerId !== 'undefined') {\n                payload['providerId'] = providerId;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('post', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Update push target\n     *\n     *\n     * @param {string} targetId\n     * @param {string} identifier\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updatePushTarget(targetId, identifier) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof targetId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"targetId\"');\n            }\n            if (typeof identifier === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"identifier\"');\n            }\n            const apiPath = '/account/targets/{targetId}/push'.replace('{targetId}', targetId);\n            const payload = {};\n            if (typeof identifier !== 'undefined') {\n                payload['identifier'] = identifier;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('put', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Delete push target\n     *\n     *\n     * @param {string} targetId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    deletePushTarget(targetId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof targetId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"targetId\"');\n            }\n            const apiPath = '/account/targets/{targetId}/push'.replace('{targetId}', targetId);\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('delete', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create email token (OTP)\n     *\n     * Sends the user an email with a secret key for creating a session. If the\n     * provided user ID has not be registered, a new user will be created. Use the\n     * returned user ID and secret and submit a request to the [POST\n     * /v1/account/sessions/token](https://appwrite.io/docs/references/cloud/client-web/account#createSession)\n     * endpoint to complete the login process. The secret sent to the user's email\n     * is valid for 15 minutes.\n     *\n     * A user is limited to 10 active sessions at a time by default. [Learn more\n     * about session\n     * limits](https://appwrite.io/docs/authentication-security#limits).\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {boolean} phrase\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    createEmailToken(userId, email, phrase) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof userId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"userId\"');\n            }\n            if (typeof email === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"email\"');\n            }\n            const apiPath = '/account/tokens/email';\n            const payload = {};\n            if (typeof userId !== 'undefined') {\n                payload['userId'] = userId;\n            }\n            if (typeof email !== 'undefined') {\n                payload['email'] = email;\n            }\n            if (typeof phrase !== 'undefined') {\n                payload['phrase'] = phrase;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('post', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create magic URL token\n     *\n     * Sends the user an email with a secret key for creating a session. If the\n     * provided user ID has not been registered, a new user will be created. When\n     * the user clicks the link in the email, the user is redirected back to the\n     * URL you provided with the secret key and userId values attached to the URL\n     * query string. Use the query string parameters to submit a request to the\n     * [POST\n     * /v1/account/sessions/token](https://appwrite.io/docs/references/cloud/client-web/account#createSession)\n     * endpoint to complete the login process. The link sent to the user's email\n     * address is valid for 1 hour. If you are on a mobile device you can leave\n     * the URL parameter empty, so that the login completion will be handled by\n     * your Appwrite instance by default.\n     *\n     * A user is limited to 10 active sessions at a time by default. [Learn more\n     * about session\n     * limits](https://appwrite.io/docs/authentication-security#limits).\n     *\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} url\n     * @param {boolean} phrase\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    createMagicURLToken(userId, email, url, phrase) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof userId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"userId\"');\n            }\n            if (typeof email === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"email\"');\n            }\n            const apiPath = '/account/tokens/magic-url';\n            const payload = {};\n            if (typeof userId !== 'undefined') {\n                payload['userId'] = userId;\n            }\n            if (typeof email !== 'undefined') {\n                payload['email'] = email;\n            }\n            if (typeof url !== 'undefined') {\n                payload['url'] = url;\n            }\n            if (typeof phrase !== 'undefined') {\n                payload['phrase'] = phrase;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('post', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create OAuth2 token\n     *\n     * Allow the user to login to their account using the OAuth2 provider of their\n     * choice. Each OAuth2 provider should be enabled from the Appwrite console\n     * first. Use the success and failure arguments to provide a redirect URL's\n     * back to your app when login is completed.\n     *\n     * If authentication succeeds, `userId` and `secret` of a token will be\n     * appended to the success URL as query parameters. These can be used to\n     * create a new session using the [Create\n     * session](https://appwrite.io/docs/references/cloud/client-web/account#createSession)\n     * endpoint.\n     *\n     * A user is limited to 10 active sessions at a time by default. [Learn more\n     * about session\n     * limits](https://appwrite.io/docs/authentication-security#limits).\n     *\n     * @param {OAuthProvider} provider\n     * @param {string} success\n     * @param {string} failure\n     * @param {string[]} scopes\n     * @throws {AppwriteException}\n     * @returns {void|string}\n    */\n    createOAuth2Token(provider, success, failure, scopes) {\n        if (typeof provider === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"provider\"');\n        }\n        const apiPath = '/account/tokens/oauth2/{provider}'.replace('{provider}', provider);\n        const payload = {};\n        if (typeof success !== 'undefined') {\n            payload['success'] = success;\n        }\n        if (typeof failure !== 'undefined') {\n            payload['failure'] = failure;\n        }\n        if (typeof scopes !== 'undefined') {\n            payload['scopes'] = scopes;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        if (typeof window !== 'undefined' && (window === null || window === void 0 ? void 0 : window.location)) {\n            window.location.href = uri.toString();\n        }\n        else {\n            return uri;\n        }\n    }\n    /**\n     * Create phone token\n     *\n     * Sends the user an SMS with a secret key for creating a session. If the\n     * provided user ID has not be registered, a new user will be created. Use the\n     * returned user ID and secret and submit a request to the [POST\n     * /v1/account/sessions/token](https://appwrite.io/docs/references/cloud/client-web/account#createSession)\n     * endpoint to complete the login process. The secret sent to the user's phone\n     * is valid for 15 minutes.\n     *\n     * A user is limited to 10 active sessions at a time by default. [Learn more\n     * about session\n     * limits](https://appwrite.io/docs/authentication-security#limits).\n     *\n     * @param {string} userId\n     * @param {string} phone\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    createPhoneToken(userId, phone) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof userId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"userId\"');\n            }\n            if (typeof phone === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"phone\"');\n            }\n            const apiPath = '/account/tokens/phone';\n            const payload = {};\n            if (typeof userId !== 'undefined') {\n                payload['userId'] = userId;\n            }\n            if (typeof phone !== 'undefined') {\n                payload['phone'] = phone;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('post', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create email verification\n     *\n     * Use this endpoint to send a verification message to your user email address\n     * to confirm they are the valid owners of that address. Both the **userId**\n     * and **secret** arguments will be passed as query parameters to the URL you\n     * have provided to be attached to the verification email. The provided URL\n     * should redirect the user back to your app and allow you to complete the\n     * verification process by verifying both the **userId** and **secret**\n     * parameters. Learn more about how to [complete the verification\n     * process](https://appwrite.io/docs/references/cloud/client-web/account#updateVerification).\n     * The verification link sent to the user's email address is valid for 7 days.\n     *\n     * Please note that in order to avoid a [Redirect\n     * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md),\n     * the only valid redirect URLs are the ones from domains you have set when\n     * adding your platforms in the console interface.\n     *\n     *\n     * @param {string} url\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    createVerification(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof url === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"url\"');\n            }\n            const apiPath = '/account/verification';\n            const payload = {};\n            if (typeof url !== 'undefined') {\n                payload['url'] = url;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('post', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create email verification (confirmation)\n     *\n     * Use this endpoint to complete the user email verification process. Use both\n     * the **userId** and **secret** parameters that were attached to your app URL\n     * to verify the user email ownership. If confirmed this route will return a\n     * 200 status code.\n     *\n     * @param {string} userId\n     * @param {string} secret\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updateVerification(userId, secret) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof userId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"userId\"');\n            }\n            if (typeof secret === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"secret\"');\n            }\n            const apiPath = '/account/verification';\n            const payload = {};\n            if (typeof userId !== 'undefined') {\n                payload['userId'] = userId;\n            }\n            if (typeof secret !== 'undefined') {\n                payload['secret'] = secret;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('put', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create phone verification\n     *\n     * Use this endpoint to send a verification SMS to the currently logged in\n     * user. This endpoint is meant for use after updating a user's phone number\n     * using the\n     * [accountUpdatePhone](https://appwrite.io/docs/references/cloud/client-web/account#updatePhone)\n     * endpoint. Learn more about how to [complete the verification\n     * process](https://appwrite.io/docs/references/cloud/client-web/account#updatePhoneVerification).\n     * The verification code sent to the user's phone number is valid for 15\n     * minutes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    createPhoneVerification() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/account/verification/phone';\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('post', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create phone verification (confirmation)\n     *\n     * Use this endpoint to complete the user phone verification process. Use the\n     * **userId** and **secret** that were sent to your user's phone number to\n     * verify the user email ownership. If confirmed this route will return a 200\n     * status code.\n     *\n     * @param {string} userId\n     * @param {string} secret\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updatePhoneVerification(userId, secret) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof userId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"userId\"');\n            }\n            if (typeof secret === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"secret\"');\n            }\n            const apiPath = '/account/verification/phone';\n            const payload = {};\n            if (typeof userId !== 'undefined') {\n                payload['userId'] = userId;\n            }\n            if (typeof secret !== 'undefined') {\n                payload['secret'] = secret;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('put', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n}\n\nclass Avatars extends Service {\n    constructor(client) {\n        super(client);\n    }\n    /**\n     * Get browser icon\n     *\n     * You can use this endpoint to show different browser icons to your users.\n     * The code argument receives the browser code as it appears in your user [GET\n     * /account/sessions](https://appwrite.io/docs/references/cloud/client-web/account#getSessions)\n     * endpoint. Use width, height and quality arguments to change the output\n     * settings.\n     *\n     * When one dimension is specified and the other is 0, the image is scaled\n     * with preserved aspect ratio. If both dimensions are 0, the API provides an\n     * image at source quality. If dimensions are not specified, the default size\n     * of image returned is 100x100px.\n     *\n     * @param {Browser} code\n     * @param {number} width\n     * @param {number} height\n     * @param {number} quality\n     * @throws {AppwriteException}\n     * @returns {URL}\n    */\n    getBrowser(code, width, height, quality) {\n        if (typeof code === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n        const apiPath = '/avatars/browsers/{code}'.replace('{code}', code);\n        const payload = {};\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri;\n    }\n    /**\n     * Get credit card icon\n     *\n     * The credit card endpoint will return you the icon of the credit card\n     * provider you need. Use width, height and quality arguments to change the\n     * output settings.\n     *\n     * When one dimension is specified and the other is 0, the image is scaled\n     * with preserved aspect ratio. If both dimensions are 0, the API provides an\n     * image at source quality. If dimensions are not specified, the default size\n     * of image returned is 100x100px.\n     *\n     *\n     * @param {CreditCard} code\n     * @param {number} width\n     * @param {number} height\n     * @param {number} quality\n     * @throws {AppwriteException}\n     * @returns {URL}\n    */\n    getCreditCard(code, width, height, quality) {\n        if (typeof code === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n        const apiPath = '/avatars/credit-cards/{code}'.replace('{code}', code);\n        const payload = {};\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri;\n    }\n    /**\n     * Get favicon\n     *\n     * Use this endpoint to fetch the favorite icon (AKA favicon) of any remote\n     * website URL.\n     *\n     *\n     * @param {string} url\n     * @throws {AppwriteException}\n     * @returns {URL}\n    */\n    getFavicon(url) {\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n        const apiPath = '/avatars/favicon';\n        const payload = {};\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri;\n    }\n    /**\n     * Get country flag\n     *\n     * You can use this endpoint to show different country flags icons to your\n     * users. The code argument receives the 2 letter country code. Use width,\n     * height and quality arguments to change the output settings. Country codes\n     * follow the [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1) standard.\n     *\n     * When one dimension is specified and the other is 0, the image is scaled\n     * with preserved aspect ratio. If both dimensions are 0, the API provides an\n     * image at source quality. If dimensions are not specified, the default size\n     * of image returned is 100x100px.\n     *\n     *\n     * @param {Flag} code\n     * @param {number} width\n     * @param {number} height\n     * @param {number} quality\n     * @throws {AppwriteException}\n     * @returns {URL}\n    */\n    getFlag(code, width, height, quality) {\n        if (typeof code === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n        const apiPath = '/avatars/flags/{code}'.replace('{code}', code);\n        const payload = {};\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri;\n    }\n    /**\n     * Get image from URL\n     *\n     * Use this endpoint to fetch a remote image URL and crop it to any image size\n     * you want. This endpoint is very useful if you need to crop and display\n     * remote images in your app or in case you want to make sure a 3rd party\n     * image is properly served using a TLS protocol.\n     *\n     * When one dimension is specified and the other is 0, the image is scaled\n     * with preserved aspect ratio. If both dimensions are 0, the API provides an\n     * image at source quality. If dimensions are not specified, the default size\n     * of image returned is 400x400px.\n     *\n     *\n     * @param {string} url\n     * @param {number} width\n     * @param {number} height\n     * @throws {AppwriteException}\n     * @returns {URL}\n    */\n    getImage(url, width, height) {\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n        const apiPath = '/avatars/image';\n        const payload = {};\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri;\n    }\n    /**\n     * Get user initials\n     *\n     * Use this endpoint to show your user initials avatar icon on your website or\n     * app. By default, this route will try to print your logged-in user name or\n     * email initials. You can also overwrite the user name if you pass the 'name'\n     * parameter. If no name is given and no user is logged, an empty avatar will\n     * be returned.\n     *\n     * You can use the color and background params to change the avatar colors. By\n     * default, a random theme will be selected. The random theme will persist for\n     * the user's initials when reloading the same theme will always return for\n     * the same initials.\n     *\n     * When one dimension is specified and the other is 0, the image is scaled\n     * with preserved aspect ratio. If both dimensions are 0, the API provides an\n     * image at source quality. If dimensions are not specified, the default size\n     * of image returned is 100x100px.\n     *\n     *\n     * @param {string} name\n     * @param {number} width\n     * @param {number} height\n     * @param {string} background\n     * @throws {AppwriteException}\n     * @returns {URL}\n    */\n    getInitials(name, width, height, background) {\n        const apiPath = '/avatars/initials';\n        const payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        if (typeof background !== 'undefined') {\n            payload['background'] = background;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri;\n    }\n    /**\n     * Get QR code\n     *\n     * Converts a given plain text to a QR code image. You can use the query\n     * parameters to change the size and style of the resulting image.\n     *\n     *\n     * @param {string} text\n     * @param {number} size\n     * @param {number} margin\n     * @param {boolean} download\n     * @throws {AppwriteException}\n     * @returns {URL}\n    */\n    getQR(text, size, margin, download) {\n        if (typeof text === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"text\"');\n        }\n        const apiPath = '/avatars/qr';\n        const payload = {};\n        if (typeof text !== 'undefined') {\n            payload['text'] = text;\n        }\n        if (typeof size !== 'undefined') {\n            payload['size'] = size;\n        }\n        if (typeof margin !== 'undefined') {\n            payload['margin'] = margin;\n        }\n        if (typeof download !== 'undefined') {\n            payload['download'] = download;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri;\n    }\n}\n\nclass Databases extends Service {\n    constructor(client) {\n        super(client);\n    }\n    /**\n     * List documents\n     *\n     * Get a list of all the user's documents in a given collection. You can use\n     * the query params to filter your results.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    listDocuments(databaseId, collectionId, queries) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof databaseId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"databaseId\"');\n            }\n            if (typeof collectionId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"collectionId\"');\n            }\n            const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n            const payload = {};\n            if (typeof queries !== 'undefined') {\n                payload['queries'] = queries;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create document\n     *\n     * Create a new Document. Before using this route, you should create a new\n     * collection resource using either a [server\n     * integration](https://appwrite.io/docs/server/databases#databasesCreateCollection)\n     * API or directly from your database console.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} documentId\n     * @param {Omit<Document, keyof Models.Document>} data\n     * @param {string[]} permissions\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    createDocument(databaseId, collectionId, documentId, data, permissions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof databaseId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"databaseId\"');\n            }\n            if (typeof collectionId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"collectionId\"');\n            }\n            if (typeof documentId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"documentId\"');\n            }\n            if (typeof data === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"data\"');\n            }\n            const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n            const payload = {};\n            if (typeof documentId !== 'undefined') {\n                payload['documentId'] = documentId;\n            }\n            if (typeof data !== 'undefined') {\n                payload['data'] = data;\n            }\n            if (typeof permissions !== 'undefined') {\n                payload['permissions'] = permissions;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('post', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Get document\n     *\n     * Get a document by its unique ID. This endpoint response returns a JSON\n     * object with the document data.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} documentId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    getDocument(databaseId, collectionId, documentId, queries) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof databaseId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"databaseId\"');\n            }\n            if (typeof collectionId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"collectionId\"');\n            }\n            if (typeof documentId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"documentId\"');\n            }\n            const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n            const payload = {};\n            if (typeof queries !== 'undefined') {\n                payload['queries'] = queries;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Update document\n     *\n     * Update a document by its unique ID. Using the patch method you can pass\n     * only specific fields that will get updated.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} documentId\n     * @param {Partial<Omit<Document, keyof Models.Document>>} data\n     * @param {string[]} permissions\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updateDocument(databaseId, collectionId, documentId, data, permissions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof databaseId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"databaseId\"');\n            }\n            if (typeof collectionId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"collectionId\"');\n            }\n            if (typeof documentId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"documentId\"');\n            }\n            const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n            const payload = {};\n            if (typeof data !== 'undefined') {\n                payload['data'] = data;\n            }\n            if (typeof permissions !== 'undefined') {\n                payload['permissions'] = permissions;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('patch', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Delete document\n     *\n     * Delete a document by its unique ID.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} documentId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    deleteDocument(databaseId, collectionId, documentId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof databaseId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"databaseId\"');\n            }\n            if (typeof collectionId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"collectionId\"');\n            }\n            if (typeof documentId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"documentId\"');\n            }\n            const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('delete', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n}\n\nclass Functions extends Service {\n    constructor(client) {\n        super(client);\n    }\n    /**\n     * List executions\n     *\n     * Get a list of all the current user function execution logs. You can use the\n     * query params to filter your results.\n     *\n     * @param {string} functionId\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    listExecutions(functionId, queries, search) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof functionId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"functionId\"');\n            }\n            const apiPath = '/functions/{functionId}/executions'.replace('{functionId}', functionId);\n            const payload = {};\n            if (typeof queries !== 'undefined') {\n                payload['queries'] = queries;\n            }\n            if (typeof search !== 'undefined') {\n                payload['search'] = search;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create execution\n     *\n     * Trigger a function execution. The returned object will return you the\n     * current execution status. You can ping the `Get Execution` endpoint to get\n     * updates on the current execution status. Once this endpoint is called, your\n     * function execution process will start asynchronously.\n     *\n     * @param {string} functionId\n     * @param {string} body\n     * @param {boolean} async\n     * @param {string} xpath\n     * @param {ExecutionMethod} method\n     * @param {object} headers\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    createExecution(functionId, body, async, xpath, method, headers) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof functionId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"functionId\"');\n            }\n            const apiPath = '/functions/{functionId}/executions'.replace('{functionId}', functionId);\n            const payload = {};\n            if (typeof body !== 'undefined') {\n                payload['body'] = body;\n            }\n            if (typeof async !== 'undefined') {\n                payload['async'] = async;\n            }\n            if (typeof xpath !== 'undefined') {\n                payload['path'] = xpath;\n            }\n            if (typeof method !== 'undefined') {\n                payload['method'] = method;\n            }\n            if (typeof headers !== 'undefined') {\n                payload['headers'] = headers;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('post', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Get execution\n     *\n     * Get a function execution log by its unique ID.\n     *\n     * @param {string} functionId\n     * @param {string} executionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    getExecution(functionId, executionId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof functionId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"functionId\"');\n            }\n            if (typeof executionId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"executionId\"');\n            }\n            const apiPath = '/functions/{functionId}/executions/{executionId}'.replace('{functionId}', functionId).replace('{executionId}', executionId);\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n}\n\nclass Graphql extends Service {\n    constructor(client) {\n        super(client);\n    }\n    /**\n     * GraphQL endpoint\n     *\n     * Execute a GraphQL mutation.\n     *\n     * @param {object} query\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    query(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof query === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"query\"');\n            }\n            const apiPath = '/graphql';\n            const payload = {};\n            if (typeof query !== 'undefined') {\n                payload['query'] = query;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('post', uri, {\n                'x-sdk-graphql': 'true',\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * GraphQL endpoint\n     *\n     * Execute a GraphQL mutation.\n     *\n     * @param {object} query\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    mutation(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof query === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"query\"');\n            }\n            const apiPath = '/graphql/mutation';\n            const payload = {};\n            if (typeof query !== 'undefined') {\n                payload['query'] = query;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('post', uri, {\n                'x-sdk-graphql': 'true',\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n}\n\nclass Locale extends Service {\n    constructor(client) {\n        super(client);\n    }\n    /**\n     * Get user locale\n     *\n     * Get the current user location based on IP. Returns an object with user\n     * country code, country name, continent name, continent code, ip address and\n     * suggested currency. You can use the locale header to get the data in a\n     * supported language.\n     *\n     * ([IP Geolocation by DB-IP](https://db-ip.com))\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    get() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/locale';\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * List Locale Codes\n     *\n     * List of all locale codes in [ISO\n     * 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    listCodes() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/locale/codes';\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * List continents\n     *\n     * List of all continents. You can use the locale header to get the data in a\n     * supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    listContinents() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/locale/continents';\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * List countries\n     *\n     * List of all countries. You can use the locale header to get the data in a\n     * supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    listCountries() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/locale/countries';\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * List EU countries\n     *\n     * List of all countries that are currently members of the EU. You can use the\n     * locale header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    listCountriesEU() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/locale/countries/eu';\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * List countries phone codes\n     *\n     * List of all countries phone codes. You can use the locale header to get the\n     * data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    listCountriesPhones() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/locale/countries/phones';\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * List currencies\n     *\n     * List of all currencies, including currency symbol, name, plural, and\n     * decimal digits for all major and minor currencies. You can use the locale\n     * header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    listCurrencies() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/locale/currencies';\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * List languages\n     *\n     * List of all languages classified by ISO 639-1 including 2-letter code, name\n     * in English, and name in the respective language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    listLanguages() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/locale/languages';\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n}\n\nclass Messaging extends Service {\n    constructor(client) {\n        super(client);\n    }\n    /**\n     * Create subscriber\n     *\n     * Create a new subscriber.\n     *\n     * @param {string} topicId\n     * @param {string} subscriberId\n     * @param {string} targetId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    createSubscriber(topicId, subscriberId, targetId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof topicId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"topicId\"');\n            }\n            if (typeof subscriberId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"subscriberId\"');\n            }\n            if (typeof targetId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"targetId\"');\n            }\n            const apiPath = '/messaging/topics/{topicId}/subscribers'.replace('{topicId}', topicId);\n            const payload = {};\n            if (typeof subscriberId !== 'undefined') {\n                payload['subscriberId'] = subscriberId;\n            }\n            if (typeof targetId !== 'undefined') {\n                payload['targetId'] = targetId;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('post', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Delete subscriber\n     *\n     * Delete a subscriber by its unique ID.\n     *\n     * @param {string} topicId\n     * @param {string} subscriberId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    deleteSubscriber(topicId, subscriberId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof topicId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"topicId\"');\n            }\n            if (typeof subscriberId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"subscriberId\"');\n            }\n            const apiPath = '/messaging/topics/{topicId}/subscribers/{subscriberId}'.replace('{topicId}', topicId).replace('{subscriberId}', subscriberId);\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('delete', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n}\n\nclass Storage extends Service {\n    constructor(client) {\n        super(client);\n    }\n    /**\n     * List files\n     *\n     * Get a list of all the user files. You can use the query params to filter\n     * your results.\n     *\n     * @param {string} bucketId\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    listFiles(bucketId, queries, search) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof bucketId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"bucketId\"');\n            }\n            const apiPath = '/storage/buckets/{bucketId}/files'.replace('{bucketId}', bucketId);\n            const payload = {};\n            if (typeof queries !== 'undefined') {\n                payload['queries'] = queries;\n            }\n            if (typeof search !== 'undefined') {\n                payload['search'] = search;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create file\n     *\n     * Create a new file. Before using this route, you should create a new bucket\n     * resource using either a [server\n     * integration](https://appwrite.io/docs/server/storage#storageCreateBucket)\n     * API or directly from your Appwrite console.\n     *\n     * Larger files should be uploaded using multiple requests with the\n     * [content-range](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Range)\n     * header to send a partial request with a maximum supported chunk of `5MB`.\n     * The `content-range` header values should always be in bytes.\n     *\n     * When the first request is sent, the server will return the **File** object,\n     * and the subsequent part request must include the file's **id** in\n     * `x-appwrite-id` header to allow the server to know that the partial upload\n     * is for the existing file and not for a new one.\n     *\n     * If you're creating a new file using one of the Appwrite SDKs, all the\n     * chunking logic will be managed by the SDK internally.\n     *\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @param {File} file\n     * @param {string[]} permissions\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    createFile(bucketId, fileId, file, permissions, onProgress = (progress) => { }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof bucketId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"bucketId\"');\n            }\n            if (typeof fileId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"fileId\"');\n            }\n            if (typeof file === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"file\"');\n            }\n            const apiPath = '/storage/buckets/{bucketId}/files'.replace('{bucketId}', bucketId);\n            const payload = {};\n            if (typeof fileId !== 'undefined') {\n                payload['fileId'] = fileId;\n            }\n            if (typeof file !== 'undefined') {\n                payload['file'] = file;\n            }\n            if (typeof permissions !== 'undefined') {\n                payload['permissions'] = permissions;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            if (!(file instanceof File)) {\n                throw new AppwriteException('Parameter \"file\" has to be a File.');\n            }\n            const size = file.size;\n            if (size <= Service.CHUNK_SIZE) {\n                return yield this.client.call('post', uri, {\n                    'content-type': 'multipart/form-data',\n                }, payload);\n            }\n            const apiHeaders = {\n                'content-type': 'multipart/form-data',\n            };\n            let offset = 0;\n            let response = undefined;\n            if (fileId != 'unique()') {\n                try {\n                    response = yield this.client.call('GET', new URL(this.client.config.endpoint + apiPath + '/' + fileId), apiHeaders);\n                    offset = response.chunksUploaded * Service.CHUNK_SIZE;\n                }\n                catch (e) {\n                }\n            }\n            while (offset < size) {\n                let end = Math.min(offset + Service.CHUNK_SIZE - 1, size - 1);\n                apiHeaders['content-range'] = 'bytes ' + offset + '-' + end + '/' + size;\n                if (response && response.$id) {\n                    apiHeaders['x-appwrite-id'] = response.$id;\n                }\n                const chunk = file.slice(offset, end + 1);\n                payload['file'] = new File([chunk], file.name);\n                response = yield this.client.call('post', uri, apiHeaders, payload);\n                if (onProgress) {\n                    onProgress({\n                        $id: response.$id,\n                        progress: (offset / size) * 100,\n                        sizeUploaded: offset,\n                        chunksTotal: response.chunksTotal,\n                        chunksUploaded: response.chunksUploaded\n                    });\n                }\n                offset += Service.CHUNK_SIZE;\n            }\n            return response;\n        });\n    }\n    /**\n     * Get file\n     *\n     * Get a file by its unique ID. This endpoint response returns a JSON object\n     * with the file metadata.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    getFile(bucketId, fileId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof bucketId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"bucketId\"');\n            }\n            if (typeof fileId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"fileId\"');\n            }\n            const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Update file\n     *\n     * Update a file by its unique ID. Only users with write permissions have\n     * access to update this resource.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @param {string} name\n     * @param {string[]} permissions\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updateFile(bucketId, fileId, name, permissions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof bucketId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"bucketId\"');\n            }\n            if (typeof fileId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"fileId\"');\n            }\n            const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n            const payload = {};\n            if (typeof name !== 'undefined') {\n                payload['name'] = name;\n            }\n            if (typeof permissions !== 'undefined') {\n                payload['permissions'] = permissions;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('put', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Delete File\n     *\n     * Delete a file by its unique ID. Only users with write permissions have\n     * access to delete this resource.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    deleteFile(bucketId, fileId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof bucketId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"bucketId\"');\n            }\n            if (typeof fileId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"fileId\"');\n            }\n            const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('delete', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Get file for download\n     *\n     * Get a file content by its unique ID. The endpoint response return with a\n     * 'Content-Disposition: attachment' header that tells the browser to start\n     * downloading the file to user downloads directory.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @throws {AppwriteException}\n     * @returns {URL}\n    */\n    getFileDownload(bucketId, fileId) {\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/download'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri;\n    }\n    /**\n     * Get file preview\n     *\n     * Get a file preview image. Currently, this method supports preview for image\n     * files (jpg, png, and gif), other supported formats, like pdf, docs, slides,\n     * and spreadsheets, will return the file icon image. You can also pass query\n     * string arguments for cutting and resizing your preview image. Preview is\n     * supported only for image files smaller than 10MB.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @param {number} width\n     * @param {number} height\n     * @param {ImageGravity} gravity\n     * @param {number} quality\n     * @param {number} borderWidth\n     * @param {string} borderColor\n     * @param {number} borderRadius\n     * @param {number} opacity\n     * @param {number} rotation\n     * @param {string} background\n     * @param {ImageFormat} output\n     * @throws {AppwriteException}\n     * @returns {URL}\n    */\n    getFilePreview(bucketId, fileId, width, height, gravity, quality, borderWidth, borderColor, borderRadius, opacity, rotation, background, output) {\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/preview'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload = {};\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        if (typeof gravity !== 'undefined') {\n            payload['gravity'] = gravity;\n        }\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n        if (typeof borderWidth !== 'undefined') {\n            payload['borderWidth'] = borderWidth;\n        }\n        if (typeof borderColor !== 'undefined') {\n            payload['borderColor'] = borderColor;\n        }\n        if (typeof borderRadius !== 'undefined') {\n            payload['borderRadius'] = borderRadius;\n        }\n        if (typeof opacity !== 'undefined') {\n            payload['opacity'] = opacity;\n        }\n        if (typeof rotation !== 'undefined') {\n            payload['rotation'] = rotation;\n        }\n        if (typeof background !== 'undefined') {\n            payload['background'] = background;\n        }\n        if (typeof output !== 'undefined') {\n            payload['output'] = output;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri;\n    }\n    /**\n     * Get file for view\n     *\n     * Get a file content by its unique ID. This endpoint is similar to the\n     * download method but returns with no  'Content-Disposition: attachment'\n     * header.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @throws {AppwriteException}\n     * @returns {URL}\n    */\n    getFileView(bucketId, fileId) {\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/view'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri;\n    }\n}\n\nclass Teams extends Service {\n    constructor(client) {\n        super(client);\n    }\n    /**\n     * List teams\n     *\n     * Get a list of all the teams in which the current user is a member. You can\n     * use the parameters to filter your results.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    list(queries, search) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiPath = '/teams';\n            const payload = {};\n            if (typeof queries !== 'undefined') {\n                payload['queries'] = queries;\n            }\n            if (typeof search !== 'undefined') {\n                payload['search'] = search;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create team\n     *\n     * Create a new team. The user who creates the team will automatically be\n     * assigned as the owner of the team. Only the users with the owner role can\n     * invite new members, add new owners and delete or update the team.\n     *\n     * @param {string} teamId\n     * @param {string} name\n     * @param {string[]} roles\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    create(teamId, name, roles) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof teamId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"teamId\"');\n            }\n            if (typeof name === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"name\"');\n            }\n            const apiPath = '/teams';\n            const payload = {};\n            if (typeof teamId !== 'undefined') {\n                payload['teamId'] = teamId;\n            }\n            if (typeof name !== 'undefined') {\n                payload['name'] = name;\n            }\n            if (typeof roles !== 'undefined') {\n                payload['roles'] = roles;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('post', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Get team\n     *\n     * Get a team by its ID. All team members have read access for this resource.\n     *\n     * @param {string} teamId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    get(teamId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof teamId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"teamId\"');\n            }\n            const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Update name\n     *\n     * Update the team's name by its unique ID.\n     *\n     * @param {string} teamId\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updateName(teamId, name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof teamId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"teamId\"');\n            }\n            if (typeof name === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"name\"');\n            }\n            const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);\n            const payload = {};\n            if (typeof name !== 'undefined') {\n                payload['name'] = name;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('put', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Delete team\n     *\n     * Delete a team using its ID. Only team members with the owner role can\n     * delete the team.\n     *\n     * @param {string} teamId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    delete(teamId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof teamId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"teamId\"');\n            }\n            const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('delete', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * List team memberships\n     *\n     * Use this endpoint to list a team's members using the team's ID. All team\n     * members have read access to this endpoint.\n     *\n     * @param {string} teamId\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    listMemberships(teamId, queries, search) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof teamId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"teamId\"');\n            }\n            const apiPath = '/teams/{teamId}/memberships'.replace('{teamId}', teamId);\n            const payload = {};\n            if (typeof queries !== 'undefined') {\n                payload['queries'] = queries;\n            }\n            if (typeof search !== 'undefined') {\n                payload['search'] = search;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Create team membership\n     *\n     * Invite a new member to join your team. Provide an ID for existing users, or\n     * invite unregistered users using an email or phone number. If initiated from\n     * a Client SDK, Appwrite will send an email or sms with a link to join the\n     * team to the invited user, and an account will be created for them if one\n     * doesn't exist. If initiated from a Server SDK, the new member will be added\n     * automatically to the team.\n     *\n     * You only need to provide one of a user ID, email, or phone number. Appwrite\n     * will prioritize accepting the user ID > email > phone number if you provide\n     * more than one of these parameters.\n     *\n     * Use the `url` parameter to redirect the user from the invitation email to\n     * your app. After the user is redirected, use the [Update Team Membership\n     * Status](https://appwrite.io/docs/references/cloud/client-web/teams#updateMembershipStatus)\n     * endpoint to allow the user to accept the invitation to the team.\n     *\n     * Please note that to avoid a [Redirect\n     * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md)\n     * Appwrite will accept the only redirect URLs under the domains you have\n     * added as a platform on the Appwrite Console.\n     *\n     *\n     * @param {string} teamId\n     * @param {string[]} roles\n     * @param {string} email\n     * @param {string} userId\n     * @param {string} phone\n     * @param {string} url\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    createMembership(teamId, roles, email, userId, phone, url, name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof teamId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"teamId\"');\n            }\n            if (typeof roles === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"roles\"');\n            }\n            const apiPath = '/teams/{teamId}/memberships'.replace('{teamId}', teamId);\n            const payload = {};\n            if (typeof email !== 'undefined') {\n                payload['email'] = email;\n            }\n            if (typeof userId !== 'undefined') {\n                payload['userId'] = userId;\n            }\n            if (typeof phone !== 'undefined') {\n                payload['phone'] = phone;\n            }\n            if (typeof roles !== 'undefined') {\n                payload['roles'] = roles;\n            }\n            if (typeof url !== 'undefined') {\n                payload['url'] = url;\n            }\n            if (typeof name !== 'undefined') {\n                payload['name'] = name;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('post', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Get team membership\n     *\n     * Get a team member by the membership unique id. All team members have read\n     * access for this resource.\n     *\n     * @param {string} teamId\n     * @param {string} membershipId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    getMembership(teamId, membershipId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof teamId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"teamId\"');\n            }\n            if (typeof membershipId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"membershipId\"');\n            }\n            const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Update membership\n     *\n     * Modify the roles of a team member. Only team members with the owner role\n     * have access to this endpoint. Learn more about [roles and\n     * permissions](https://appwrite.io/docs/permissions).\n     *\n     *\n     * @param {string} teamId\n     * @param {string} membershipId\n     * @param {string[]} roles\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updateMembership(teamId, membershipId, roles) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof teamId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"teamId\"');\n            }\n            if (typeof membershipId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"membershipId\"');\n            }\n            if (typeof roles === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"roles\"');\n            }\n            const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n            const payload = {};\n            if (typeof roles !== 'undefined') {\n                payload['roles'] = roles;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('patch', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Delete team membership\n     *\n     * This endpoint allows a user to leave a team or for a team owner to delete\n     * the membership of any other team member. You can also use this endpoint to\n     * delete a user membership even if it is not accepted.\n     *\n     * @param {string} teamId\n     * @param {string} membershipId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    deleteMembership(teamId, membershipId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof teamId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"teamId\"');\n            }\n            if (typeof membershipId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"membershipId\"');\n            }\n            const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('delete', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Update team membership status\n     *\n     * Use this endpoint to allow a user to accept an invitation to join a team\n     * after being redirected back to your app from the invitation email received\n     * by the user.\n     *\n     * If the request is successful, a session for the user is automatically\n     * created.\n     *\n     *\n     * @param {string} teamId\n     * @param {string} membershipId\n     * @param {string} userId\n     * @param {string} secret\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updateMembershipStatus(teamId, membershipId, userId, secret) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof teamId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"teamId\"');\n            }\n            if (typeof membershipId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"membershipId\"');\n            }\n            if (typeof userId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"userId\"');\n            }\n            if (typeof secret === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"secret\"');\n            }\n            const apiPath = '/teams/{teamId}/memberships/{membershipId}/status'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n            const payload = {};\n            if (typeof userId !== 'undefined') {\n                payload['userId'] = userId;\n            }\n            if (typeof secret !== 'undefined') {\n                payload['secret'] = secret;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('patch', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Get team preferences\n     *\n     * Get the team's shared preferences by its unique ID. If a preference doesn't\n     * need to be shared by all team members, prefer storing them in [user\n     * preferences](https://appwrite.io/docs/references/cloud/client-web/account#getPrefs).\n     *\n     * @param {string} teamId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    getPrefs(teamId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof teamId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"teamId\"');\n            }\n            const apiPath = '/teams/{teamId}/prefs'.replace('{teamId}', teamId);\n            const payload = {};\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('get', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n    /**\n     * Update preferences\n     *\n     * Update the team's preferences by its unique ID. The object you pass is\n     * stored as is and replaces any previous value. The maximum allowed prefs\n     * size is 64kB and throws an error if exceeded.\n     *\n     * @param {string} teamId\n     * @param {object} prefs\n     * @throws {AppwriteException}\n     * @returns {Promise}\n    */\n    updatePrefs(teamId, prefs) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof teamId === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"teamId\"');\n            }\n            if (typeof prefs === 'undefined') {\n                throw new AppwriteException('Missing required parameter: \"prefs\"');\n            }\n            const apiPath = '/teams/{teamId}/prefs'.replace('{teamId}', teamId);\n            const payload = {};\n            if (typeof prefs !== 'undefined') {\n                payload['prefs'] = prefs;\n            }\n            const uri = new URL(this.client.config.endpoint + apiPath);\n            return yield this.client.call('put', uri, {\n                'content-type': 'application/json',\n            }, payload);\n        });\n    }\n}\n\nclass Permission {\n}\nPermission.read = (role) => {\n    return `read(\"${role}\")`;\n};\nPermission.write = (role) => {\n    return `write(\"${role}\")`;\n};\nPermission.create = (role) => {\n    return `create(\"${role}\")`;\n};\nPermission.update = (role) => {\n    return `update(\"${role}\")`;\n};\nPermission.delete = (role) => {\n    return `delete(\"${role}\")`;\n};\n\n/**\n * Helper class to generate role strings for `Permission`.\n */\nclass Role {\n    /**\n     * Grants access to anyone.\n     *\n     * This includes authenticated and unauthenticated users.\n     *\n     * @returns {string}\n     */\n    static any() {\n        return 'any';\n    }\n    /**\n     * Grants access to a specific user by user ID.\n     *\n     * You can optionally pass verified or unverified for\n     * `status` to target specific types of users.\n     *\n     * @param {string} id\n     * @param {string} status\n     * @returns {string}\n     */\n    static user(id, status = '') {\n        if (status === '') {\n            return `user:${id}`;\n        }\n        return `user:${id}/${status}`;\n    }\n    /**\n     * Grants access to any authenticated or anonymous user.\n     *\n     * You can optionally pass verified or unverified for\n     * `status` to target specific types of users.\n     *\n     * @param {string} status\n     * @returns {string}\n     */\n    static users(status = '') {\n        if (status === '') {\n            return 'users';\n        }\n        return `users/${status}`;\n    }\n    /**\n     * Grants access to any guest user without a session.\n     *\n     * Authenticated users don't have access to this role.\n     *\n     * @returns {string}\n     */\n    static guests() {\n        return 'guests';\n    }\n    /**\n     * Grants access to a team by team ID.\n     *\n     * You can optionally pass a role for `role` to target\n     * team members with the specified role.\n     *\n     * @param {string} id\n     * @param {string} role\n     * @returns {string}\n     */\n    static team(id, role = '') {\n        if (role === '') {\n            return `team:${id}`;\n        }\n        return `team:${id}/${role}`;\n    }\n    /**\n     * Grants access to a specific member of a team.\n     *\n     * When the member is removed from the team, they will\n     * no longer have access.\n     *\n     * @param {string} id\n     * @returns {string}\n     */\n    static member(id) {\n        return `member:${id}`;\n    }\n    /**\n     * Grants access to a user with the specified label.\n     *\n     * @param {string} name\n     * @returns  {string}\n     */\n    static label(name) {\n        return `label:${name}`;\n    }\n}\n\nvar _a, _ID_hexTimestamp;\nclass ID {\n    static custom(id) {\n        return id;\n    }\n    static unique(padding = 7) {\n        // Generate a unique ID with padding to have a longer ID\n        const baseId = __classPrivateFieldGet(ID, _a, \"m\", _ID_hexTimestamp).call(ID);\n        let randomPadding = '';\n        for (let i = 0; i < padding; i++) {\n            const randomHexDigit = Math.floor(Math.random() * 16).toString(16);\n            randomPadding += randomHexDigit;\n        }\n        return baseId + randomPadding;\n    }\n}\n_a = ID, _ID_hexTimestamp = function _ID_hexTimestamp() {\n    const now = new Date();\n    const sec = Math.floor(now.getTime() / 1000);\n    const msec = now.getMilliseconds();\n    // Convert to hexadecimal\n    const hexTimestamp = sec.toString(16) + msec.toString(16).padStart(5, '0');\n    return hexTimestamp;\n};\n\nvar AuthenticatorType;\n(function (AuthenticatorType) {\n    AuthenticatorType[\"Totp\"] = \"totp\";\n})(AuthenticatorType || (AuthenticatorType = {}));\n\nvar AuthenticationFactor;\n(function (AuthenticationFactor) {\n    AuthenticationFactor[\"Email\"] = \"email\";\n    AuthenticationFactor[\"Phone\"] = \"phone\";\n    AuthenticationFactor[\"Totp\"] = \"totp\";\n    AuthenticationFactor[\"Recoverycode\"] = \"recoverycode\";\n})(AuthenticationFactor || (AuthenticationFactor = {}));\n\nvar OAuthProvider;\n(function (OAuthProvider) {\n    OAuthProvider[\"Amazon\"] = \"amazon\";\n    OAuthProvider[\"Apple\"] = \"apple\";\n    OAuthProvider[\"Auth0\"] = \"auth0\";\n    OAuthProvider[\"Authentik\"] = \"authentik\";\n    OAuthProvider[\"Autodesk\"] = \"autodesk\";\n    OAuthProvider[\"Bitbucket\"] = \"bitbucket\";\n    OAuthProvider[\"Bitly\"] = \"bitly\";\n    OAuthProvider[\"Box\"] = \"box\";\n    OAuthProvider[\"Dailymotion\"] = \"dailymotion\";\n    OAuthProvider[\"Discord\"] = \"discord\";\n    OAuthProvider[\"Disqus\"] = \"disqus\";\n    OAuthProvider[\"Dropbox\"] = \"dropbox\";\n    OAuthProvider[\"Etsy\"] = \"etsy\";\n    OAuthProvider[\"Facebook\"] = \"facebook\";\n    OAuthProvider[\"Github\"] = \"github\";\n    OAuthProvider[\"Gitlab\"] = \"gitlab\";\n    OAuthProvider[\"Google\"] = \"google\";\n    OAuthProvider[\"Linkedin\"] = \"linkedin\";\n    OAuthProvider[\"Microsoft\"] = \"microsoft\";\n    OAuthProvider[\"Notion\"] = \"notion\";\n    OAuthProvider[\"Oidc\"] = \"oidc\";\n    OAuthProvider[\"Okta\"] = \"okta\";\n    OAuthProvider[\"Paypal\"] = \"paypal\";\n    OAuthProvider[\"PaypalSandbox\"] = \"paypalSandbox\";\n    OAuthProvider[\"Podio\"] = \"podio\";\n    OAuthProvider[\"Salesforce\"] = \"salesforce\";\n    OAuthProvider[\"Slack\"] = \"slack\";\n    OAuthProvider[\"Spotify\"] = \"spotify\";\n    OAuthProvider[\"Stripe\"] = \"stripe\";\n    OAuthProvider[\"Tradeshift\"] = \"tradeshift\";\n    OAuthProvider[\"TradeshiftBox\"] = \"tradeshiftBox\";\n    OAuthProvider[\"Twitch\"] = \"twitch\";\n    OAuthProvider[\"Wordpress\"] = \"wordpress\";\n    OAuthProvider[\"Yahoo\"] = \"yahoo\";\n    OAuthProvider[\"Yammer\"] = \"yammer\";\n    OAuthProvider[\"Yandex\"] = \"yandex\";\n    OAuthProvider[\"Zoho\"] = \"zoho\";\n    OAuthProvider[\"Zoom\"] = \"zoom\";\n    OAuthProvider[\"Mock\"] = \"mock\";\n})(OAuthProvider || (OAuthProvider = {}));\n\nvar Browser;\n(function (Browser) {\n    Browser[\"AvantBrowser\"] = \"aa\";\n    Browser[\"AndroidWebViewBeta\"] = \"an\";\n    Browser[\"GoogleChrome\"] = \"ch\";\n    Browser[\"GoogleChromeIOS\"] = \"ci\";\n    Browser[\"GoogleChromeMobile\"] = \"cm\";\n    Browser[\"Chromium\"] = \"cr\";\n    Browser[\"MozillaFirefox\"] = \"ff\";\n    Browser[\"Safari\"] = \"sf\";\n    Browser[\"MobileSafari\"] = \"mf\";\n    Browser[\"MicrosoftEdge\"] = \"ps\";\n    Browser[\"MicrosoftEdgeIOS\"] = \"oi\";\n    Browser[\"OperaMini\"] = \"om\";\n    Browser[\"Opera\"] = \"op\";\n    Browser[\"OperaNext\"] = \"on\";\n})(Browser || (Browser = {}));\n\nvar CreditCard;\n(function (CreditCard) {\n    CreditCard[\"AmericanExpress\"] = \"amex\";\n    CreditCard[\"Argencard\"] = \"argencard\";\n    CreditCard[\"Cabal\"] = \"cabal\";\n    CreditCard[\"Cencosud\"] = \"cencosud\";\n    CreditCard[\"DinersClub\"] = \"diners\";\n    CreditCard[\"Discover\"] = \"discover\";\n    CreditCard[\"Elo\"] = \"elo\";\n    CreditCard[\"Hipercard\"] = \"hipercard\";\n    CreditCard[\"JCB\"] = \"jcb\";\n    CreditCard[\"Mastercard\"] = \"mastercard\";\n    CreditCard[\"Naranja\"] = \"naranja\";\n    CreditCard[\"TarjetaShopping\"] = \"targeta-shopping\";\n    CreditCard[\"UnionChinaPay\"] = \"union-china-pay\";\n    CreditCard[\"Visa\"] = \"visa\";\n    CreditCard[\"MIR\"] = \"mir\";\n    CreditCard[\"Maestro\"] = \"maestro\";\n})(CreditCard || (CreditCard = {}));\n\nvar Flag;\n(function (Flag) {\n    Flag[\"Afghanistan\"] = \"af\";\n    Flag[\"Angola\"] = \"ao\";\n    Flag[\"Albania\"] = \"al\";\n    Flag[\"Andorra\"] = \"ad\";\n    Flag[\"UnitedArabEmirates\"] = \"ae\";\n    Flag[\"Argentina\"] = \"ar\";\n    Flag[\"Armenia\"] = \"am\";\n    Flag[\"AntiguaAndBarbuda\"] = \"ag\";\n    Flag[\"Australia\"] = \"au\";\n    Flag[\"Austria\"] = \"at\";\n    Flag[\"Azerbaijan\"] = \"az\";\n    Flag[\"Burundi\"] = \"bi\";\n    Flag[\"Belgium\"] = \"be\";\n    Flag[\"Benin\"] = \"bj\";\n    Flag[\"BurkinaFaso\"] = \"bf\";\n    Flag[\"Bangladesh\"] = \"bd\";\n    Flag[\"Bulgaria\"] = \"bg\";\n    Flag[\"Bahrain\"] = \"bh\";\n    Flag[\"Bahamas\"] = \"bs\";\n    Flag[\"BosniaAndHerzegovina\"] = \"ba\";\n    Flag[\"Belarus\"] = \"by\";\n    Flag[\"Belize\"] = \"bz\";\n    Flag[\"Bolivia\"] = \"bo\";\n    Flag[\"Brazil\"] = \"br\";\n    Flag[\"Barbados\"] = \"bb\";\n    Flag[\"BruneiDarussalam\"] = \"bn\";\n    Flag[\"Bhutan\"] = \"bt\";\n    Flag[\"Botswana\"] = \"bw\";\n    Flag[\"CentralAfricanRepublic\"] = \"cf\";\n    Flag[\"Canada\"] = \"ca\";\n    Flag[\"Switzerland\"] = \"ch\";\n    Flag[\"Chile\"] = \"cl\";\n    Flag[\"China\"] = \"cn\";\n    Flag[\"CoteDIvoire\"] = \"ci\";\n    Flag[\"Cameroon\"] = \"cm\";\n    Flag[\"DemocraticRepublicOfTheCongo\"] = \"cd\";\n    Flag[\"RepublicOfTheCongo\"] = \"cg\";\n    Flag[\"Colombia\"] = \"co\";\n    Flag[\"Comoros\"] = \"km\";\n    Flag[\"CapeVerde\"] = \"cv\";\n    Flag[\"CostaRica\"] = \"cr\";\n    Flag[\"Cuba\"] = \"cu\";\n    Flag[\"Cyprus\"] = \"cy\";\n    Flag[\"CzechRepublic\"] = \"cz\";\n    Flag[\"Germany\"] = \"de\";\n    Flag[\"Djibouti\"] = \"dj\";\n    Flag[\"Dominica\"] = \"dm\";\n    Flag[\"Denmark\"] = \"dk\";\n    Flag[\"DominicanRepublic\"] = \"do\";\n    Flag[\"Algeria\"] = \"dz\";\n    Flag[\"Ecuador\"] = \"ec\";\n    Flag[\"Egypt\"] = \"eg\";\n    Flag[\"Eritrea\"] = \"er\";\n    Flag[\"Spain\"] = \"es\";\n    Flag[\"Estonia\"] = \"ee\";\n    Flag[\"Ethiopia\"] = \"et\";\n    Flag[\"Finland\"] = \"fi\";\n    Flag[\"Fiji\"] = \"fj\";\n    Flag[\"France\"] = \"fr\";\n    Flag[\"MicronesiaFederatedStatesOf\"] = \"fm\";\n    Flag[\"Gabon\"] = \"ga\";\n    Flag[\"UnitedKingdom\"] = \"gb\";\n    Flag[\"Georgia\"] = \"ge\";\n    Flag[\"Ghana\"] = \"gh\";\n    Flag[\"Guinea\"] = \"gn\";\n    Flag[\"Gambia\"] = \"gm\";\n    Flag[\"GuineaBissau\"] = \"gw\";\n    Flag[\"EquatorialGuinea\"] = \"gq\";\n    Flag[\"Greece\"] = \"gr\";\n    Flag[\"Grenada\"] = \"gd\";\n    Flag[\"Guatemala\"] = \"gt\";\n    Flag[\"Guyana\"] = \"gy\";\n    Flag[\"Honduras\"] = \"hn\";\n    Flag[\"Croatia\"] = \"hr\";\n    Flag[\"Haiti\"] = \"ht\";\n    Flag[\"Hungary\"] = \"hu\";\n    Flag[\"Indonesia\"] = \"id\";\n    Flag[\"India\"] = \"in\";\n    Flag[\"Ireland\"] = \"ie\";\n    Flag[\"IranIslamicRepublicOf\"] = \"ir\";\n    Flag[\"Iraq\"] = \"iq\";\n    Flag[\"Iceland\"] = \"is\";\n    Flag[\"Israel\"] = \"il\";\n    Flag[\"Italy\"] = \"it\";\n    Flag[\"Jamaica\"] = \"jm\";\n    Flag[\"Jordan\"] = \"jo\";\n    Flag[\"Japan\"] = \"jp\";\n    Flag[\"Kazakhstan\"] = \"kz\";\n    Flag[\"Kenya\"] = \"ke\";\n    Flag[\"Kyrgyzstan\"] = \"kg\";\n    Flag[\"Cambodia\"] = \"kh\";\n    Flag[\"Kiribati\"] = \"ki\";\n    Flag[\"SaintKittsAndNevis\"] = \"kn\";\n    Flag[\"SouthKorea\"] = \"kr\";\n    Flag[\"Kuwait\"] = \"kw\";\n    Flag[\"LaoPeopleSDemocraticRepublic\"] = \"la\";\n    Flag[\"Lebanon\"] = \"lb\";\n    Flag[\"Liberia\"] = \"lr\";\n    Flag[\"Libya\"] = \"ly\";\n    Flag[\"SaintLucia\"] = \"lc\";\n    Flag[\"Liechtenstein\"] = \"li\";\n    Flag[\"SriLanka\"] = \"lk\";\n    Flag[\"Lesotho\"] = \"ls\";\n    Flag[\"Lithuania\"] = \"lt\";\n    Flag[\"Luxembourg\"] = \"lu\";\n    Flag[\"Latvia\"] = \"lv\";\n    Flag[\"Morocco\"] = \"ma\";\n    Flag[\"Monaco\"] = \"mc\";\n    Flag[\"Moldova\"] = \"md\";\n    Flag[\"Madagascar\"] = \"mg\";\n    Flag[\"Maldives\"] = \"mv\";\n    Flag[\"Mexico\"] = \"mx\";\n    Flag[\"MarshallIslands\"] = \"mh\";\n    Flag[\"NorthMacedonia\"] = \"mk\";\n    Flag[\"Mali\"] = \"ml\";\n    Flag[\"Malta\"] = \"mt\";\n    Flag[\"Myanmar\"] = \"mm\";\n    Flag[\"Montenegro\"] = \"me\";\n    Flag[\"Mongolia\"] = \"mn\";\n    Flag[\"Mozambique\"] = \"mz\";\n    Flag[\"Mauritania\"] = \"mr\";\n    Flag[\"Mauritius\"] = \"mu\";\n    Flag[\"Malawi\"] = \"mw\";\n    Flag[\"Malaysia\"] = \"my\";\n    Flag[\"Namibia\"] = \"na\";\n    Flag[\"Niger\"] = \"ne\";\n    Flag[\"Nigeria\"] = \"ng\";\n    Flag[\"Nicaragua\"] = \"ni\";\n    Flag[\"Netherlands\"] = \"nl\";\n    Flag[\"Norway\"] = \"no\";\n    Flag[\"Nepal\"] = \"np\";\n    Flag[\"Nauru\"] = \"nr\";\n    Flag[\"NewZealand\"] = \"nz\";\n    Flag[\"Oman\"] = \"om\";\n    Flag[\"Pakistan\"] = \"pk\";\n    Flag[\"Panama\"] = \"pa\";\n    Flag[\"Peru\"] = \"pe\";\n    Flag[\"Philippines\"] = \"ph\";\n    Flag[\"Palau\"] = \"pw\";\n    Flag[\"PapuaNewGuinea\"] = \"pg\";\n    Flag[\"Poland\"] = \"pl\";\n    Flag[\"FrenchPolynesia\"] = \"pf\";\n    Flag[\"NorthKorea\"] = \"kp\";\n    Flag[\"Portugal\"] = \"pt\";\n    Flag[\"Paraguay\"] = \"py\";\n    Flag[\"Qatar\"] = \"qa\";\n    Flag[\"Romania\"] = \"ro\";\n    Flag[\"Russia\"] = \"ru\";\n    Flag[\"Rwanda\"] = \"rw\";\n    Flag[\"SaudiArabia\"] = \"sa\";\n    Flag[\"Sudan\"] = \"sd\";\n    Flag[\"Senegal\"] = \"sn\";\n    Flag[\"Singapore\"] = \"sg\";\n    Flag[\"SolomonIslands\"] = \"sb\";\n    Flag[\"SierraLeone\"] = \"sl\";\n    Flag[\"ElSalvador\"] = \"sv\";\n    Flag[\"SanMarino\"] = \"sm\";\n    Flag[\"Somalia\"] = \"so\";\n    Flag[\"Serbia\"] = \"rs\";\n    Flag[\"SouthSudan\"] = \"ss\";\n    Flag[\"SaoTomeAndPrincipe\"] = \"st\";\n    Flag[\"Suriname\"] = \"sr\";\n    Flag[\"Slovakia\"] = \"sk\";\n    Flag[\"Slovenia\"] = \"si\";\n    Flag[\"Sweden\"] = \"se\";\n    Flag[\"Eswatini\"] = \"sz\";\n    Flag[\"Seychelles\"] = \"sc\";\n    Flag[\"Syria\"] = \"sy\";\n    Flag[\"Chad\"] = \"td\";\n    Flag[\"Togo\"] = \"tg\";\n    Flag[\"Thailand\"] = \"th\";\n    Flag[\"Tajikistan\"] = \"tj\";\n    Flag[\"Turkmenistan\"] = \"tm\";\n    Flag[\"TimorLeste\"] = \"tl\";\n    Flag[\"Tonga\"] = \"to\";\n    Flag[\"TrinidadAndTobago\"] = \"tt\";\n    Flag[\"Tunisia\"] = \"tn\";\n    Flag[\"Turkey\"] = \"tr\";\n    Flag[\"Tuvalu\"] = \"tv\";\n    Flag[\"Tanzania\"] = \"tz\";\n    Flag[\"Uganda\"] = \"ug\";\n    Flag[\"Ukraine\"] = \"ua\";\n    Flag[\"Uruguay\"] = \"uy\";\n    Flag[\"UnitedStates\"] = \"us\";\n    Flag[\"Uzbekistan\"] = \"uz\";\n    Flag[\"VaticanCity\"] = \"va\";\n    Flag[\"SaintVincentAndTheGrenadines\"] = \"vc\";\n    Flag[\"Venezuela\"] = \"ve\";\n    Flag[\"Vietnam\"] = \"vn\";\n    Flag[\"Vanuatu\"] = \"vu\";\n    Flag[\"Samoa\"] = \"ws\";\n    Flag[\"Yemen\"] = \"ye\";\n    Flag[\"SouthAfrica\"] = \"za\";\n    Flag[\"Zambia\"] = \"zm\";\n    Flag[\"Zimbabwe\"] = \"zw\";\n})(Flag || (Flag = {}));\n\nvar ExecutionMethod;\n(function (ExecutionMethod) {\n    ExecutionMethod[\"GET\"] = \"GET\";\n    ExecutionMethod[\"POST\"] = \"POST\";\n    ExecutionMethod[\"PUT\"] = \"PUT\";\n    ExecutionMethod[\"PATCH\"] = \"PATCH\";\n    ExecutionMethod[\"DELETE\"] = \"DELETE\";\n    ExecutionMethod[\"OPTIONS\"] = \"OPTIONS\";\n})(ExecutionMethod || (ExecutionMethod = {}));\n\nvar ImageGravity;\n(function (ImageGravity) {\n    ImageGravity[\"Center\"] = \"center\";\n    ImageGravity[\"Topleft\"] = \"top-left\";\n    ImageGravity[\"Top\"] = \"top\";\n    ImageGravity[\"Topright\"] = \"top-right\";\n    ImageGravity[\"Left\"] = \"left\";\n    ImageGravity[\"Right\"] = \"right\";\n    ImageGravity[\"Bottomleft\"] = \"bottom-left\";\n    ImageGravity[\"Bottom\"] = \"bottom\";\n    ImageGravity[\"Bottomright\"] = \"bottom-right\";\n})(ImageGravity || (ImageGravity = {}));\n\nvar ImageFormat;\n(function (ImageFormat) {\n    ImageFormat[\"Jpg\"] = \"jpg\";\n    ImageFormat[\"Jpeg\"] = \"jpeg\";\n    ImageFormat[\"Gif\"] = \"gif\";\n    ImageFormat[\"Png\"] = \"png\";\n    ImageFormat[\"Webp\"] = \"webp\";\n})(ImageFormat || (ImageFormat = {}));\n\n\n//# sourceMappingURL=sdk.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hcHB3cml0ZS9kaXN0L2VzbS9zZGsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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Q0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7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O0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9EQUFvRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9COztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQzs7QUFFa1A7QUFDclIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FwcHdyaXRlL2Rpc3QvZXNtL3Nkay5qcz9mYWUxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxuXG5jbGFzcyBTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIHN0YXRpYyBmbGF0dGVuKGRhdGEsIHByZWZpeCA9ICcnKSB7XG4gICAgICAgIGxldCBvdXRwdXQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZGF0YSkpIHtcbiAgICAgICAgICAgIGxldCBmaW5hbEtleSA9IHByZWZpeCA/IHByZWZpeCArICdbJyArIGtleSArICddJyA6IGtleTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3V0cHV0KSwgU2VydmljZS5mbGF0dGVuKHZhbHVlLCBmaW5hbEtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2ZpbmFsS2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxufVxuU2VydmljZS5DSFVOS19TSVpFID0gNSAqIDEwMjQgKiAxMDI0OyAvLyA1TUJcblxuY2xhc3MgUXVlcnkge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgYXR0cmlidXRlLCB2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlID0gYXR0cmlidXRlO1xuICAgICAgICBpZiAodmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzID0gW3ZhbHVlc107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgYXR0cmlidXRlOiB0aGlzLmF0dHJpYnV0ZSxcbiAgICAgICAgICAgIHZhbHVlczogdGhpcy52YWx1ZXMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblF1ZXJ5LmVxdWFsID0gKGF0dHJpYnV0ZSwgdmFsdWUpID0+IG5ldyBRdWVyeShcImVxdWFsXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKCk7XG5RdWVyeS5ub3RFcXVhbCA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PiBuZXcgUXVlcnkoXCJub3RFcXVhbFwiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpO1xuUXVlcnkubGVzc1RoYW4gPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT4gbmV3IFF1ZXJ5KFwibGVzc1RoYW5cIiwgYXR0cmlidXRlLCB2YWx1ZSkudG9TdHJpbmcoKTtcblF1ZXJ5Lmxlc3NUaGFuRXF1YWwgPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT4gbmV3IFF1ZXJ5KFwibGVzc1RoYW5FcXVhbFwiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpO1xuUXVlcnkuZ3JlYXRlclRoYW4gPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT4gbmV3IFF1ZXJ5KFwiZ3JlYXRlclRoYW5cIiwgYXR0cmlidXRlLCB2YWx1ZSkudG9TdHJpbmcoKTtcblF1ZXJ5LmdyZWF0ZXJUaGFuRXF1YWwgPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT4gbmV3IFF1ZXJ5KFwiZ3JlYXRlclRoYW5FcXVhbFwiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpO1xuUXVlcnkuaXNOdWxsID0gKGF0dHJpYnV0ZSkgPT4gbmV3IFF1ZXJ5KFwiaXNOdWxsXCIsIGF0dHJpYnV0ZSkudG9TdHJpbmcoKTtcblF1ZXJ5LmlzTm90TnVsbCA9IChhdHRyaWJ1dGUpID0+IG5ldyBRdWVyeShcImlzTm90TnVsbFwiLCBhdHRyaWJ1dGUpLnRvU3RyaW5nKCk7XG5RdWVyeS5iZXR3ZWVuID0gKGF0dHJpYnV0ZSwgc3RhcnQsIGVuZCkgPT4gbmV3IFF1ZXJ5KFwiYmV0d2VlblwiLCBhdHRyaWJ1dGUsIFtzdGFydCwgZW5kXSkudG9TdHJpbmcoKTtcblF1ZXJ5LnN0YXJ0c1dpdGggPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT4gbmV3IFF1ZXJ5KFwic3RhcnRzV2l0aFwiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpO1xuUXVlcnkuZW5kc1dpdGggPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT4gbmV3IFF1ZXJ5KFwiZW5kc1dpdGhcIiwgYXR0cmlidXRlLCB2YWx1ZSkudG9TdHJpbmcoKTtcblF1ZXJ5LnNlbGVjdCA9IChhdHRyaWJ1dGVzKSA9PiBuZXcgUXVlcnkoXCJzZWxlY3RcIiwgdW5kZWZpbmVkLCBhdHRyaWJ1dGVzKS50b1N0cmluZygpO1xuUXVlcnkuc2VhcmNoID0gKGF0dHJpYnV0ZSwgdmFsdWUpID0+IG5ldyBRdWVyeShcInNlYXJjaFwiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpO1xuUXVlcnkub3JkZXJEZXNjID0gKGF0dHJpYnV0ZSkgPT4gbmV3IFF1ZXJ5KFwib3JkZXJEZXNjXCIsIGF0dHJpYnV0ZSkudG9TdHJpbmcoKTtcblF1ZXJ5Lm9yZGVyQXNjID0gKGF0dHJpYnV0ZSkgPT4gbmV3IFF1ZXJ5KFwib3JkZXJBc2NcIiwgYXR0cmlidXRlKS50b1N0cmluZygpO1xuUXVlcnkuY3Vyc29yQWZ0ZXIgPSAoZG9jdW1lbnRJZCkgPT4gbmV3IFF1ZXJ5KFwiY3Vyc29yQWZ0ZXJcIiwgdW5kZWZpbmVkLCBkb2N1bWVudElkKS50b1N0cmluZygpO1xuUXVlcnkuY3Vyc29yQmVmb3JlID0gKGRvY3VtZW50SWQpID0+IG5ldyBRdWVyeShcImN1cnNvckJlZm9yZVwiLCB1bmRlZmluZWQsIGRvY3VtZW50SWQpLnRvU3RyaW5nKCk7XG5RdWVyeS5saW1pdCA9IChsaW1pdCkgPT4gbmV3IFF1ZXJ5KFwibGltaXRcIiwgdW5kZWZpbmVkLCBsaW1pdCkudG9TdHJpbmcoKTtcblF1ZXJ5Lm9mZnNldCA9IChvZmZzZXQpID0+IG5ldyBRdWVyeShcIm9mZnNldFwiLCB1bmRlZmluZWQsIG9mZnNldCkudG9TdHJpbmcoKTtcblF1ZXJ5LmNvbnRhaW5zID0gKGF0dHJpYnV0ZSwgdmFsdWUpID0+IG5ldyBRdWVyeShcImNvbnRhaW5zXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKCk7XG5RdWVyeS5vciA9IChxdWVyaWVzKSA9PiBuZXcgUXVlcnkoXCJvclwiLCB1bmRlZmluZWQsIHF1ZXJpZXMubWFwKChxdWVyeSkgPT4gSlNPTi5wYXJzZShxdWVyeSkpKS50b1N0cmluZygpO1xuUXVlcnkuYW5kID0gKHF1ZXJpZXMpID0+IG5ldyBRdWVyeShcImFuZFwiLCB1bmRlZmluZWQsIHF1ZXJpZXMubWFwKChxdWVyeSkgPT4gSlNPTi5wYXJzZShxdWVyeSkpKS50b1N0cmluZygpO1xuXG5jbGFzcyBBcHB3cml0ZUV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlID0gMCwgdHlwZSA9ICcnLCByZXNwb25zZSA9ICcnKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXBwd3JpdGVFeGNlcHRpb24nO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgfVxufVxuY2xhc3MgQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAgICAgICBlbmRwb2ludDogJ2h0dHBzOi8vY2xvdWQuYXBwd3JpdGUuaW8vdjEnLFxuICAgICAgICAgICAgZW5kcG9pbnRSZWFsdGltZTogJycsXG4gICAgICAgICAgICBwcm9qZWN0OiAnJyxcbiAgICAgICAgICAgIGp3dDogJycsXG4gICAgICAgICAgICBsb2NhbGU6ICcnLFxuICAgICAgICAgICAgc2Vzc2lvbjogJycsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IHtcbiAgICAgICAgICAgICd4LXNkay1uYW1lJzogJ1dlYicsXG4gICAgICAgICAgICAneC1zZGstcGxhdGZvcm0nOiAnY2xpZW50JyxcbiAgICAgICAgICAgICd4LXNkay1sYW5ndWFnZSc6ICd3ZWInLFxuICAgICAgICAgICAgJ3gtc2RrLXZlcnNpb24nOiAnMTUuMC4wJyxcbiAgICAgICAgICAgICdYLUFwcHdyaXRlLVJlc3BvbnNlLUZvcm1hdCc6ICcxLjUuMCcsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVhbHRpbWUgPSB7XG4gICAgICAgICAgICBzb2NrZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRpbWVvdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVybDogJycsXG4gICAgICAgICAgICBjaGFubmVsczogbmV3IFNldCgpLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uc0NvdW50ZXI6IDAsXG4gICAgICAgICAgICByZWNvbm5lY3Q6IHRydWUsXG4gICAgICAgICAgICByZWNvbm5lY3RBdHRlbXB0czogMCxcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb25uZWN0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVhbHRpbWUudGltZW91dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS50aW1lb3V0ID0gd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLmNyZWF0ZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRUaW1lb3V0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5yZWFsdGltZS5yZWNvbm5lY3RBdHRlbXB0cyA8IDU6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLnJlYWx0aW1lLnJlY29ubmVjdEF0dGVtcHRzIDwgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNTAwMDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLnJlYWx0aW1lLnJlY29ubmVjdEF0dGVtcHRzIDwgMTAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEwMDAwO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDYwMDAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjcmVhdGVTb2NrZXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFsdGltZS5jaGFubmVscy5zaXplIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLnJlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLnJlYWx0aW1lLnNvY2tldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbHMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgICAgICAgICAgY2hhbm5lbHMuc2V0KCdwcm9qZWN0JywgdGhpcy5jb25maWcucHJvamVjdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5jaGFubmVscy5mb3JFYWNoKGNoYW5uZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVscy5hcHBlbmQoJ2NoYW5uZWxzW10nLCBjaGFubmVsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmNvbmZpZy5lbmRwb2ludFJlYWx0aW1lICsgJy9yZWFsdGltZT8nICsgY2hhbm5lbHMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAodXJsICE9PSB0aGlzLnJlYWx0aW1lLnVybCB8fCAvLyBDaGVjayBpZiBVUkwgaXMgcHJlc2VudFxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5yZWFsdGltZS5zb2NrZXQgfHwgLy8gQ2hlY2sgaWYgV2ViU29ja2V0IGhhcyBub3QgYmVlbiBjcmVhdGVkXG4gICAgICAgICAgICAgICAgICAgICgoX2IgPSB0aGlzLnJlYWx0aW1lLnNvY2tldCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlYWR5U3RhdGUpID4gV2ViU29ja2V0Lk9QRU4gLy8gQ2hlY2sgaWYgV2ViU29ja2V0IGlzIENMT1NJTkcgKDMpIG9yIENMT1NFRCAoNClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhbHRpbWUuc29ja2V0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoKF9jID0gdGhpcy5yZWFsdGltZS5zb2NrZXQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZWFkeVN0YXRlKSA8IFdlYlNvY2tldC5DTE9TSU5HIC8vIENsb3NlIFdlYlNvY2tldCBpZiBpdCBpcyBDT05ORUNUSU5HICgwKSBvciBPUEVOICgxKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUucmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUudXJsID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLnNvY2tldCA9IG5ldyBXZWJTb2NrZXQodXJsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMucmVhbHRpbWUub25NZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIF9ldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVhbHRpbWUucmVjb25uZWN0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCgoX2IgPSAoX2EgPSB0aGlzLnJlYWx0aW1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFzdE1lc3NhZ2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50eXBlKSA9PT0gJ2Vycm9yJyAmJiAvLyBDaGVjayBpZiBsYXN0IG1lc3NhZ2Ugd2FzIG9mIHR5cGUgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfYyA9IHRoaXMucmVhbHRpbWUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sYXN0TWVzc2FnZS5kYXRhKS5jb2RlID09PSAxMDA4IC8vIENoZWNrIGZvciBwb2xpY3kgdmlvbGF0aW9uIDEwMDhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5yZWNvbm5lY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLnJlYWx0aW1lLmdldFRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFJlYWx0aW1lIGdvdCBkaXNjb25uZWN0ZWQuIFJlY29ubmVjdCB3aWxsIGJlIGF0dGVtcHRlZCBpbiAke3RpbWVvdXQgLyAxMDAwfSBzZWNvbmRzLmAsIGV2ZW50LnJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLnJlY29ubmVjdEF0dGVtcHRzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5jcmVhdGVTb2NrZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25NZXNzYWdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLmxhc3RNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29va2llID0gSlNPTi5wYXJzZSgoX2EgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2Nvb2tpZUZhbGxiYWNrJykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd7fScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBjb29raWUgPT09IG51bGwgfHwgY29va2llID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb29raWVbYGFfc2Vzc2lvbl8ke3RoaXMuY29uZmlnLnByb2plY3R9YF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZURhdGEgPSBtZXNzYWdlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlc3Npb24gJiYgIW1lc3NhZ2VEYXRhLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gdGhpcy5yZWFsdGltZS5zb2NrZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZW5kKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhdXRoZW50aWNhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXZlbnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhID0gbWVzc2FnZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNTdWJzY3JpYmVkID0gZGF0YS5jaGFubmVscy5zb21lKGNoYW5uZWwgPT4gdGhpcy5yZWFsdGltZS5jaGFubmVscy5oYXMoY2hhbm5lbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU3Vic2NyaWJlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5zdWJzY3JpcHRpb25zLmZvckVhY2goc3Vic2NyaXB0aW9uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmNoYW5uZWxzLnNvbWUoY2hhbm5lbCA9PiBzdWJzY3JpcHRpb24uY2hhbm5lbHMuaW5jbHVkZXMoY2hhbm5lbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzdWJzY3JpcHRpb24uY2FsbGJhY2soZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbWVzc2FnZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGVhblVwOiBjaGFubmVscyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5jaGFubmVscy5mb3JFYWNoKGNoYW5uZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbHMuaW5jbHVkZXMoY2hhbm5lbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IEFycmF5LmZyb20odGhpcy5yZWFsdGltZS5zdWJzY3JpcHRpb25zKS5zb21lKChbX2tleSwgc3Vic2NyaXB0aW9uXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb24uY2hhbm5lbHMuaW5jbHVkZXMoY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLmRlbGV0ZShjaGFubmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgRW5kcG9pbnRcbiAgICAgKlxuICAgICAqIFlvdXIgcHJvamVjdCBlbmRwb2ludFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVuZHBvaW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBzZXRFbmRwb2ludChlbmRwb2ludCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5lbmRwb2ludCA9IGVuZHBvaW50O1xuICAgICAgICB0aGlzLmNvbmZpZy5lbmRwb2ludFJlYWx0aW1lID0gdGhpcy5jb25maWcuZW5kcG9pbnRSZWFsdGltZSB8fCB0aGlzLmNvbmZpZy5lbmRwb2ludC5yZXBsYWNlKCdodHRwczovLycsICd3c3M6Ly8nKS5yZXBsYWNlKCdodHRwOi8vJywgJ3dzOi8vJyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgUmVhbHRpbWUgRW5kcG9pbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludFJlYWx0aW1lXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBzZXRFbmRwb2ludFJlYWx0aW1lKGVuZHBvaW50UmVhbHRpbWUpIHtcbiAgICAgICAgdGhpcy5jb25maWcuZW5kcG9pbnRSZWFsdGltZSA9IGVuZHBvaW50UmVhbHRpbWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgUHJvamVjdFxuICAgICAqXG4gICAgICogWW91ciBwcm9qZWN0IElEXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuICAgIHNldFByb2plY3QodmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzWydYLUFwcHdyaXRlLVByb2plY3QnXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNvbmZpZy5wcm9qZWN0ID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgSldUXG4gICAgICpcbiAgICAgKiBZb3VyIHNlY3JldCBKU09OIFdlYiBUb2tlblxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHN0cmluZ1xuICAgICAqXG4gICAgICogQHJldHVybiB7dGhpc31cbiAgICAgKi9cbiAgICBzZXRKV1QodmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzWydYLUFwcHdyaXRlLUpXVCddID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY29uZmlnLmp3dCA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IExvY2FsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHN0cmluZ1xuICAgICAqXG4gICAgICogQHJldHVybiB7dGhpc31cbiAgICAgKi9cbiAgICBzZXRMb2NhbGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzWydYLUFwcHdyaXRlLUxvY2FsZSddID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY29uZmlnLmxvY2FsZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IFNlc3Npb25cbiAgICAgKlxuICAgICAqIFRoZSB1c2VyIHNlc3Npb24gdG8gYXV0aGVudGljYXRlIHdpdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBzdHJpbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3RoaXN9XG4gICAgICovXG4gICAgc2V0U2Vzc2lvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLmhlYWRlcnNbJ1gtQXBwd3JpdGUtU2Vzc2lvbiddID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY29uZmlnLnNlc3Npb24gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gQXBwd3JpdGUgZXZlbnRzIGFuZCBwYXNzZXMgeW91IHRoZSBwYXlsb2FkIGluIHJlYWx0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGNoYW5uZWxzXG4gICAgICogQ2hhbm5lbCB0byBzdWJzY3JpYmUgLSBwYXNzIGEgc2luZ2xlIGNoYW5uZWwgYXMgYSBzdHJpbmcgb3IgbXVsdGlwbGUgd2l0aCBhbiBhcnJheSBvZiBzdHJpbmdzLlxuICAgICAqXG4gICAgICogUG9zc2libGUgY2hhbm5lbHMgYXJlOlxuICAgICAqIC0gYWNjb3VudFxuICAgICAqIC0gY29sbGVjdGlvbnNcbiAgICAgKiAtIGNvbGxlY3Rpb25zLltJRF1cbiAgICAgKiAtIGNvbGxlY3Rpb25zLltJRF0uZG9jdW1lbnRzXG4gICAgICogLSBkb2N1bWVudHNcbiAgICAgKiAtIGRvY3VtZW50cy5bSURdXG4gICAgICogLSBmaWxlc1xuICAgICAqIC0gZmlsZXMuW0lEXVxuICAgICAqIC0gZXhlY3V0aW9uc1xuICAgICAqIC0gZXhlY3V0aW9ucy5bSURdXG4gICAgICogLSBmdW5jdGlvbnMuW0lEXVxuICAgICAqIC0gdGVhbXNcbiAgICAgKiAtIHRlYW1zLltJRF1cbiAgICAgKiAtIG1lbWJlcnNoaXBzXG4gICAgICogLSBtZW1iZXJzaGlwcy5bSURdXG4gICAgICogQHBhcmFtIHsocGF5bG9hZDogUmVhbHRpbWVNZXNzYWdlKSA9PiB2b2lkfSBjYWxsYmFjayBJcyBjYWxsZWQgb24gZXZlcnkgcmVhbHRpbWUgdXBkYXRlLlxuICAgICAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfSBVbnN1YnNjcmliZXMgZnJvbSBldmVudHMuXG4gICAgICovXG4gICAgc3Vic2NyaWJlKGNoYW5uZWxzLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgY2hhbm5lbEFycmF5ID0gdHlwZW9mIGNoYW5uZWxzID09PSAnc3RyaW5nJyA/IFtjaGFubmVsc10gOiBjaGFubmVscztcbiAgICAgICAgY2hhbm5lbEFycmF5LmZvckVhY2goY2hhbm5lbCA9PiB0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLmFkZChjaGFubmVsKSk7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSB0aGlzLnJlYWx0aW1lLnN1YnNjcmlwdGlvbnNDb3VudGVyKys7XG4gICAgICAgIHRoaXMucmVhbHRpbWUuc3Vic2NyaXB0aW9ucy5zZXQoY291bnRlciwge1xuICAgICAgICAgICAgY2hhbm5lbHM6IGNoYW5uZWxBcnJheSxcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3QoKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuc3Vic2NyaXB0aW9ucy5kZWxldGUoY291bnRlcik7XG4gICAgICAgICAgICB0aGlzLnJlYWx0aW1lLmNsZWFuVXAoY2hhbm5lbEFycmF5KTtcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjYWxsKG1ldGhvZCwgdXJsLCBoZWFkZXJzID0ge30sIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycywgaGVhZGVycyk7XG4gICAgICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb29raWVGYWxsYmFjayA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnY29va2llRmFsbGJhY2snKTtcbiAgICAgICAgICAgICAgICBpZiAoY29va2llRmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snWC1GYWxsYmFjay1Db29raWVzJ10gPSBjb29raWVGYWxsYmFjaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKFNlcnZpY2UuZmxhdHRlbihwYXJhbXMpKSkge1xuICAgICAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FwcGxpY2F0aW9uL2pzb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtdWx0aXBhcnQvZm9ybS1kYXRhJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1zW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1trZXldLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoa2V5ICsgJ1tdJywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIHBhcmFtc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmJvZHkgPSBmb3JtRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBoZWFkZXJzWydjb250ZW50LXR5cGUnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZmV0Y2godXJsLnRvU3RyaW5nKCksIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmICgoX2EgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB5aWVsZCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogeWllbGQgcmVzcG9uc2UudGV4dCgpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICg0MDAgPD0gcmVzcG9uc2Uuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbihkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEubWVzc2FnZSwgcmVzcG9uc2Uuc3RhdHVzLCBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEudHlwZSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvb2tpZUZhbGxiYWNrID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ1gtRmFsbGJhY2stQ29va2llcycpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYWxTdG9yYWdlICYmIGNvb2tpZUZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLndhcm4oJ0FwcHdyaXRlIGlzIHVzaW5nIGxvY2FsU3RvcmFnZSBmb3Igc2Vzc2lvbiBtYW5hZ2VtZW50LiBJbmNyZWFzZSB5b3VyIHNlY3VyaXR5IGJ5IGFkZGluZyBhIGN1c3RvbSBkb21haW4gYXMgeW91ciBBUEkgZW5kcG9pbnQuJyk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnY29va2llRmFsbGJhY2snLCBjb29raWVGYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEFwcHdyaXRlRXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbihlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIEFjY291bnQgZXh0ZW5kcyBTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgc3VwZXIoY2xpZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFjY291bnRcbiAgICAgKlxuICAgICAqIEdldCB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50JztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFjY291bnRcbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIGFsbG93IGEgbmV3IHVzZXIgdG8gcmVnaXN0ZXIgYSBuZXcgYWNjb3VudCBpbiB5b3VyXG4gICAgICogcHJvamVjdC4gQWZ0ZXIgdGhlIHVzZXIgcmVnaXN0cmF0aW9uIGNvbXBsZXRlcyBzdWNjZXNzZnVsbHksIHlvdSBjYW4gdXNlXG4gICAgICogdGhlXG4gICAgICogWy9hY2NvdW50L3ZlcmZpY2F0aW9uXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlVmVyaWZpY2F0aW9uKVxuICAgICAqIHJvdXRlIHRvIHN0YXJ0IHZlcmlmeWluZyB0aGUgdXNlciBlbWFpbCBhZGRyZXNzLiBUbyBhbGxvdyB0aGUgbmV3IHVzZXIgdG9cbiAgICAgKiBsb2dpbiB0byB0aGVpciBuZXcgYWNjb3VudCwgeW91IG5lZWQgdG8gY3JlYXRlIGEgbmV3IFthY2NvdW50XG4gICAgICogc2Vzc2lvbl0oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2NyZWF0ZUVtYWlsU2Vzc2lvbikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGNyZWF0ZSh1c2VySWQsIGVtYWlsLCBwYXNzd29yZCwgbmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50JztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkJ10gPSBwYXNzd29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGVtYWlsXG4gICAgICpcbiAgICAgKiBVcGRhdGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyIGFjY291bnQgZW1haWwgYWRkcmVzcy4gQWZ0ZXIgY2hhbmdpbmcgdXNlclxuICAgICAqIGFkZHJlc3MsIHRoZSB1c2VyIGNvbmZpcm1hdGlvbiBzdGF0dXMgd2lsbCBnZXQgcmVzZXQuIEEgbmV3IGNvbmZpcm1hdGlvblxuICAgICAqIGVtYWlsIGlzIG5vdCBzZW50IGF1dG9tYXRpY2FsbHkgaG93ZXZlciB5b3UgY2FuIHVzZSB0aGUgc2VuZCBjb25maXJtYXRpb25cbiAgICAgKiBlbWFpbCBlbmRwb2ludCBhZ2FpbiB0byBzZW5kIHRoZSBjb25maXJtYXRpb24gZW1haWwuIEZvciBzZWN1cml0eSBtZWFzdXJlcyxcbiAgICAgKiB1c2VyIHBhc3N3b3JkIGlzIHJlcXVpcmVkIHRvIGNvbXBsZXRlIHRoaXMgcmVxdWVzdC5cbiAgICAgKiBUaGlzIGVuZHBvaW50IGNhbiBhbHNvIGJlIHVzZWQgdG8gY29udmVydCBhbiBhbm9ueW1vdXMgYWNjb3VudCB0byBhIG5vcm1hbFxuICAgICAqIG9uZSwgYnkgcGFzc2luZyBhbiBlbWFpbCBhZGRyZXNzIGFuZCBhIG5ldyBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICB1cGRhdGVFbWFpbChlbWFpbCwgcGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJlbWFpbFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9lbWFpbCc7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgSWRlbnRpdGllc1xuICAgICAqXG4gICAgICogR2V0IHRoZSBsaXN0IG9mIGlkZW50aXRpZXMgZm9yIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICBsaXN0SWRlbnRpdGllcyhxdWVyaWVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L2lkZW50aXRpZXMnO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBpZGVudGl0eVxuICAgICAqXG4gICAgICogRGVsZXRlIGFuIGlkZW50aXR5IGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpdHlJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgZGVsZXRlSWRlbnRpdHkoaWRlbnRpdHlJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpZGVudGl0eUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiaWRlbnRpdHlJZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L2lkZW50aXRpZXMve2lkZW50aXR5SWR9Jy5yZXBsYWNlKCd7aWRlbnRpdHlJZH0nLCBpZGVudGl0eUlkKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIEpXVFxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZW5kcG9pbnQgdG8gY3JlYXRlIGEgSlNPTiBXZWIgVG9rZW4uIFlvdSBjYW4gdXNlIHRoZSByZXN1bHRpbmcgSldUXG4gICAgICogdG8gYXV0aGVudGljYXRlIG9uIGJlaGFsZiBvZiB0aGUgY3VycmVudCB1c2VyIHdoZW4gd29ya2luZyB3aXRoIHRoZVxuICAgICAqIEFwcHdyaXRlIHNlcnZlci1zaWRlIEFQSSBhbmQgU0RLcy4gVGhlIEpXVCBzZWNyZXQgaXMgdmFsaWQgZm9yIDE1IG1pbnV0ZXNcbiAgICAgKiBmcm9tIGl0cyBjcmVhdGlvbiBhbmQgd2lsbCBiZSBpbnZhbGlkIGlmIHRoZSB1c2VyIHdpbGwgbG9nb3V0IGluIHRoYXQgdGltZVxuICAgICAqIGZyYW1lLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICBjcmVhdGVKV1QoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L2p3dCc7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGxvZ3NcbiAgICAgKlxuICAgICAqIEdldCB0aGUgbGlzdCBvZiBsYXRlc3Qgc2VjdXJpdHkgYWN0aXZpdHkgbG9ncyBmb3IgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW5cbiAgICAgKiB1c2VyLiBFYWNoIGxvZyByZXR1cm5zIHVzZXIgSVAgYWRkcmVzcywgbG9jYXRpb24gYW5kIGRhdGUgYW5kIHRpbWUgb2YgbG9nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgbGlzdExvZ3MocXVlcmllcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9sb2dzJztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgTUZBXG4gICAgICpcbiAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBNRkEgb24gYW4gYWNjb3VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbWZhXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICB1cGRhdGVNRkEobWZhKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1mYSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1mYVwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYSc7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1mYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydtZmEnXSA9IG1mYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgQXV0aGVudGljYXRvclxuICAgICAqXG4gICAgICogQWRkIGFuIGF1dGhlbnRpY2F0b3IgYXBwIHRvIGJlIHVzZWQgYXMgYW4gTUZBIGZhY3Rvci4gVmVyaWZ5IHRoZVxuICAgICAqIGF1dGhlbnRpY2F0b3IgdXNpbmcgdGhlIFt2ZXJpZnlcbiAgICAgKiBhdXRoZW50aWNhdG9yXSgvZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCN1cGRhdGVNZmFBdXRoZW50aWNhdG9yKVxuICAgICAqIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXV0aGVudGljYXRvclR5cGV9IHR5cGVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGNyZWF0ZU1mYUF1dGhlbnRpY2F0b3IodHlwZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidHlwZVwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9hdXRoZW50aWNhdG9ycy97dHlwZX0nLnJlcGxhY2UoJ3t0eXBlfScsIHR5cGUpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZ5IEF1dGhlbnRpY2F0b3JcbiAgICAgKlxuICAgICAqIFZlcmlmeSBhbiBhdXRoZW50aWNhdG9yIGFwcCBhZnRlciBhZGRpbmcgaXQgdXNpbmcgdGhlIFthZGRcbiAgICAgKiBhdXRoZW50aWNhdG9yXSgvZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNjcmVhdGVNZmFBdXRoZW50aWNhdG9yKVxuICAgICAqIG1ldGhvZC4gYWRkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0F1dGhlbnRpY2F0b3JUeXBlfSB0eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG90cFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgdXBkYXRlTWZhQXV0aGVudGljYXRvcih0eXBlLCBvdHApIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInR5cGVcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvdHAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJvdHBcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvYXV0aGVudGljYXRvcnMve3R5cGV9Jy5yZXBsYWNlKCd7dHlwZX0nLCB0eXBlKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3RwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ290cCddID0gb3RwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgQXV0aGVudGljYXRvclxuICAgICAqXG4gICAgICogRGVsZXRlIGFuIGF1dGhlbnRpY2F0b3IgZm9yIGEgdXNlciBieSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXV0aGVudGljYXRvclR5cGV9IHR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3RwXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICBkZWxldGVNZmFBdXRoZW50aWNhdG9yKHR5cGUsIG90cCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidHlwZVwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG90cCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm90cFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9hdXRoZW50aWNhdG9ycy97dHlwZX0nLnJlcGxhY2UoJ3t0eXBlfScsIHR5cGUpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvdHAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsnb3RwJ10gPSBvdHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSAyRkEgQ2hhbGxlbmdlXG4gICAgICpcbiAgICAgKiBCZWdpbiB0aGUgcHJvY2VzcyBvZiBNRkEgdmVyaWZpY2F0aW9uIGFmdGVyIHNpZ24taW4uIEZpbmlzaCB0aGUgZmxvdyB3aXRoXG4gICAgICogW3VwZGF0ZU1mYUNoYWxsZW5nZV0oL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjdXBkYXRlTWZhQ2hhbGxlbmdlKVxuICAgICAqIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXV0aGVudGljYXRpb25GYWN0b3J9IGZhY3RvclxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgY3JlYXRlTWZhQ2hhbGxlbmdlKGZhY3Rvcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmYWN0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmYWN0b3JcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvY2hhbGxlbmdlJztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmFjdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ2ZhY3RvciddID0gZmFjdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIE1GQSBDaGFsbGVuZ2UgKGNvbmZpcm1hdGlvbilcbiAgICAgKlxuICAgICAqIENvbXBsZXRlIHRoZSBNRkEgY2hhbGxlbmdlIGJ5IHByb3ZpZGluZyB0aGUgb25lLXRpbWUgcGFzc3dvcmQuIEZpbmlzaCB0aGVcbiAgICAgKiBwcm9jZXNzIG9mIE1GQSB2ZXJpZmljYXRpb24gYnkgcHJvdmlkaW5nIHRoZSBvbmUtdGltZSBwYXNzd29yZC4gVG8gYmVnaW5cbiAgICAgKiB0aGUgZmxvdywgdXNlXG4gICAgICogW2NyZWF0ZU1mYUNoYWxsZW5nZV0oL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlTWZhQ2hhbGxlbmdlKVxuICAgICAqIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFsbGVuZ2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvdHBcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIHVwZGF0ZU1mYUNoYWxsZW5nZShjaGFsbGVuZ2VJZCwgb3RwKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoYWxsZW5nZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY2hhbGxlbmdlSWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvdHAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJvdHBcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvY2hhbGxlbmdlJztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbGxlbmdlSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsnY2hhbGxlbmdlSWQnXSA9IGNoYWxsZW5nZUlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvdHAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsnb3RwJ10gPSBvdHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgRmFjdG9yc1xuICAgICAqXG4gICAgICogTGlzdCB0aGUgZmFjdG9ycyBhdmFpbGFibGUgb24gdGhlIGFjY291bnQgdG8gYmUgdXNlZCBhcyBhIE1GQSBjaGFsbGFuZ2UuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGxpc3RNZmFGYWN0b3JzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvZmFjdG9ycyc7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBNRkEgUmVjb3ZlcnkgQ29kZXNcbiAgICAgKlxuICAgICAqIEdldCByZWNvdmVyeSBjb2RlcyB0aGF0IGNhbiBiZSB1c2VkIGFzIGJhY2t1cCBmb3IgTUZBIGZsb3cuIEJlZm9yZSBnZXR0aW5nXG4gICAgICogY29kZXMsIHRoZXkgbXVzdCBiZSBnZW5lcmF0ZWQgdXNpbmdcbiAgICAgKiBbY3JlYXRlTWZhUmVjb3ZlcnlDb2Rlc10oL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlTWZhUmVjb3ZlcnlDb2RlcylcbiAgICAgKiBtZXRob2QuIEFuIE9UUCBjaGFsbGVuZ2UgaXMgcmVxdWlyZWQgdG8gcmVhZCByZWNvdmVyeSBjb2Rlcy5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgZ2V0TWZhUmVjb3ZlcnlDb2RlcygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL3JlY292ZXJ5LWNvZGVzJztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIE1GQSBSZWNvdmVyeSBDb2Rlc1xuICAgICAqXG4gICAgICogR2VuZXJhdGUgcmVjb3ZlcnkgY29kZXMgYXMgYmFja3VwIGZvciBNRkEgZmxvdy4gSXQncyByZWNvbW1lbmRlZCB0b1xuICAgICAqIGdlbmVyYXRlIGFuZCBzaG93IHRoZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgdXNlciBzdWNjZXNzZnVsbHkgYWRkcyB0aGVpclxuICAgICAqIGF1dGhlaHRpY2F0b3IuIFJlY292ZXJ5IGNvZGVzIGNhbiBiZSB1c2VkIGFzIGEgTUZBIHZlcmlmaWNhdGlvbiB0eXBlIGluXG4gICAgICogW2NyZWF0ZU1mYUNoYWxsZW5nZV0oL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlTWZhQ2hhbGxlbmdlKVxuICAgICAqIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgY3JlYXRlTWZhUmVjb3ZlcnlDb2RlcygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL3JlY292ZXJ5LWNvZGVzJztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2VuZXJhdGUgTUZBIFJlY292ZXJ5IENvZGVzXG4gICAgICpcbiAgICAgKiBSZWdlbmVyYXRlIHJlY292ZXJ5IGNvZGVzIHRoYXQgY2FuIGJlIHVzZWQgYXMgYmFja3VwIGZvciBNRkEgZmxvdy4gQmVmb3JlXG4gICAgICogcmVnZW5lcmF0aW5nIGNvZGVzLCB0aGV5IG11c3QgYmUgZmlyc3QgZ2VuZXJhdGVkIHVzaW5nXG4gICAgICogW2NyZWF0ZU1mYVJlY292ZXJ5Q29kZXNdKC9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2NyZWF0ZU1mYVJlY292ZXJ5Q29kZXMpXG4gICAgICogbWV0aG9kLiBBbiBPVFAgY2hhbGxlbmdlIGlzIHJlcXVpcmVkIHRvIHJlZ2VucmVhdGUgcmVjb3ZlcnkgY29kZXMuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIHVwZGF0ZU1mYVJlY292ZXJ5Q29kZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9yZWNvdmVyeS1jb2Rlcyc7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIG5hbWVcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIgYWNjb3VudCBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIHVwZGF0ZU5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L25hbWUnO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHBhc3N3b3JkXG4gICAgICpcbiAgICAgKiBVcGRhdGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyIHBhc3N3b3JkLiBGb3IgdmFsaWRhdGlvbiwgdXNlciBpcyByZXF1aXJlZFxuICAgICAqIHRvIHBhc3MgaW4gdGhlIG5ldyBwYXNzd29yZCwgYW5kIHRoZSBvbGQgcGFzc3dvcmQuIEZvciB1c2VycyBjcmVhdGVkIHdpdGhcbiAgICAgKiBPQXV0aCwgVGVhbSBJbnZpdGVzIGFuZCBNYWdpYyBVUkwsIG9sZFBhc3N3b3JkIGlzIG9wdGlvbmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9sZFBhc3N3b3JkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICB1cGRhdGVQYXNzd29yZChwYXNzd29yZCwgb2xkUGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Bhc3N3b3JkJztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbGRQYXNzd29yZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydvbGRQYXNzd29yZCddID0gb2xkUGFzc3dvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHBob25lXG4gICAgICpcbiAgICAgKiBVcGRhdGUgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlcidzIHBob25lIG51bWJlci4gQWZ0ZXIgdXBkYXRpbmcgdGhlXG4gICAgICogcGhvbmUgbnVtYmVyLCB0aGUgcGhvbmUgdmVyaWZpY2F0aW9uIHN0YXR1cyB3aWxsIGJlIHJlc2V0LiBBIGNvbmZpcm1hdGlvblxuICAgICAqIFNNUyBpcyBub3Qgc2VudCBhdXRvbWF0aWNhbGx5LCBob3dldmVyIHlvdSBjYW4gdXNlIHRoZSBbUE9TVFxuICAgICAqIC9hY2NvdW50L3ZlcmlmaWNhdGlvbi9waG9uZV0oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2NyZWF0ZVBob25lVmVyaWZpY2F0aW9uKVxuICAgICAqIGVuZHBvaW50IHRvIHNlbmQgYSBjb25maXJtYXRpb24gU01TLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBob25lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICB1cGRhdGVQaG9uZShwaG9uZSwgcGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGhvbmUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwaG9uZVwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9waG9uZSc7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBob25lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3Bob25lJ10gPSBwaG9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhY2NvdW50IHByZWZlcmVuY2VzXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIHByZWZlcmVuY2VzIGFzIGEga2V5LXZhbHVlIG9iamVjdCBmb3IgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlci5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgZ2V0UHJlZnMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3ByZWZzJztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHByZWZlcmVuY2VzXG4gICAgICpcbiAgICAgKiBVcGRhdGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyIGFjY291bnQgcHJlZmVyZW5jZXMuIFRoZSBvYmplY3QgeW91IHBhc3MgaXNcbiAgICAgKiBzdG9yZWQgYXMgaXMsIGFuZCByZXBsYWNlcyBhbnkgcHJldmlvdXMgdmFsdWUuIFRoZSBtYXhpbXVtIGFsbG93ZWQgcHJlZnNcbiAgICAgKiBzaXplIGlzIDY0a0IgYW5kIHRocm93cyBlcnJvciBpZiBleGNlZWRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFydGlhbDxQcmVmZXJlbmNlcz59IHByZWZzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICB1cGRhdGVQcmVmcyhwcmVmcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmVmcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByZWZzXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvcHJlZnMnO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmVmcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydwcmVmcyddID0gcHJlZnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHBhc3N3b3JkIHJlY292ZXJ5XG4gICAgICpcbiAgICAgKiBTZW5kcyB0aGUgdXNlciBhbiBlbWFpbCB3aXRoIGEgdGVtcG9yYXJ5IHNlY3JldCBrZXkgZm9yIHBhc3N3b3JkIHJlc2V0LlxuICAgICAqIFdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBjb25maXJtYXRpb24gbGluayBoZSBpcyByZWRpcmVjdGVkIGJhY2sgdG8geW91clxuICAgICAqIGFwcCBwYXNzd29yZCByZXNldCBVUkwgd2l0aCB0aGUgc2VjcmV0IGtleSBhbmQgZW1haWwgYWRkcmVzcyB2YWx1ZXNcbiAgICAgKiBhdHRhY2hlZCB0byB0aGUgVVJMIHF1ZXJ5IHN0cmluZy4gVXNlIHRoZSBxdWVyeSBzdHJpbmcgcGFyYW1zIHRvIHN1Ym1pdCBhXG4gICAgICogcmVxdWVzdCB0byB0aGUgW1BVVFxuICAgICAqIC9hY2NvdW50L3JlY292ZXJ5XShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjdXBkYXRlUmVjb3ZlcnkpXG4gICAgICogZW5kcG9pbnQgdG8gY29tcGxldGUgdGhlIHByb2Nlc3MuIFRoZSB2ZXJpZmljYXRpb24gbGluayBzZW50IHRvIHRoZSB1c2VyJ3NcbiAgICAgKiBlbWFpbCBhZGRyZXNzIGlzIHZhbGlkIGZvciAxIGhvdXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW1haWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICBjcmVhdGVSZWNvdmVyeShlbWFpbCwgdXJsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVtYWlsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZW1haWxcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1cmxcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9yZWNvdmVyeSc7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3VybCddID0gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHBhc3N3b3JkIHJlY292ZXJ5IChjb25maXJtYXRpb24pXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBjb21wbGV0ZSB0aGUgdXNlciBhY2NvdW50IHBhc3N3b3JkIHJlc2V0LiBCb3RoIHRoZVxuICAgICAqICoqdXNlcklkKiogYW5kICoqc2VjcmV0KiogYXJndW1lbnRzIHdpbGwgYmUgcGFzc2VkIGFzIHF1ZXJ5IHBhcmFtZXRlcnMgdG9cbiAgICAgKiB0aGUgcmVkaXJlY3QgVVJMIHlvdSBoYXZlIHByb3ZpZGVkIHdoZW4gc2VuZGluZyB5b3VyIHJlcXVlc3QgdG8gdGhlIFtQT1NUXG4gICAgICogL2FjY291bnQvcmVjb3ZlcnldKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNjcmVhdGVSZWNvdmVyeSlcbiAgICAgKiBlbmRwb2ludC5cbiAgICAgKlxuICAgICAqIFBsZWFzZSBub3RlIHRoYXQgaW4gb3JkZXIgdG8gYXZvaWQgYSBbUmVkaXJlY3RcbiAgICAgKiBBdHRhY2tdKGh0dHBzOi8vZ2l0aHViLmNvbS9PV0FTUC9DaGVhdFNoZWV0U2VyaWVzL2Jsb2IvbWFzdGVyL2NoZWF0c2hlZXRzL1VudmFsaWRhdGVkX1JlZGlyZWN0c19hbmRfRm9yd2FyZHNfQ2hlYXRfU2hlZXQubWQpXG4gICAgICogdGhlIG9ubHkgdmFsaWQgcmVkaXJlY3QgVVJMcyBhcmUgdGhlIG9uZXMgZnJvbSBkb21haW5zIHlvdSBoYXZlIHNldCB3aGVuXG4gICAgICogYWRkaW5nIHlvdXIgcGxhdGZvcm1zIGluIHRoZSBjb25zb2xlIGludGVyZmFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VjcmV0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICB1cGRhdGVSZWNvdmVyeSh1c2VySWQsIHNlY3JldCwgcGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2VjcmV0XCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3JlY292ZXJ5JztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsnc2VjcmV0J10gPSBzZWNyZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkJ10gPSBwYXNzd29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgncHV0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBzZXNzaW9uc1xuICAgICAqXG4gICAgICogR2V0IHRoZSBsaXN0IG9mIGFjdGl2ZSBzZXNzaW9ucyBhY3Jvc3MgZGlmZmVyZW50IGRldmljZXMgZm9yIHRoZSBjdXJyZW50bHlcbiAgICAgKiBsb2dnZWQgaW4gdXNlci5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgbGlzdFNlc3Npb25zKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucyc7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBzZXNzaW9uc1xuICAgICAqXG4gICAgICogRGVsZXRlIGFsbCBzZXNzaW9ucyBmcm9tIHRoZSB1c2VyIGFjY291bnQgYW5kIHJlbW92ZSBhbnkgc2Vzc2lvbnMgY29va2llc1xuICAgICAqIGZyb20gdGhlIGVuZCBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGRlbGV0ZVNlc3Npb25zKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucyc7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbm9ueW1vdXMgc2Vzc2lvblxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZW5kcG9pbnQgdG8gYWxsb3cgYSBuZXcgdXNlciB0byByZWdpc3RlciBhbiBhbm9ueW1vdXMgYWNjb3VudCBpblxuICAgICAqIHlvdXIgcHJvamVjdC4gVGhpcyByb3V0ZSB3aWxsIGFsc28gY3JlYXRlIGEgbmV3IHNlc3Npb24gZm9yIHRoZSB1c2VyLiBUb1xuICAgICAqIGFsbG93IHRoZSBuZXcgdXNlciB0byBjb252ZXJ0IGFuIGFub255bW91cyBhY2NvdW50IHRvIGEgbm9ybWFsIGFjY291bnQsIHlvdVxuICAgICAqIG5lZWQgdG8gdXBkYXRlIGl0cyBbZW1haWwgYW5kXG4gICAgICogcGFzc3dvcmRdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCN1cGRhdGVFbWFpbClcbiAgICAgKiBvciBjcmVhdGUgYW4gW09BdXRoMlxuICAgICAqIHNlc3Npb25dKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNDcmVhdGVPQXV0aDJTZXNzaW9uKS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgY3JlYXRlQW5vbnltb3VzU2Vzc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvc2Vzc2lvbnMvYW5vbnltb3VzJztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBlbWFpbCBwYXNzd29yZCBzZXNzaW9uXG4gICAgICpcbiAgICAgKiBBbGxvdyB0aGUgdXNlciB0byBsb2dpbiBpbnRvIHRoZWlyIGFjY291bnQgYnkgcHJvdmlkaW5nIGEgdmFsaWQgZW1haWwgYW5kXG4gICAgICogcGFzc3dvcmQgY29tYmluYXRpb24uIFRoaXMgcm91dGUgd2lsbCBjcmVhdGUgYSBuZXcgc2Vzc2lvbiBmb3IgdGhlIHVzZXIuXG4gICAgICpcbiAgICAgKiBBIHVzZXIgaXMgbGltaXRlZCB0byAxMCBhY3RpdmUgc2Vzc2lvbnMgYXQgYSB0aW1lIGJ5IGRlZmF1bHQuIFtMZWFybiBtb3JlXG4gICAgICogYWJvdXQgc2Vzc2lvblxuICAgICAqIGxpbWl0c10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL2F1dGhlbnRpY2F0aW9uLXNlY3VyaXR5I2xpbWl0cykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW1haWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGNyZWF0ZUVtYWlsUGFzc3dvcmRTZXNzaW9uKGVtYWlsLCBwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zL2VtYWlsJztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsnZW1haWwnXSA9IGVtYWlsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZCddID0gcGFzc3dvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgbWFnaWMgVVJMIHNlc3Npb25cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIGNyZWF0ZSBhIHNlc3Npb24gZnJvbSB0b2tlbi4gUHJvdmlkZSB0aGUgKip1c2VySWQqKlxuICAgICAqIGFuZCAqKnNlY3JldCoqIHBhcmFtZXRlcnMgZnJvbSB0aGUgc3VjY2Vzc2Z1bCByZXNwb25zZSBvZiBhdXRoZW50aWNhdGlvblxuICAgICAqIGZsb3dzIGluaXRpYXRlZCBieSB0b2tlbiBjcmVhdGlvbi4gRm9yIGV4YW1wbGUsIG1hZ2ljIFVSTCBhbmQgcGhvbmUgbG9naW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlY3JldFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgdXBkYXRlTWFnaWNVUkxTZXNzaW9uKHVzZXJJZCwgc2VjcmV0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInNlY3JldFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zL21hZ2ljLXVybCc7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3NlY3JldCddID0gc2VjcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgT0F1dGgyIHNlc3Npb25cbiAgICAgKlxuICAgICAqIEFsbG93IHRoZSB1c2VyIHRvIGxvZ2luIHRvIHRoZWlyIGFjY291bnQgdXNpbmcgdGhlIE9BdXRoMiBwcm92aWRlciBvZiB0aGVpclxuICAgICAqIGNob2ljZS4gRWFjaCBPQXV0aDIgcHJvdmlkZXIgc2hvdWxkIGJlIGVuYWJsZWQgZnJvbSB0aGUgQXBwd3JpdGUgY29uc29sZVxuICAgICAqIGZpcnN0LiBVc2UgdGhlIHN1Y2Nlc3MgYW5kIGZhaWx1cmUgYXJndW1lbnRzIHRvIHByb3ZpZGUgYSByZWRpcmVjdCBVUkwnc1xuICAgICAqIGJhY2sgdG8geW91ciBhcHAgd2hlbiBsb2dpbiBpcyBjb21wbGV0ZWQuXG4gICAgICpcbiAgICAgKiBJZiB0aGVyZSBpcyBhbHJlYWR5IGFuIGFjdGl2ZSBzZXNzaW9uLCB0aGUgbmV3IHNlc3Npb24gd2lsbCBiZSBhdHRhY2hlZCB0b1xuICAgICAqIHRoZSBsb2dnZWQtaW4gYWNjb3VudC4gSWYgdGhlcmUgYXJlIG5vIGFjdGl2ZSBzZXNzaW9ucywgdGhlIHNlcnZlciB3aWxsXG4gICAgICogYXR0ZW1wdCB0byBsb29rIGZvciBhIHVzZXIgd2l0aCB0aGUgc2FtZSBlbWFpbCBhZGRyZXNzIGFzIHRoZSBlbWFpbFxuICAgICAqIHJlY2VpdmVkIGZyb20gdGhlIE9BdXRoMiBwcm92aWRlciBhbmQgYXR0YWNoIHRoZSBuZXcgc2Vzc2lvbiB0byB0aGVcbiAgICAgKiBleGlzdGluZyB1c2VyLiBJZiBubyBtYXRjaGluZyB1c2VyIGlzIGZvdW5kIC0gdGhlIHNlcnZlciB3aWxsIGNyZWF0ZSBhIG5ld1xuICAgICAqIHVzZXIuXG4gICAgICpcbiAgICAgKiBBIHVzZXIgaXMgbGltaXRlZCB0byAxMCBhY3RpdmUgc2Vzc2lvbnMgYXQgYSB0aW1lIGJ5IGRlZmF1bHQuIFtMZWFybiBtb3JlXG4gICAgICogYWJvdXQgc2Vzc2lvblxuICAgICAqIGxpbWl0c10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL2F1dGhlbnRpY2F0aW9uLXNlY3VyaXR5I2xpbWl0cykuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T0F1dGhQcm92aWRlcn0gcHJvdmlkZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3VjY2Vzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmYWlsdXJlXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gc2NvcGVzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge3ZvaWR8c3RyaW5nfVxuICAgICovXG4gICAgY3JlYXRlT0F1dGgyU2Vzc2lvbihwcm92aWRlciwgc3VjY2VzcywgZmFpbHVyZSwgc2NvcGVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByb3ZpZGVyXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zL29hdXRoMi97cHJvdmlkZXJ9Jy5yZXBsYWNlKCd7cHJvdmlkZXJ9JywgcHJvdmlkZXIpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygc3VjY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3N1Y2Nlc3MnXSA9IHN1Y2Nlc3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmYWlsdXJlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZmFpbHVyZSddID0gZmFpbHVyZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNjb3BlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Njb3BlcyddID0gc2NvcGVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIHBheWxvYWRbJ3Byb2plY3QnXSA9IHRoaXMuY2xpZW50LmNvbmZpZy5wcm9qZWN0O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhTZXJ2aWNlLmZsYXR0ZW4ocGF5bG9hZCkpKSB7XG4gICAgICAgICAgICB1cmkuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5sb2NhdGlvbikpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdXJpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBwaG9uZSBzZXNzaW9uXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBjcmVhdGUgYSBzZXNzaW9uIGZyb20gdG9rZW4uIFByb3ZpZGUgdGhlICoqdXNlcklkKipcbiAgICAgKiBhbmQgKipzZWNyZXQqKiBwYXJhbWV0ZXJzIGZyb20gdGhlIHN1Y2Nlc3NmdWwgcmVzcG9uc2Ugb2YgYXV0aGVudGljYXRpb25cbiAgICAgKiBmbG93cyBpbml0aWF0ZWQgYnkgdG9rZW4gY3JlYXRpb24uIEZvciBleGFtcGxlLCBtYWdpYyBVUkwgYW5kIHBob25lIGxvZ2luLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWNyZXRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIHVwZGF0ZVBob25lU2Vzc2lvbih1c2VySWQsIHNlY3JldCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZWNyZXRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucy9waG9uZSc7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3NlY3JldCddID0gc2VjcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgc2Vzc2lvblxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZW5kcG9pbnQgdG8gY3JlYXRlIGEgc2Vzc2lvbiBmcm9tIHRva2VuLiBQcm92aWRlIHRoZSAqKnVzZXJJZCoqXG4gICAgICogYW5kICoqc2VjcmV0KiogcGFyYW1ldGVycyBmcm9tIHRoZSBzdWNjZXNzZnVsIHJlc3BvbnNlIG9mIGF1dGhlbnRpY2F0aW9uXG4gICAgICogZmxvd3MgaW5pdGlhdGVkIGJ5IHRva2VuIGNyZWF0aW9uLiBGb3IgZXhhbXBsZSwgbWFnaWMgVVJMIGFuZCBwaG9uZSBsb2dpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VjcmV0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICBjcmVhdGVTZXNzaW9uKHVzZXJJZCwgc2VjcmV0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInNlY3JldFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zL3Rva2VuJztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsnc2VjcmV0J10gPSBzZWNyZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgc2Vzc2lvblxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZW5kcG9pbnQgdG8gZ2V0IGEgbG9nZ2VkIGluIHVzZXIncyBzZXNzaW9uIHVzaW5nIGEgU2Vzc2lvbiBJRC5cbiAgICAgKiBJbnB1dHRpbmcgJ2N1cnJlbnQnIHdpbGwgcmV0dXJuIHRoZSBjdXJyZW50IHNlc3Npb24gYmVpbmcgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXNzaW9uSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGdldFNlc3Npb24oc2Vzc2lvbklkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInNlc3Npb25JZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zL3tzZXNzaW9uSWR9Jy5yZXBsYWNlKCd7c2Vzc2lvbklkfScsIHNlc3Npb25JZCk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBzZXNzaW9uXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBleHRlbmQgYSBzZXNzaW9uJ3MgbGVuZ3RoLiBFeHRlbmRpbmcgYSBzZXNzaW9uIGlzXG4gICAgICogdXNlZnVsIHdoZW4gc2Vzc2lvbiBleHBpcnkgaXMgc2hvcnQuIElmIHRoZSBzZXNzaW9uIHdhcyBjcmVhdGVkIHVzaW5nIGFuXG4gICAgICogT0F1dGggcHJvdmlkZXIsIHRoaXMgZW5kcG9pbnQgcmVmcmVzaGVzIHRoZSBhY2Nlc3MgdG9rZW4gZnJvbSB0aGUgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2Vzc2lvbklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICB1cGRhdGVTZXNzaW9uKHNlc3Npb25JZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZXNzaW9uSWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucy97c2Vzc2lvbklkfScucmVwbGFjZSgne3Nlc3Npb25JZH0nLCBzZXNzaW9uSWQpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBzZXNzaW9uXG4gICAgICpcbiAgICAgKiBMb2dvdXQgdGhlIHVzZXIuIFVzZSAnY3VycmVudCcgYXMgdGhlIHNlc3Npb24gSUQgdG8gbG9nb3V0IG9uIHRoaXMgZGV2aWNlLFxuICAgICAqIHVzZSBhIHNlc3Npb24gSUQgdG8gbG9nb3V0IG9uIGFub3RoZXIgZGV2aWNlLiBJZiB5b3UncmUgbG9va2luZyB0byBsb2dvdXRcbiAgICAgKiB0aGUgdXNlciBvbiBhbGwgZGV2aWNlcywgdXNlIFtEZWxldGVcbiAgICAgKiBTZXNzaW9uc10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2RlbGV0ZVNlc3Npb25zKVxuICAgICAqIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2Vzc2lvbklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICBkZWxldGVTZXNzaW9uKHNlc3Npb25JZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZXNzaW9uSWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucy97c2Vzc2lvbklkfScucmVwbGFjZSgne3Nlc3Npb25JZH0nLCBzZXNzaW9uSWQpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgc3RhdHVzXG4gICAgICpcbiAgICAgKiBCbG9jayB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyIGFjY291bnQuIEJlaGluZCB0aGUgc2NlbmUsIHRoZSB1c2VyXG4gICAgICogcmVjb3JkIGlzIG5vdCBkZWxldGVkIGJ1dCBwZXJtYW5lbnRseSBibG9ja2VkIGZyb20gYW55IGFjY2Vzcy4gVG9cbiAgICAgKiBjb21wbGV0ZWx5IGRlbGV0ZSBhIHVzZXIsIHVzZSB0aGUgVXNlcnMgQVBJIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIHVwZGF0ZVN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvc3RhdHVzJztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgcHVzaCB0YXJnZXRcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldElkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgY3JlYXRlUHVzaFRhcmdldCh0YXJnZXRJZCwgaWRlbnRpZmllciwgcHJvdmlkZXJJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRhcmdldElkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaWRlbnRpZmllciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImlkZW50aWZpZXJcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC90YXJnZXRzL3B1c2gnO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWyd0YXJnZXRJZCddID0gdGFyZ2V0SWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlkZW50aWZpZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsnaWRlbnRpZmllciddID0gaWRlbnRpZmllcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydwcm92aWRlcklkJ10gPSBwcm92aWRlcklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHB1c2ggdGFyZ2V0XG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICB1cGRhdGVQdXNoVGFyZ2V0KHRhcmdldElkLCBpZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGFyZ2V0SWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpZGVudGlmaWVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiaWRlbnRpZmllclwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3RhcmdldHMve3RhcmdldElkfS9wdXNoJy5yZXBsYWNlKCd7dGFyZ2V0SWR9JywgdGFyZ2V0SWQpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpZGVudGlmaWVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ2lkZW50aWZpZXInXSA9IGlkZW50aWZpZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBwdXNoIHRhcmdldFxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0SWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGRlbGV0ZVB1c2hUYXJnZXQodGFyZ2V0SWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0YXJnZXRJZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3RhcmdldHMve3RhcmdldElkfS9wdXNoJy5yZXBsYWNlKCd7dGFyZ2V0SWR9JywgdGFyZ2V0SWQpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZW1haWwgdG9rZW4gKE9UUClcbiAgICAgKlxuICAgICAqIFNlbmRzIHRoZSB1c2VyIGFuIGVtYWlsIHdpdGggYSBzZWNyZXQga2V5IGZvciBjcmVhdGluZyBhIHNlc3Npb24uIElmIHRoZVxuICAgICAqIHByb3ZpZGVkIHVzZXIgSUQgaGFzIG5vdCBiZSByZWdpc3RlcmVkLCBhIG5ldyB1c2VyIHdpbGwgYmUgY3JlYXRlZC4gVXNlIHRoZVxuICAgICAqIHJldHVybmVkIHVzZXIgSUQgYW5kIHNlY3JldCBhbmQgc3VibWl0IGEgcmVxdWVzdCB0byB0aGUgW1BPU1RcbiAgICAgKiAvdjEvYWNjb3VudC9zZXNzaW9ucy90b2tlbl0oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2NyZWF0ZVNlc3Npb24pXG4gICAgICogZW5kcG9pbnQgdG8gY29tcGxldGUgdGhlIGxvZ2luIHByb2Nlc3MuIFRoZSBzZWNyZXQgc2VudCB0byB0aGUgdXNlcidzIGVtYWlsXG4gICAgICogaXMgdmFsaWQgZm9yIDE1IG1pbnV0ZXMuXG4gICAgICpcbiAgICAgKiBBIHVzZXIgaXMgbGltaXRlZCB0byAxMCBhY3RpdmUgc2Vzc2lvbnMgYXQgYSB0aW1lIGJ5IGRlZmF1bHQuIFtMZWFybiBtb3JlXG4gICAgICogYWJvdXQgc2Vzc2lvblxuICAgICAqIGxpbWl0c10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL2F1dGhlbnRpY2F0aW9uLXNlY3VyaXR5I2xpbWl0cykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwaHJhc2VcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGNyZWF0ZUVtYWlsVG9rZW4odXNlcklkLCBlbWFpbCwgcGhyYXNlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVtYWlsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZW1haWxcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC90b2tlbnMvZW1haWwnO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGhyYXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3BocmFzZSddID0gcGhyYXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIG1hZ2ljIFVSTCB0b2tlblxuICAgICAqXG4gICAgICogU2VuZHMgdGhlIHVzZXIgYW4gZW1haWwgd2l0aCBhIHNlY3JldCBrZXkgZm9yIGNyZWF0aW5nIGEgc2Vzc2lvbi4gSWYgdGhlXG4gICAgICogcHJvdmlkZWQgdXNlciBJRCBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCwgYSBuZXcgdXNlciB3aWxsIGJlIGNyZWF0ZWQuIFdoZW5cbiAgICAgKiB0aGUgdXNlciBjbGlja3MgdGhlIGxpbmsgaW4gdGhlIGVtYWlsLCB0aGUgdXNlciBpcyByZWRpcmVjdGVkIGJhY2sgdG8gdGhlXG4gICAgICogVVJMIHlvdSBwcm92aWRlZCB3aXRoIHRoZSBzZWNyZXQga2V5IGFuZCB1c2VySWQgdmFsdWVzIGF0dGFjaGVkIHRvIHRoZSBVUkxcbiAgICAgKiBxdWVyeSBzdHJpbmcuIFVzZSB0aGUgcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnMgdG8gc3VibWl0IGEgcmVxdWVzdCB0byB0aGVcbiAgICAgKiBbUE9TVFxuICAgICAqIC92MS9hY2NvdW50L3Nlc3Npb25zL3Rva2VuXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlU2Vzc2lvbilcbiAgICAgKiBlbmRwb2ludCB0byBjb21wbGV0ZSB0aGUgbG9naW4gcHJvY2Vzcy4gVGhlIGxpbmsgc2VudCB0byB0aGUgdXNlcidzIGVtYWlsXG4gICAgICogYWRkcmVzcyBpcyB2YWxpZCBmb3IgMSBob3VyLiBJZiB5b3UgYXJlIG9uIGEgbW9iaWxlIGRldmljZSB5b3UgY2FuIGxlYXZlXG4gICAgICogdGhlIFVSTCBwYXJhbWV0ZXIgZW1wdHksIHNvIHRoYXQgdGhlIGxvZ2luIGNvbXBsZXRpb24gd2lsbCBiZSBoYW5kbGVkIGJ5XG4gICAgICogeW91ciBBcHB3cml0ZSBpbnN0YW5jZSBieSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogQSB1c2VyIGlzIGxpbWl0ZWQgdG8gMTAgYWN0aXZlIHNlc3Npb25zIGF0IGEgdGltZSBieSBkZWZhdWx0LiBbTGVhcm4gbW9yZVxuICAgICAqIGFib3V0IHNlc3Npb25cbiAgICAgKiBsaW1pdHNdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9hdXRoZW50aWNhdGlvbi1zZWN1cml0eSNsaW1pdHMpLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGhyYXNlXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICBjcmVhdGVNYWdpY1VSTFRva2VuKHVzZXJJZCwgZW1haWwsIHVybCwgcGhyYXNlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVtYWlsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZW1haWxcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC90b2tlbnMvbWFnaWMtdXJsJztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWyd1cmwnXSA9IHVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGhyYXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3BocmFzZSddID0gcGhyYXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIE9BdXRoMiB0b2tlblxuICAgICAqXG4gICAgICogQWxsb3cgdGhlIHVzZXIgdG8gbG9naW4gdG8gdGhlaXIgYWNjb3VudCB1c2luZyB0aGUgT0F1dGgyIHByb3ZpZGVyIG9mIHRoZWlyXG4gICAgICogY2hvaWNlLiBFYWNoIE9BdXRoMiBwcm92aWRlciBzaG91bGQgYmUgZW5hYmxlZCBmcm9tIHRoZSBBcHB3cml0ZSBjb25zb2xlXG4gICAgICogZmlyc3QuIFVzZSB0aGUgc3VjY2VzcyBhbmQgZmFpbHVyZSBhcmd1bWVudHMgdG8gcHJvdmlkZSBhIHJlZGlyZWN0IFVSTCdzXG4gICAgICogYmFjayB0byB5b3VyIGFwcCB3aGVuIGxvZ2luIGlzIGNvbXBsZXRlZC5cbiAgICAgKlxuICAgICAqIElmIGF1dGhlbnRpY2F0aW9uIHN1Y2NlZWRzLCBgdXNlcklkYCBhbmQgYHNlY3JldGAgb2YgYSB0b2tlbiB3aWxsIGJlXG4gICAgICogYXBwZW5kZWQgdG8gdGhlIHN1Y2Nlc3MgVVJMIGFzIHF1ZXJ5IHBhcmFtZXRlcnMuIFRoZXNlIGNhbiBiZSB1c2VkIHRvXG4gICAgICogY3JlYXRlIGEgbmV3IHNlc3Npb24gdXNpbmcgdGhlIFtDcmVhdGVcbiAgICAgKiBzZXNzaW9uXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlU2Vzc2lvbilcbiAgICAgKiBlbmRwb2ludC5cbiAgICAgKlxuICAgICAqIEEgdXNlciBpcyBsaW1pdGVkIHRvIDEwIGFjdGl2ZSBzZXNzaW9ucyBhdCBhIHRpbWUgYnkgZGVmYXVsdC4gW0xlYXJuIG1vcmVcbiAgICAgKiBhYm91dCBzZXNzaW9uXG4gICAgICogbGltaXRzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvYXV0aGVudGljYXRpb24tc2VjdXJpdHkjbGltaXRzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T0F1dGhQcm92aWRlcn0gcHJvdmlkZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3VjY2Vzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmYWlsdXJlXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gc2NvcGVzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge3ZvaWR8c3RyaW5nfVxuICAgICovXG4gICAgY3JlYXRlT0F1dGgyVG9rZW4ocHJvdmlkZXIsIHN1Y2Nlc3MsIGZhaWx1cmUsIHNjb3Blcykge1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcm92aWRlclwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC90b2tlbnMvb2F1dGgyL3twcm92aWRlcn0nLnJlcGxhY2UoJ3twcm92aWRlcn0nLCBwcm92aWRlcik7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdWNjZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc3VjY2VzcyddID0gc3VjY2VzcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZhaWx1cmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmYWlsdXJlJ10gPSBmYWlsdXJlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2NvcGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2NvcGVzJ10gPSBzY29wZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgcGF5bG9hZFsncHJvamVjdCddID0gdGhpcy5jbGllbnQuY29uZmlnLnByb2plY3Q7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKFNlcnZpY2UuZmxhdHRlbihwYXlsb2FkKSkpIHtcbiAgICAgICAgICAgIHVyaS5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAod2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LmxvY2F0aW9uKSkge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1cmk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHBob25lIHRva2VuXG4gICAgICpcbiAgICAgKiBTZW5kcyB0aGUgdXNlciBhbiBTTVMgd2l0aCBhIHNlY3JldCBrZXkgZm9yIGNyZWF0aW5nIGEgc2Vzc2lvbi4gSWYgdGhlXG4gICAgICogcHJvdmlkZWQgdXNlciBJRCBoYXMgbm90IGJlIHJlZ2lzdGVyZWQsIGEgbmV3IHVzZXIgd2lsbCBiZSBjcmVhdGVkLiBVc2UgdGhlXG4gICAgICogcmV0dXJuZWQgdXNlciBJRCBhbmQgc2VjcmV0IGFuZCBzdWJtaXQgYSByZXF1ZXN0IHRvIHRoZSBbUE9TVFxuICAgICAqIC92MS9hY2NvdW50L3Nlc3Npb25zL3Rva2VuXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlU2Vzc2lvbilcbiAgICAgKiBlbmRwb2ludCB0byBjb21wbGV0ZSB0aGUgbG9naW4gcHJvY2Vzcy4gVGhlIHNlY3JldCBzZW50IHRvIHRoZSB1c2VyJ3MgcGhvbmVcbiAgICAgKiBpcyB2YWxpZCBmb3IgMTUgbWludXRlcy5cbiAgICAgKlxuICAgICAqIEEgdXNlciBpcyBsaW1pdGVkIHRvIDEwIGFjdGl2ZSBzZXNzaW9ucyBhdCBhIHRpbWUgYnkgZGVmYXVsdC4gW0xlYXJuIG1vcmVcbiAgICAgKiBhYm91dCBzZXNzaW9uXG4gICAgICogbGltaXRzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvYXV0aGVudGljYXRpb24tc2VjdXJpdHkjbGltaXRzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGhvbmVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGNyZWF0ZVBob25lVG9rZW4odXNlcklkLCBwaG9uZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwaG9uZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBob25lXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdG9rZW5zL3Bob25lJztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwaG9uZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydwaG9uZSddID0gcGhvbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZW1haWwgdmVyaWZpY2F0aW9uXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBzZW5kIGEgdmVyaWZpY2F0aW9uIG1lc3NhZ2UgdG8geW91ciB1c2VyIGVtYWlsIGFkZHJlc3NcbiAgICAgKiB0byBjb25maXJtIHRoZXkgYXJlIHRoZSB2YWxpZCBvd25lcnMgb2YgdGhhdCBhZGRyZXNzLiBCb3RoIHRoZSAqKnVzZXJJZCoqXG4gICAgICogYW5kICoqc2VjcmV0KiogYXJndW1lbnRzIHdpbGwgYmUgcGFzc2VkIGFzIHF1ZXJ5IHBhcmFtZXRlcnMgdG8gdGhlIFVSTCB5b3VcbiAgICAgKiBoYXZlIHByb3ZpZGVkIHRvIGJlIGF0dGFjaGVkIHRvIHRoZSB2ZXJpZmljYXRpb24gZW1haWwuIFRoZSBwcm92aWRlZCBVUkxcbiAgICAgKiBzaG91bGQgcmVkaXJlY3QgdGhlIHVzZXIgYmFjayB0byB5b3VyIGFwcCBhbmQgYWxsb3cgeW91IHRvIGNvbXBsZXRlIHRoZVxuICAgICAqIHZlcmlmaWNhdGlvbiBwcm9jZXNzIGJ5IHZlcmlmeWluZyBib3RoIHRoZSAqKnVzZXJJZCoqIGFuZCAqKnNlY3JldCoqXG4gICAgICogcGFyYW1ldGVycy4gTGVhcm4gbW9yZSBhYm91dCBob3cgdG8gW2NvbXBsZXRlIHRoZSB2ZXJpZmljYXRpb25cbiAgICAgKiBwcm9jZXNzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjdXBkYXRlVmVyaWZpY2F0aW9uKS5cbiAgICAgKiBUaGUgdmVyaWZpY2F0aW9uIGxpbmsgc2VudCB0byB0aGUgdXNlcidzIGVtYWlsIGFkZHJlc3MgaXMgdmFsaWQgZm9yIDcgZGF5cy5cbiAgICAgKlxuICAgICAqIFBsZWFzZSBub3RlIHRoYXQgaW4gb3JkZXIgdG8gYXZvaWQgYSBbUmVkaXJlY3RcbiAgICAgKiBBdHRhY2tdKGh0dHBzOi8vZ2l0aHViLmNvbS9PV0FTUC9DaGVhdFNoZWV0U2VyaWVzL2Jsb2IvbWFzdGVyL2NoZWF0c2hlZXRzL1VudmFsaWRhdGVkX1JlZGlyZWN0c19hbmRfRm9yd2FyZHNfQ2hlYXRfU2hlZXQubWQpLFxuICAgICAqIHRoZSBvbmx5IHZhbGlkIHJlZGlyZWN0IFVSTHMgYXJlIHRoZSBvbmVzIGZyb20gZG9tYWlucyB5b3UgaGF2ZSBzZXQgd2hlblxuICAgICAqIGFkZGluZyB5b3VyIHBsYXRmb3JtcyBpbiB0aGUgY29uc29sZSBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGNyZWF0ZVZlcmlmaWNhdGlvbih1cmwpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXJsXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdmVyaWZpY2F0aW9uJztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3VybCddID0gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGVtYWlsIHZlcmlmaWNhdGlvbiAoY29uZmlybWF0aW9uKVxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZW5kcG9pbnQgdG8gY29tcGxldGUgdGhlIHVzZXIgZW1haWwgdmVyaWZpY2F0aW9uIHByb2Nlc3MuIFVzZSBib3RoXG4gICAgICogdGhlICoqdXNlcklkKiogYW5kICoqc2VjcmV0KiogcGFyYW1ldGVycyB0aGF0IHdlcmUgYXR0YWNoZWQgdG8geW91ciBhcHAgVVJMXG4gICAgICogdG8gdmVyaWZ5IHRoZSB1c2VyIGVtYWlsIG93bmVyc2hpcC4gSWYgY29uZmlybWVkIHRoaXMgcm91dGUgd2lsbCByZXR1cm4gYVxuICAgICAqIDIwMCBzdGF0dXMgY29kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VjcmV0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICB1cGRhdGVWZXJpZmljYXRpb24odXNlcklkLCBzZWNyZXQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2VjcmV0XCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdmVyaWZpY2F0aW9uJztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsnc2VjcmV0J10gPSBzZWNyZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBwaG9uZSB2ZXJpZmljYXRpb25cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIHNlbmQgYSB2ZXJpZmljYXRpb24gU01TIHRvIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluXG4gICAgICogdXNlci4gVGhpcyBlbmRwb2ludCBpcyBtZWFudCBmb3IgdXNlIGFmdGVyIHVwZGF0aW5nIGEgdXNlcidzIHBob25lIG51bWJlclxuICAgICAqIHVzaW5nIHRoZVxuICAgICAqIFthY2NvdW50VXBkYXRlUGhvbmVdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCN1cGRhdGVQaG9uZSlcbiAgICAgKiBlbmRwb2ludC4gTGVhcm4gbW9yZSBhYm91dCBob3cgdG8gW2NvbXBsZXRlIHRoZSB2ZXJpZmljYXRpb25cbiAgICAgKiBwcm9jZXNzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjdXBkYXRlUGhvbmVWZXJpZmljYXRpb24pLlxuICAgICAqIFRoZSB2ZXJpZmljYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyJ3MgcGhvbmUgbnVtYmVyIGlzIHZhbGlkIGZvciAxNVxuICAgICAqIG1pbnV0ZXMuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGNyZWF0ZVBob25lVmVyaWZpY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC92ZXJpZmljYXRpb24vcGhvbmUnO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHBob25lIHZlcmlmaWNhdGlvbiAoY29uZmlybWF0aW9uKVxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZW5kcG9pbnQgdG8gY29tcGxldGUgdGhlIHVzZXIgcGhvbmUgdmVyaWZpY2F0aW9uIHByb2Nlc3MuIFVzZSB0aGVcbiAgICAgKiAqKnVzZXJJZCoqIGFuZCAqKnNlY3JldCoqIHRoYXQgd2VyZSBzZW50IHRvIHlvdXIgdXNlcidzIHBob25lIG51bWJlciB0b1xuICAgICAqIHZlcmlmeSB0aGUgdXNlciBlbWFpbCBvd25lcnNoaXAuIElmIGNvbmZpcm1lZCB0aGlzIHJvdXRlIHdpbGwgcmV0dXJuIGEgMjAwXG4gICAgICogc3RhdHVzIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlY3JldFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgdXBkYXRlUGhvbmVWZXJpZmljYXRpb24odXNlcklkLCBzZWNyZXQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2VjcmV0XCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdmVyaWZpY2F0aW9uL3Bob25lJztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsnc2VjcmV0J10gPSBzZWNyZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBBdmF0YXJzIGV4dGVuZHMgU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHN1cGVyKGNsaWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBicm93c2VyIGljb25cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gdXNlIHRoaXMgZW5kcG9pbnQgdG8gc2hvdyBkaWZmZXJlbnQgYnJvd3NlciBpY29ucyB0byB5b3VyIHVzZXJzLlxuICAgICAqIFRoZSBjb2RlIGFyZ3VtZW50IHJlY2VpdmVzIHRoZSBicm93c2VyIGNvZGUgYXMgaXQgYXBwZWFycyBpbiB5b3VyIHVzZXIgW0dFVFxuICAgICAqIC9hY2NvdW50L3Nlc3Npb25zXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjZ2V0U2Vzc2lvbnMpXG4gICAgICogZW5kcG9pbnQuIFVzZSB3aWR0aCwgaGVpZ2h0IGFuZCBxdWFsaXR5IGFyZ3VtZW50cyB0byBjaGFuZ2UgdGhlIG91dHB1dFxuICAgICAqIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogV2hlbiBvbmUgZGltZW5zaW9uIGlzIHNwZWNpZmllZCBhbmQgdGhlIG90aGVyIGlzIDAsIHRoZSBpbWFnZSBpcyBzY2FsZWRcbiAgICAgKiB3aXRoIHByZXNlcnZlZCBhc3BlY3QgcmF0aW8uIElmIGJvdGggZGltZW5zaW9ucyBhcmUgMCwgdGhlIEFQSSBwcm92aWRlcyBhblxuICAgICAqIGltYWdlIGF0IHNvdXJjZSBxdWFsaXR5LiBJZiBkaW1lbnNpb25zIGFyZSBub3Qgc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBzaXplXG4gICAgICogb2YgaW1hZ2UgcmV0dXJuZWQgaXMgMTAweDEwMHB4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCcm93c2VyfSBjb2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBxdWFsaXR5XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1VSTH1cbiAgICAqL1xuICAgIGdldEJyb3dzZXIoY29kZSwgd2lkdGgsIGhlaWdodCwgcXVhbGl0eSkge1xuICAgICAgICBpZiAodHlwZW9mIGNvZGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvZGVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2F2YXRhcnMvYnJvd3NlcnMve2NvZGV9Jy5yZXBsYWNlKCd7Y29kZX0nLCBjb2RlKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHdpZHRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnd2lkdGgnXSA9IHdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaGVpZ2h0J10gPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBxdWFsaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVhbGl0eSddID0gcXVhbGl0eTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBwYXlsb2FkWydwcm9qZWN0J10gPSB0aGlzLmNsaWVudC5jb25maWcucHJvamVjdDtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoU2VydmljZS5mbGF0dGVuKHBheWxvYWQpKSkge1xuICAgICAgICAgICAgdXJpLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGNyZWRpdCBjYXJkIGljb25cbiAgICAgKlxuICAgICAqIFRoZSBjcmVkaXQgY2FyZCBlbmRwb2ludCB3aWxsIHJldHVybiB5b3UgdGhlIGljb24gb2YgdGhlIGNyZWRpdCBjYXJkXG4gICAgICogcHJvdmlkZXIgeW91IG5lZWQuIFVzZSB3aWR0aCwgaGVpZ2h0IGFuZCBxdWFsaXR5IGFyZ3VtZW50cyB0byBjaGFuZ2UgdGhlXG4gICAgICogb3V0cHV0IHNldHRpbmdzLlxuICAgICAqXG4gICAgICogV2hlbiBvbmUgZGltZW5zaW9uIGlzIHNwZWNpZmllZCBhbmQgdGhlIG90aGVyIGlzIDAsIHRoZSBpbWFnZSBpcyBzY2FsZWRcbiAgICAgKiB3aXRoIHByZXNlcnZlZCBhc3BlY3QgcmF0aW8uIElmIGJvdGggZGltZW5zaW9ucyBhcmUgMCwgdGhlIEFQSSBwcm92aWRlcyBhblxuICAgICAqIGltYWdlIGF0IHNvdXJjZSBxdWFsaXR5LiBJZiBkaW1lbnNpb25zIGFyZSBub3Qgc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBzaXplXG4gICAgICogb2YgaW1hZ2UgcmV0dXJuZWQgaXMgMTAweDEwMHB4LlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NyZWRpdENhcmR9IGNvZGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHF1YWxpdHlcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7VVJMfVxuICAgICovXG4gICAgZ2V0Q3JlZGl0Q2FyZChjb2RlLCB3aWR0aCwgaGVpZ2h0LCBxdWFsaXR5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29kZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29kZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYXZhdGFycy9jcmVkaXQtY2FyZHMve2NvZGV9Jy5yZXBsYWNlKCd7Y29kZX0nLCBjb2RlKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHdpZHRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnd2lkdGgnXSA9IHdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaGVpZ2h0J10gPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBxdWFsaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVhbGl0eSddID0gcXVhbGl0eTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBwYXlsb2FkWydwcm9qZWN0J10gPSB0aGlzLmNsaWVudC5jb25maWcucHJvamVjdDtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoU2VydmljZS5mbGF0dGVuKHBheWxvYWQpKSkge1xuICAgICAgICAgICAgdXJpLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGZhdmljb25cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIGZldGNoIHRoZSBmYXZvcml0ZSBpY29uIChBS0EgZmF2aWNvbikgb2YgYW55IHJlbW90ZVxuICAgICAqIHdlYnNpdGUgVVJMLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1VSTH1cbiAgICAqL1xuICAgIGdldEZhdmljb24odXJsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1cmxcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2F2YXRhcnMvZmF2aWNvbic7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1cmwnXSA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBwYXlsb2FkWydwcm9qZWN0J10gPSB0aGlzLmNsaWVudC5jb25maWcucHJvamVjdDtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoU2VydmljZS5mbGF0dGVuKHBheWxvYWQpKSkge1xuICAgICAgICAgICAgdXJpLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGNvdW50cnkgZmxhZ1xuICAgICAqXG4gICAgICogWW91IGNhbiB1c2UgdGhpcyBlbmRwb2ludCB0byBzaG93IGRpZmZlcmVudCBjb3VudHJ5IGZsYWdzIGljb25zIHRvIHlvdXJcbiAgICAgKiB1c2Vycy4gVGhlIGNvZGUgYXJndW1lbnQgcmVjZWl2ZXMgdGhlIDIgbGV0dGVyIGNvdW50cnkgY29kZS4gVXNlIHdpZHRoLFxuICAgICAqIGhlaWdodCBhbmQgcXVhbGl0eSBhcmd1bWVudHMgdG8gY2hhbmdlIHRoZSBvdXRwdXQgc2V0dGluZ3MuIENvdW50cnkgY29kZXNcbiAgICAgKiBmb2xsb3cgdGhlIFtJU08gMzE2Ni0xXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fMzE2Ni0xKSBzdGFuZGFyZC5cbiAgICAgKlxuICAgICAqIFdoZW4gb25lIGRpbWVuc2lvbiBpcyBzcGVjaWZpZWQgYW5kIHRoZSBvdGhlciBpcyAwLCB0aGUgaW1hZ2UgaXMgc2NhbGVkXG4gICAgICogd2l0aCBwcmVzZXJ2ZWQgYXNwZWN0IHJhdGlvLiBJZiBib3RoIGRpbWVuc2lvbnMgYXJlIDAsIHRoZSBBUEkgcHJvdmlkZXMgYW5cbiAgICAgKiBpbWFnZSBhdCBzb3VyY2UgcXVhbGl0eS4gSWYgZGltZW5zaW9ucyBhcmUgbm90IHNwZWNpZmllZCwgdGhlIGRlZmF1bHQgc2l6ZVxuICAgICAqIG9mIGltYWdlIHJldHVybmVkIGlzIDEwMHgxMDBweC5cbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGbGFnfSBjb2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBxdWFsaXR5XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1VSTH1cbiAgICAqL1xuICAgIGdldEZsYWcoY29kZSwgd2lkdGgsIGhlaWdodCwgcXVhbGl0eSkge1xuICAgICAgICBpZiAodHlwZW9mIGNvZGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvZGVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2F2YXRhcnMvZmxhZ3Mve2NvZGV9Jy5yZXBsYWNlKCd7Y29kZX0nLCBjb2RlKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHdpZHRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnd2lkdGgnXSA9IHdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaGVpZ2h0J10gPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBxdWFsaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVhbGl0eSddID0gcXVhbGl0eTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBwYXlsb2FkWydwcm9qZWN0J10gPSB0aGlzLmNsaWVudC5jb25maWcucHJvamVjdDtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoU2VydmljZS5mbGF0dGVuKHBheWxvYWQpKSkge1xuICAgICAgICAgICAgdXJpLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGltYWdlIGZyb20gVVJMXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBmZXRjaCBhIHJlbW90ZSBpbWFnZSBVUkwgYW5kIGNyb3AgaXQgdG8gYW55IGltYWdlIHNpemVcbiAgICAgKiB5b3Ugd2FudC4gVGhpcyBlbmRwb2ludCBpcyB2ZXJ5IHVzZWZ1bCBpZiB5b3UgbmVlZCB0byBjcm9wIGFuZCBkaXNwbGF5XG4gICAgICogcmVtb3RlIGltYWdlcyBpbiB5b3VyIGFwcCBvciBpbiBjYXNlIHlvdSB3YW50IHRvIG1ha2Ugc3VyZSBhIDNyZCBwYXJ0eVxuICAgICAqIGltYWdlIGlzIHByb3Blcmx5IHNlcnZlZCB1c2luZyBhIFRMUyBwcm90b2NvbC5cbiAgICAgKlxuICAgICAqIFdoZW4gb25lIGRpbWVuc2lvbiBpcyBzcGVjaWZpZWQgYW5kIHRoZSBvdGhlciBpcyAwLCB0aGUgaW1hZ2UgaXMgc2NhbGVkXG4gICAgICogd2l0aCBwcmVzZXJ2ZWQgYXNwZWN0IHJhdGlvLiBJZiBib3RoIGRpbWVuc2lvbnMgYXJlIDAsIHRoZSBBUEkgcHJvdmlkZXMgYW5cbiAgICAgKiBpbWFnZSBhdCBzb3VyY2UgcXVhbGl0eS4gSWYgZGltZW5zaW9ucyBhcmUgbm90IHNwZWNpZmllZCwgdGhlIGRlZmF1bHQgc2l6ZVxuICAgICAqIG9mIGltYWdlIHJldHVybmVkIGlzIDQwMHg0MDBweC5cbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7VVJMfVxuICAgICovXG4gICAgZ2V0SW1hZ2UodXJsLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1cmxcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2F2YXRhcnMvaW1hZ2UnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXJsJ10gPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3dpZHRoJ10gPSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGhlaWdodCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2hlaWdodCddID0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIHBheWxvYWRbJ3Byb2plY3QnXSA9IHRoaXMuY2xpZW50LmNvbmZpZy5wcm9qZWN0O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhTZXJ2aWNlLmZsYXR0ZW4ocGF5bG9hZCkpKSB7XG4gICAgICAgICAgICB1cmkuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdXNlciBpbml0aWFsc1xuICAgICAqXG4gICAgICogVXNlIHRoaXMgZW5kcG9pbnQgdG8gc2hvdyB5b3VyIHVzZXIgaW5pdGlhbHMgYXZhdGFyIGljb24gb24geW91ciB3ZWJzaXRlIG9yXG4gICAgICogYXBwLiBCeSBkZWZhdWx0LCB0aGlzIHJvdXRlIHdpbGwgdHJ5IHRvIHByaW50IHlvdXIgbG9nZ2VkLWluIHVzZXIgbmFtZSBvclxuICAgICAqIGVtYWlsIGluaXRpYWxzLiBZb3UgY2FuIGFsc28gb3ZlcndyaXRlIHRoZSB1c2VyIG5hbWUgaWYgeW91IHBhc3MgdGhlICduYW1lJ1xuICAgICAqIHBhcmFtZXRlci4gSWYgbm8gbmFtZSBpcyBnaXZlbiBhbmQgbm8gdXNlciBpcyBsb2dnZWQsIGFuIGVtcHR5IGF2YXRhciB3aWxsXG4gICAgICogYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIHVzZSB0aGUgY29sb3IgYW5kIGJhY2tncm91bmQgcGFyYW1zIHRvIGNoYW5nZSB0aGUgYXZhdGFyIGNvbG9ycy4gQnlcbiAgICAgKiBkZWZhdWx0LCBhIHJhbmRvbSB0aGVtZSB3aWxsIGJlIHNlbGVjdGVkLiBUaGUgcmFuZG9tIHRoZW1lIHdpbGwgcGVyc2lzdCBmb3JcbiAgICAgKiB0aGUgdXNlcidzIGluaXRpYWxzIHdoZW4gcmVsb2FkaW5nIHRoZSBzYW1lIHRoZW1lIHdpbGwgYWx3YXlzIHJldHVybiBmb3JcbiAgICAgKiB0aGUgc2FtZSBpbml0aWFscy5cbiAgICAgKlxuICAgICAqIFdoZW4gb25lIGRpbWVuc2lvbiBpcyBzcGVjaWZpZWQgYW5kIHRoZSBvdGhlciBpcyAwLCB0aGUgaW1hZ2UgaXMgc2NhbGVkXG4gICAgICogd2l0aCBwcmVzZXJ2ZWQgYXNwZWN0IHJhdGlvLiBJZiBib3RoIGRpbWVuc2lvbnMgYXJlIDAsIHRoZSBBUEkgcHJvdmlkZXMgYW5cbiAgICAgKiBpbWFnZSBhdCBzb3VyY2UgcXVhbGl0eS4gSWYgZGltZW5zaW9ucyBhcmUgbm90IHNwZWNpZmllZCwgdGhlIGRlZmF1bHQgc2l6ZVxuICAgICAqIG9mIGltYWdlIHJldHVybmVkIGlzIDEwMHgxMDBweC5cbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhY2tncm91bmRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7VVJMfVxuICAgICovXG4gICAgZ2V0SW5pdGlhbHMobmFtZSwgd2lkdGgsIGhlaWdodCwgYmFja2dyb3VuZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hdmF0YXJzL2luaXRpYWxzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd3aWR0aCddID0gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydoZWlnaHQnXSA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGJhY2tncm91bmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydiYWNrZ3JvdW5kJ10gPSBiYWNrZ3JvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIHBheWxvYWRbJ3Byb2plY3QnXSA9IHRoaXMuY2xpZW50LmNvbmZpZy5wcm9qZWN0O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhTZXJ2aWNlLmZsYXR0ZW4ocGF5bG9hZCkpKSB7XG4gICAgICAgICAgICB1cmkuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgUVIgY29kZVxuICAgICAqXG4gICAgICogQ29udmVydHMgYSBnaXZlbiBwbGFpbiB0ZXh0IHRvIGEgUVIgY29kZSBpbWFnZS4gWW91IGNhbiB1c2UgdGhlIHF1ZXJ5XG4gICAgICogcGFyYW1ldGVycyB0byBjaGFuZ2UgdGhlIHNpemUgYW5kIHN0eWxlIG9mIHRoZSByZXN1bHRpbmcgaW1hZ2UuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWFyZ2luXG4gICAgICogQHBhcmFtIHtib29sZWFufSBkb3dubG9hZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtVUkx9XG4gICAgKi9cbiAgICBnZXRRUih0ZXh0LCBzaXplLCBtYXJnaW4sIGRvd25sb2FkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGV4dFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYXZhdGFycy9xcic7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGV4dCddID0gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzaXplJ10gPSBzaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbWFyZ2luICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWFyZ2luJ10gPSBtYXJnaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkb3dubG9hZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2Rvd25sb2FkJ10gPSBkb3dubG9hZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBwYXlsb2FkWydwcm9qZWN0J10gPSB0aGlzLmNsaWVudC5jb25maWcucHJvamVjdDtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoU2VydmljZS5mbGF0dGVuKHBheWxvYWQpKSkge1xuICAgICAgICAgICAgdXJpLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaTtcbiAgICB9XG59XG5cbmNsYXNzIERhdGFiYXNlcyBleHRlbmRzIFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICBzdXBlcihjbGllbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGRvY3VtZW50c1xuICAgICAqXG4gICAgICogR2V0IGEgbGlzdCBvZiBhbGwgdGhlIHVzZXIncyBkb2N1bWVudHMgaW4gYSBnaXZlbiBjb2xsZWN0aW9uLiBZb3UgY2FuIHVzZVxuICAgICAqIHRoZSBxdWVyeSBwYXJhbXMgdG8gZmlsdGVyIHlvdXIgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGxpc3REb2N1bWVudHMoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBxdWVyaWVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vZG9jdW1lbnRzJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGRvY3VtZW50XG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgRG9jdW1lbnQuIEJlZm9yZSB1c2luZyB0aGlzIHJvdXRlLCB5b3Ugc2hvdWxkIGNyZWF0ZSBhIG5ld1xuICAgICAqIGNvbGxlY3Rpb24gcmVzb3VyY2UgdXNpbmcgZWl0aGVyIGEgW3NlcnZlclxuICAgICAqIGludGVncmF0aW9uXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3Mvc2VydmVyL2RhdGFiYXNlcyNkYXRhYmFzZXNDcmVhdGVDb2xsZWN0aW9uKVxuICAgICAqIEFQSSBvciBkaXJlY3RseSBmcm9tIHlvdXIgZGF0YWJhc2UgY29uc29sZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkb2N1bWVudElkXG4gICAgICogQHBhcmFtIHtPbWl0PERvY3VtZW50LCBrZXlvZiBNb2RlbHMuRG9jdW1lbnQ+fSBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGVybWlzc2lvbnNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGNyZWF0ZURvY3VtZW50KGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwgZG9jdW1lbnRJZCwgZGF0YSwgcGVybWlzc2lvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZG9jdW1lbnRJZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vZG9jdW1lbnRzJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50SWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsnZG9jdW1lbnRJZCddID0gZG9jdW1lbnRJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydkYXRhJ10gPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwZXJtaXNzaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydwZXJtaXNzaW9ucyddID0gcGVybWlzc2lvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZG9jdW1lbnRcbiAgICAgKlxuICAgICAqIEdldCBhIGRvY3VtZW50IGJ5IGl0cyB1bmlxdWUgSUQuIFRoaXMgZW5kcG9pbnQgcmVzcG9uc2UgcmV0dXJucyBhIEpTT05cbiAgICAgKiBvYmplY3Qgd2l0aCB0aGUgZG9jdW1lbnQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkb2N1bWVudElkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgZ2V0RG9jdW1lbnQoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBkb2N1bWVudElkLCBxdWVyaWVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRvY3VtZW50SWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9kb2N1bWVudHMve2RvY3VtZW50SWR9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCkucmVwbGFjZSgne2RvY3VtZW50SWR9JywgZG9jdW1lbnRJZCk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGRvY3VtZW50XG4gICAgICpcbiAgICAgKiBVcGRhdGUgYSBkb2N1bWVudCBieSBpdHMgdW5pcXVlIElELiBVc2luZyB0aGUgcGF0Y2ggbWV0aG9kIHlvdSBjYW4gcGFzc1xuICAgICAqIG9ubHkgc3BlY2lmaWMgZmllbGRzIHRoYXQgd2lsbCBnZXQgdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkb2N1bWVudElkXG4gICAgICogQHBhcmFtIHtQYXJ0aWFsPE9taXQ8RG9jdW1lbnQsIGtleW9mIE1vZGVscy5Eb2N1bWVudD4+fSBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGVybWlzc2lvbnNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIHVwZGF0ZURvY3VtZW50KGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwgZG9jdW1lbnRJZCwgZGF0YSwgcGVybWlzc2lvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZG9jdW1lbnRJZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2RvY3VtZW50cy97ZG9jdW1lbnRJZH0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7ZG9jdW1lbnRJZH0nLCBkb2N1bWVudElkKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydkYXRhJ10gPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwZXJtaXNzaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydwZXJtaXNzaW9ucyddID0gcGVybWlzc2lvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGRvY3VtZW50XG4gICAgICpcbiAgICAgKiBEZWxldGUgYSBkb2N1bWVudCBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRvY3VtZW50SWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGRlbGV0ZURvY3VtZW50KGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwgZG9jdW1lbnRJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkb2N1bWVudElkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vZG9jdW1lbnRzL3tkb2N1bWVudElkfScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3tkb2N1bWVudElkfScsIGRvY3VtZW50SWQpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgRnVuY3Rpb25zIGV4dGVuZHMgU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHN1cGVyKGNsaWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgZXhlY3V0aW9uc1xuICAgICAqXG4gICAgICogR2V0IGEgbGlzdCBvZiBhbGwgdGhlIGN1cnJlbnQgdXNlciBmdW5jdGlvbiBleGVjdXRpb24gbG9ncy4gWW91IGNhbiB1c2UgdGhlXG4gICAgICogcXVlcnkgcGFyYW1zIHRvIGZpbHRlciB5b3VyIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICBsaXN0RXhlY3V0aW9ucyhmdW5jdGlvbklkLCBxdWVyaWVzLCBzZWFyY2gpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfS9leGVjdXRpb25zJy5yZXBsYWNlKCd7ZnVuY3Rpb25JZH0nLCBmdW5jdGlvbklkKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWFyY2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBleGVjdXRpb25cbiAgICAgKlxuICAgICAqIFRyaWdnZXIgYSBmdW5jdGlvbiBleGVjdXRpb24uIFRoZSByZXR1cm5lZCBvYmplY3Qgd2lsbCByZXR1cm4geW91IHRoZVxuICAgICAqIGN1cnJlbnQgZXhlY3V0aW9uIHN0YXR1cy4gWW91IGNhbiBwaW5nIHRoZSBgR2V0IEV4ZWN1dGlvbmAgZW5kcG9pbnQgdG8gZ2V0XG4gICAgICogdXBkYXRlcyBvbiB0aGUgY3VycmVudCBleGVjdXRpb24gc3RhdHVzLiBPbmNlIHRoaXMgZW5kcG9pbnQgaXMgY2FsbGVkLCB5b3VyXG4gICAgICogZnVuY3Rpb24gZXhlY3V0aW9uIHByb2Nlc3Mgd2lsbCBzdGFydCBhc3luY2hyb25vdXNseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJvZHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFzeW5jXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHhwYXRoXG4gICAgICogQHBhcmFtIHtFeGVjdXRpb25NZXRob2R9IG1ldGhvZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBoZWFkZXJzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICBjcmVhdGVFeGVjdXRpb24oZnVuY3Rpb25JZCwgYm9keSwgYXN5bmMsIHhwYXRoLCBtZXRob2QsIGhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfS9leGVjdXRpb25zJy5yZXBsYWNlKCd7ZnVuY3Rpb25JZH0nLCBmdW5jdGlvbklkKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYm9keSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydib2R5J10gPSBib2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhc3luYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydhc3luYyddID0gYXN5bmM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHhwYXRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3BhdGgnXSA9IHhwYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsnbWV0aG9kJ10gPSBtZXRob2Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGhlYWRlcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsnaGVhZGVycyddID0gaGVhZGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBleGVjdXRpb25cbiAgICAgKlxuICAgICAqIEdldCBhIGZ1bmN0aW9uIGV4ZWN1dGlvbiBsb2cgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4ZWN1dGlvbklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICBnZXRFeGVjdXRpb24oZnVuY3Rpb25JZCwgZXhlY3V0aW9uSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleGVjdXRpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImV4ZWN1dGlvbklkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucy97ZnVuY3Rpb25JZH0vZXhlY3V0aW9ucy97ZXhlY3V0aW9uSWR9Jy5yZXBsYWNlKCd7ZnVuY3Rpb25JZH0nLCBmdW5jdGlvbklkKS5yZXBsYWNlKCd7ZXhlY3V0aW9uSWR9JywgZXhlY3V0aW9uSWQpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgR3JhcGhxbCBleHRlbmRzIFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICBzdXBlcihjbGllbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHcmFwaFFMIGVuZHBvaW50XG4gICAgICpcbiAgICAgKiBFeGVjdXRlIGEgR3JhcGhRTCBtdXRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBxdWVyeVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgcXVlcnkocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJxdWVyeVwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9ncmFwaHFsJztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcXVlcnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsncXVlcnknXSA9IHF1ZXJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ3gtc2RrLWdyYXBocWwnOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR3JhcGhRTCBlbmRwb2ludFxuICAgICAqXG4gICAgICogRXhlY3V0ZSBhIEdyYXBoUUwgbXV0YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcXVlcnlcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIG11dGF0aW9uKHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicXVlcnlcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZ3JhcGhxbC9tdXRhdGlvbic7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJ5J10gPSBxdWVyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwge1xuICAgICAgICAgICAgICAgICd4LXNkay1ncmFwaHFsJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBMb2NhbGUgZXh0ZW5kcyBTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgc3VwZXIoY2xpZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHVzZXIgbG9jYWxlXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgdXNlciBsb2NhdGlvbiBiYXNlZCBvbiBJUC4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB1c2VyXG4gICAgICogY291bnRyeSBjb2RlLCBjb3VudHJ5IG5hbWUsIGNvbnRpbmVudCBuYW1lLCBjb250aW5lbnQgY29kZSwgaXAgYWRkcmVzcyBhbmRcbiAgICAgKiBzdWdnZXN0ZWQgY3VycmVuY3kuIFlvdSBjYW4gdXNlIHRoZSBsb2NhbGUgaGVhZGVyIHRvIGdldCB0aGUgZGF0YSBpbiBhXG4gICAgICogc3VwcG9ydGVkIGxhbmd1YWdlLlxuICAgICAqXG4gICAgICogKFtJUCBHZW9sb2NhdGlvbiBieSBEQi1JUF0oaHR0cHM6Ly9kYi1pcC5jb20pKVxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9sb2NhbGUnO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IExvY2FsZSBDb2Rlc1xuICAgICAqXG4gICAgICogTGlzdCBvZiBhbGwgbG9jYWxlIGNvZGVzIGluIFtJU09cbiAgICAgKiA2MzktMV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9JU09fNjM5LTFfY29kZXMpLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICBsaXN0Q29kZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9sb2NhbGUvY29kZXMnO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGNvbnRpbmVudHNcbiAgICAgKlxuICAgICAqIExpc3Qgb2YgYWxsIGNvbnRpbmVudHMuIFlvdSBjYW4gdXNlIHRoZSBsb2NhbGUgaGVhZGVyIHRvIGdldCB0aGUgZGF0YSBpbiBhXG4gICAgICogc3VwcG9ydGVkIGxhbmd1YWdlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICBsaXN0Q29udGluZW50cygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZS9jb250aW5lbnRzJztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBjb3VudHJpZXNcbiAgICAgKlxuICAgICAqIExpc3Qgb2YgYWxsIGNvdW50cmllcy4gWW91IGNhbiB1c2UgdGhlIGxvY2FsZSBoZWFkZXIgdG8gZ2V0IHRoZSBkYXRhIGluIGFcbiAgICAgKiBzdXBwb3J0ZWQgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGxpc3RDb3VudHJpZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9sb2NhbGUvY291bnRyaWVzJztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBFVSBjb3VudHJpZXNcbiAgICAgKlxuICAgICAqIExpc3Qgb2YgYWxsIGNvdW50cmllcyB0aGF0IGFyZSBjdXJyZW50bHkgbWVtYmVycyBvZiB0aGUgRVUuIFlvdSBjYW4gdXNlIHRoZVxuICAgICAqIGxvY2FsZSBoZWFkZXIgdG8gZ2V0IHRoZSBkYXRhIGluIGEgc3VwcG9ydGVkIGxhbmd1YWdlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICBsaXN0Q291bnRyaWVzRVUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9sb2NhbGUvY291bnRyaWVzL2V1JztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBjb3VudHJpZXMgcGhvbmUgY29kZXNcbiAgICAgKlxuICAgICAqIExpc3Qgb2YgYWxsIGNvdW50cmllcyBwaG9uZSBjb2Rlcy4gWW91IGNhbiB1c2UgdGhlIGxvY2FsZSBoZWFkZXIgdG8gZ2V0IHRoZVxuICAgICAqIGRhdGEgaW4gYSBzdXBwb3J0ZWQgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGxpc3RDb3VudHJpZXNQaG9uZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9sb2NhbGUvY291bnRyaWVzL3Bob25lcyc7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgY3VycmVuY2llc1xuICAgICAqXG4gICAgICogTGlzdCBvZiBhbGwgY3VycmVuY2llcywgaW5jbHVkaW5nIGN1cnJlbmN5IHN5bWJvbCwgbmFtZSwgcGx1cmFsLCBhbmRcbiAgICAgKiBkZWNpbWFsIGRpZ2l0cyBmb3IgYWxsIG1ham9yIGFuZCBtaW5vciBjdXJyZW5jaWVzLiBZb3UgY2FuIHVzZSB0aGUgbG9jYWxlXG4gICAgICogaGVhZGVyIHRvIGdldCB0aGUgZGF0YSBpbiBhIHN1cHBvcnRlZCBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgbGlzdEN1cnJlbmNpZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9sb2NhbGUvY3VycmVuY2llcyc7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgbGFuZ3VhZ2VzXG4gICAgICpcbiAgICAgKiBMaXN0IG9mIGFsbCBsYW5ndWFnZXMgY2xhc3NpZmllZCBieSBJU08gNjM5LTEgaW5jbHVkaW5nIDItbGV0dGVyIGNvZGUsIG5hbWVcbiAgICAgKiBpbiBFbmdsaXNoLCBhbmQgbmFtZSBpbiB0aGUgcmVzcGVjdGl2ZSBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgbGlzdExhbmd1YWdlcygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZS9sYW5ndWFnZXMnO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgTWVzc2FnaW5nIGV4dGVuZHMgU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHN1cGVyKGNsaWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBzdWJzY3JpYmVyXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgc3Vic2NyaWJlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BpY0lkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN1YnNjcmliZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgY3JlYXRlU3Vic2NyaWJlcih0b3BpY0lkLCBzdWJzY3JpYmVySWQsIHRhcmdldElkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRvcGljSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0b3BpY0lkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3Vic2NyaWJlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic3Vic2NyaWJlcklkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0YXJnZXRJZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvdG9waWNzL3t0b3BpY0lkfS9zdWJzY3JpYmVycycucmVwbGFjZSgne3RvcGljSWR9JywgdG9waWNJZCk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN1YnNjcmliZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydzdWJzY3JpYmVySWQnXSA9IHN1YnNjcmliZXJJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0SWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsndGFyZ2V0SWQnXSA9IHRhcmdldElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIHN1YnNjcmliZXJcbiAgICAgKlxuICAgICAqIERlbGV0ZSBhIHN1YnNjcmliZXIgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BpY0lkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN1YnNjcmliZXJJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgZGVsZXRlU3Vic2NyaWJlcih0b3BpY0lkLCBzdWJzY3JpYmVySWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9waWNJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRvcGljSWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpYmVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzdWJzY3JpYmVySWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3RvcGljcy97dG9waWNJZH0vc3Vic2NyaWJlcnMve3N1YnNjcmliZXJJZH0nLnJlcGxhY2UoJ3t0b3BpY0lkfScsIHRvcGljSWQpLnJlcGxhY2UoJ3tzdWJzY3JpYmVySWR9Jywgc3Vic2NyaWJlcklkKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIFN0b3JhZ2UgZXh0ZW5kcyBTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgc3VwZXIoY2xpZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBmaWxlc1xuICAgICAqXG4gICAgICogR2V0IGEgbGlzdCBvZiBhbGwgdGhlIHVzZXIgZmlsZXMuIFlvdSBjYW4gdXNlIHRoZSBxdWVyeSBwYXJhbXMgdG8gZmlsdGVyXG4gICAgICogeW91ciByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJ1Y2tldElkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWFyY2hcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGxpc3RGaWxlcyhidWNrZXRJZCwgcXVlcmllcywgc2VhcmNoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0vZmlsZXMnLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3NlYXJjaCddID0gc2VhcmNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZmlsZVxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IGZpbGUuIEJlZm9yZSB1c2luZyB0aGlzIHJvdXRlLCB5b3Ugc2hvdWxkIGNyZWF0ZSBhIG5ldyBidWNrZXRcbiAgICAgKiByZXNvdXJjZSB1c2luZyBlaXRoZXIgYSBbc2VydmVyXG4gICAgICogaW50ZWdyYXRpb25dKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9zZXJ2ZXIvc3RvcmFnZSNzdG9yYWdlQ3JlYXRlQnVja2V0KVxuICAgICAqIEFQSSBvciBkaXJlY3RseSBmcm9tIHlvdXIgQXBwd3JpdGUgY29uc29sZS5cbiAgICAgKlxuICAgICAqIExhcmdlciBmaWxlcyBzaG91bGQgYmUgdXBsb2FkZWQgdXNpbmcgbXVsdGlwbGUgcmVxdWVzdHMgd2l0aCB0aGVcbiAgICAgKiBbY29udGVudC1yYW5nZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0NvbnRlbnQtUmFuZ2UpXG4gICAgICogaGVhZGVyIHRvIHNlbmQgYSBwYXJ0aWFsIHJlcXVlc3Qgd2l0aCBhIG1heGltdW0gc3VwcG9ydGVkIGNodW5rIG9mIGA1TUJgLlxuICAgICAqIFRoZSBgY29udGVudC1yYW5nZWAgaGVhZGVyIHZhbHVlcyBzaG91bGQgYWx3YXlzIGJlIGluIGJ5dGVzLlxuICAgICAqXG4gICAgICogV2hlbiB0aGUgZmlyc3QgcmVxdWVzdCBpcyBzZW50LCB0aGUgc2VydmVyIHdpbGwgcmV0dXJuIHRoZSAqKkZpbGUqKiBvYmplY3QsXG4gICAgICogYW5kIHRoZSBzdWJzZXF1ZW50IHBhcnQgcmVxdWVzdCBtdXN0IGluY2x1ZGUgdGhlIGZpbGUncyAqKmlkKiogaW5cbiAgICAgKiBgeC1hcHB3cml0ZS1pZGAgaGVhZGVyIHRvIGFsbG93IHRoZSBzZXJ2ZXIgdG8ga25vdyB0aGF0IHRoZSBwYXJ0aWFsIHVwbG9hZFxuICAgICAqIGlzIGZvciB0aGUgZXhpc3RpbmcgZmlsZSBhbmQgbm90IGZvciBhIG5ldyBvbmUuXG4gICAgICpcbiAgICAgKiBJZiB5b3UncmUgY3JlYXRpbmcgYSBuZXcgZmlsZSB1c2luZyBvbmUgb2YgdGhlIEFwcHdyaXRlIFNES3MsIGFsbCB0aGVcbiAgICAgKiBjaHVua2luZyBsb2dpYyB3aWxsIGJlIG1hbmFnZWQgYnkgdGhlIFNESyBpbnRlcm5hbGx5LlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnVja2V0SWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlkXG4gICAgICogQHBhcmFtIHtGaWxlfSBmaWxlXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGVybWlzc2lvbnNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGNyZWF0ZUZpbGUoYnVja2V0SWQsIGZpbGVJZCwgZmlsZSwgcGVybWlzc2lvbnMsIG9uUHJvZ3Jlc3MgPSAocHJvZ3Jlc3MpID0+IHsgfSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImJ1Y2tldElkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZmlsZUlkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZpbGVcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0vZmlsZXMnLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpbGVJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydmaWxlSWQnXSA9IGZpbGVJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydmaWxlJ10gPSBmaWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwZXJtaXNzaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydwZXJtaXNzaW9ucyddID0gcGVybWlzc2lvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdQYXJhbWV0ZXIgXCJmaWxlXCIgaGFzIHRvIGJlIGEgRmlsZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBmaWxlLnNpemU7XG4gICAgICAgICAgICBpZiAoc2l6ZSA8PSBTZXJ2aWNlLkNIVU5LX1NJWkUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwge1xuICAgICAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGEnLFxuICAgICAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGEnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGZpbGVJZCAhPSAndW5pcXVlKCknKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdHRVQnLCBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGggKyAnLycgKyBmaWxlSWQpLCBhcGlIZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gcmVzcG9uc2UuY2h1bmtzVXBsb2FkZWQgKiBTZXJ2aWNlLkNIVU5LX1NJWkU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IHNpemUpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gTWF0aC5taW4ob2Zmc2V0ICsgU2VydmljZS5DSFVOS19TSVpFIC0gMSwgc2l6ZSAtIDEpO1xuICAgICAgICAgICAgICAgIGFwaUhlYWRlcnNbJ2NvbnRlbnQtcmFuZ2UnXSA9ICdieXRlcyAnICsgb2Zmc2V0ICsgJy0nICsgZW5kICsgJy8nICsgc2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UuJGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwaUhlYWRlcnNbJ3gtYXBwd3JpdGUtaWQnXSA9IHJlc3BvbnNlLiRpZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBmaWxlLnNsaWNlKG9mZnNldCwgZW5kICsgMSk7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsnZmlsZSddID0gbmV3IEZpbGUoW2NodW5rXSwgZmlsZS5uYW1lKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgJGlkOiByZXNwb25zZS4kaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogKG9mZnNldCAvIHNpemUpICogMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZVVwbG9hZGVkOiBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua3NUb3RhbDogcmVzcG9uc2UuY2h1bmtzVG90YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua3NVcGxvYWRlZDogcmVzcG9uc2UuY2h1bmtzVXBsb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBTZXJ2aWNlLkNIVU5LX1NJWkU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZmlsZVxuICAgICAqXG4gICAgICogR2V0IGEgZmlsZSBieSBpdHMgdW5pcXVlIElELiBUaGlzIGVuZHBvaW50IHJlc3BvbnNlIHJldHVybnMgYSBKU09OIG9iamVjdFxuICAgICAqIHdpdGggdGhlIGZpbGUgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnVja2V0SWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICBnZXRGaWxlKGJ1Y2tldElkLCBmaWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYnVja2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpbGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZpbGVJZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9zdG9yYWdlL2J1Y2tldHMve2J1Y2tldElkfS9maWxlcy97ZmlsZUlkfScucmVwbGFjZSgne2J1Y2tldElkfScsIGJ1Y2tldElkKS5yZXBsYWNlKCd7ZmlsZUlkfScsIGZpbGVJZCk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBmaWxlXG4gICAgICpcbiAgICAgKiBVcGRhdGUgYSBmaWxlIGJ5IGl0cyB1bmlxdWUgSUQuIE9ubHkgdXNlcnMgd2l0aCB3cml0ZSBwZXJtaXNzaW9ucyBoYXZlXG4gICAgICogYWNjZXNzIHRvIHVwZGF0ZSB0aGlzIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJ1Y2tldElkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGVybWlzc2lvbnNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIHVwZGF0ZUZpbGUoYnVja2V0SWQsIGZpbGVJZCwgbmFtZSwgcGVybWlzc2lvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYnVja2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpbGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZpbGVJZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9zdG9yYWdlL2J1Y2tldHMve2J1Y2tldElkfS9maWxlcy97ZmlsZUlkfScucmVwbGFjZSgne2J1Y2tldElkfScsIGJ1Y2tldElkKS5yZXBsYWNlKCd7ZmlsZUlkfScsIGZpbGVJZCk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGVybWlzc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsncGVybWlzc2lvbnMnXSA9IHBlcm1pc3Npb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgRmlsZVxuICAgICAqXG4gICAgICogRGVsZXRlIGEgZmlsZSBieSBpdHMgdW5pcXVlIElELiBPbmx5IHVzZXJzIHdpdGggd3JpdGUgcGVybWlzc2lvbnMgaGF2ZVxuICAgICAqIGFjY2VzcyB0byBkZWxldGUgdGhpcyByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBidWNrZXRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGRlbGV0ZUZpbGUoYnVja2V0SWQsIGZpbGVJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImJ1Y2tldElkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZmlsZUlkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9L2ZpbGVzL3tmaWxlSWR9Jy5yZXBsYWNlKCd7YnVja2V0SWR9JywgYnVja2V0SWQpLnJlcGxhY2UoJ3tmaWxlSWR9JywgZmlsZUlkKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGZpbGUgZm9yIGRvd25sb2FkXG4gICAgICpcbiAgICAgKiBHZXQgYSBmaWxlIGNvbnRlbnQgYnkgaXRzIHVuaXF1ZSBJRC4gVGhlIGVuZHBvaW50IHJlc3BvbnNlIHJldHVybiB3aXRoIGFcbiAgICAgKiAnQ29udGVudC1EaXNwb3NpdGlvbjogYXR0YWNobWVudCcgaGVhZGVyIHRoYXQgdGVsbHMgdGhlIGJyb3dzZXIgdG8gc3RhcnRcbiAgICAgKiBkb3dubG9hZGluZyB0aGUgZmlsZSB0byB1c2VyIGRvd25sb2FkcyBkaXJlY3RvcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnVja2V0SWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1VSTH1cbiAgICAqL1xuICAgIGdldEZpbGVEb3dubG9hZChidWNrZXRJZCwgZmlsZUlkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYnVja2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImJ1Y2tldElkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZpbGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZmlsZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9zdG9yYWdlL2J1Y2tldHMve2J1Y2tldElkfS9maWxlcy97ZmlsZUlkfS9kb3dubG9hZCcucmVwbGFjZSgne2J1Y2tldElkfScsIGJ1Y2tldElkKS5yZXBsYWNlKCd7ZmlsZUlkfScsIGZpbGVJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgcGF5bG9hZFsncHJvamVjdCddID0gdGhpcy5jbGllbnQuY29uZmlnLnByb2plY3Q7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKFNlcnZpY2UuZmxhdHRlbihwYXlsb2FkKSkpIHtcbiAgICAgICAgICAgIHVyaS5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBmaWxlIHByZXZpZXdcbiAgICAgKlxuICAgICAqIEdldCBhIGZpbGUgcHJldmlldyBpbWFnZS4gQ3VycmVudGx5LCB0aGlzIG1ldGhvZCBzdXBwb3J0cyBwcmV2aWV3IGZvciBpbWFnZVxuICAgICAqIGZpbGVzIChqcGcsIHBuZywgYW5kIGdpZiksIG90aGVyIHN1cHBvcnRlZCBmb3JtYXRzLCBsaWtlIHBkZiwgZG9jcywgc2xpZGVzLFxuICAgICAqIGFuZCBzcHJlYWRzaGVldHMsIHdpbGwgcmV0dXJuIHRoZSBmaWxlIGljb24gaW1hZ2UuIFlvdSBjYW4gYWxzbyBwYXNzIHF1ZXJ5XG4gICAgICogc3RyaW5nIGFyZ3VtZW50cyBmb3IgY3V0dGluZyBhbmQgcmVzaXppbmcgeW91ciBwcmV2aWV3IGltYWdlLiBQcmV2aWV3IGlzXG4gICAgICogc3VwcG9ydGVkIG9ubHkgZm9yIGltYWdlIGZpbGVzIHNtYWxsZXIgdGhhbiAxME1CLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJ1Y2tldElkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0ltYWdlR3Jhdml0eX0gZ3Jhdml0eVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBxdWFsaXR5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJvcmRlcldpZHRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJvcmRlckNvbG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJvcmRlclJhZGl1c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhY2tncm91bmRcbiAgICAgKiBAcGFyYW0ge0ltYWdlRm9ybWF0fSBvdXRwdXRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7VVJMfVxuICAgICovXG4gICAgZ2V0RmlsZVByZXZpZXcoYnVja2V0SWQsIGZpbGVJZCwgd2lkdGgsIGhlaWdodCwgZ3Jhdml0eSwgcXVhbGl0eSwgYm9yZGVyV2lkdGgsIGJvcmRlckNvbG9yLCBib3JkZXJSYWRpdXMsIG9wYWNpdHksIHJvdGF0aW9uLCBiYWNrZ3JvdW5kLCBvdXRwdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmaWxlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9L2ZpbGVzL3tmaWxlSWR9L3ByZXZpZXcnLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCkucmVwbGFjZSgne2ZpbGVJZH0nLCBmaWxlSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd3aWR0aCddID0gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydoZWlnaHQnXSA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdyYXZpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydncmF2aXR5J10gPSBncmF2aXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcXVhbGl0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1YWxpdHknXSA9IHF1YWxpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBib3JkZXJXaWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2JvcmRlcldpZHRoJ10gPSBib3JkZXJXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGJvcmRlckNvbG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYm9yZGVyQ29sb3InXSA9IGJvcmRlckNvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYm9yZGVyUmFkaXVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYm9yZGVyUmFkaXVzJ10gPSBib3JkZXJSYWRpdXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcGFjaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb3BhY2l0eSddID0gb3BhY2l0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJvdGF0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncm90YXRpb24nXSA9IHJvdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYmFja2dyb3VuZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2JhY2tncm91bmQnXSA9IGJhY2tncm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvdXRwdXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydvdXRwdXQnXSA9IG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBwYXlsb2FkWydwcm9qZWN0J10gPSB0aGlzLmNsaWVudC5jb25maWcucHJvamVjdDtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoU2VydmljZS5mbGF0dGVuKHBheWxvYWQpKSkge1xuICAgICAgICAgICAgdXJpLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGZpbGUgZm9yIHZpZXdcbiAgICAgKlxuICAgICAqIEdldCBhIGZpbGUgY29udGVudCBieSBpdHMgdW5pcXVlIElELiBUaGlzIGVuZHBvaW50IGlzIHNpbWlsYXIgdG8gdGhlXG4gICAgICogZG93bmxvYWQgbWV0aG9kIGJ1dCByZXR1cm5zIHdpdGggbm8gICdDb250ZW50LURpc3Bvc2l0aW9uOiBhdHRhY2htZW50J1xuICAgICAqIGhlYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBidWNrZXRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7VVJMfVxuICAgICovXG4gICAgZ2V0RmlsZVZpZXcoYnVja2V0SWQsIGZpbGVJZCkge1xuICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZpbGVJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0vZmlsZXMve2ZpbGVJZH0vdmlldycucmVwbGFjZSgne2J1Y2tldElkfScsIGJ1Y2tldElkKS5yZXBsYWNlKCd7ZmlsZUlkfScsIGZpbGVJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgcGF5bG9hZFsncHJvamVjdCddID0gdGhpcy5jbGllbnQuY29uZmlnLnByb2plY3Q7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKFNlcnZpY2UuZmxhdHRlbihwYXlsb2FkKSkpIHtcbiAgICAgICAgICAgIHVyaS5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmk7XG4gICAgfVxufVxuXG5jbGFzcyBUZWFtcyBleHRlbmRzIFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICBzdXBlcihjbGllbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IHRlYW1zXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGFsbCB0aGUgdGVhbXMgaW4gd2hpY2ggdGhlIGN1cnJlbnQgdXNlciBpcyBhIG1lbWJlci4gWW91IGNhblxuICAgICAqIHVzZSB0aGUgcGFyYW1ldGVycyB0byBmaWx0ZXIgeW91ciByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWFyY2hcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGxpc3QocXVlcmllcywgc2VhcmNoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcyc7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3NlYXJjaCddID0gc2VhcmNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGVhbVxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IHRlYW0uIFRoZSB1c2VyIHdobyBjcmVhdGVzIHRoZSB0ZWFtIHdpbGwgYXV0b21hdGljYWxseSBiZVxuICAgICAqIGFzc2lnbmVkIGFzIHRoZSBvd25lciBvZiB0aGUgdGVhbS4gT25seSB0aGUgdXNlcnMgd2l0aCB0aGUgb3duZXIgcm9sZSBjYW5cbiAgICAgKiBpbnZpdGUgbmV3IG1lbWJlcnMsIGFkZCBuZXcgb3duZXJzIGFuZCBkZWxldGUgb3IgdXBkYXRlIHRoZSB0ZWFtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlYW1JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcm9sZXNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGNyZWF0ZSh0ZWFtSWQsIG5hbWUsIHJvbGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJuYW1lXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zJztcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGVhbUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3RlYW1JZCddID0gdGVhbUlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJvbGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3JvbGVzJ10gPSByb2xlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0ZWFtXG4gICAgICpcbiAgICAgKiBHZXQgYSB0ZWFtIGJ5IGl0cyBJRC4gQWxsIHRlYW0gbWVtYmVycyBoYXZlIHJlYWQgYWNjZXNzIGZvciB0aGlzIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlYW1JZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgZ2V0KHRlYW1JZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0nLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIG5hbWVcbiAgICAgKlxuICAgICAqIFVwZGF0ZSB0aGUgdGVhbSdzIG5hbWUgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWFtSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgdXBkYXRlTmFtZSh0ZWFtSWQsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm5hbWVcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0nLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgdGVhbVxuICAgICAqXG4gICAgICogRGVsZXRlIGEgdGVhbSB1c2luZyBpdHMgSUQuIE9ubHkgdGVhbSBtZW1iZXJzIHdpdGggdGhlIG93bmVyIHJvbGUgY2FuXG4gICAgICogZGVsZXRlIHRoZSB0ZWFtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlYW1JZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgZGVsZXRlKHRlYW1JZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0nLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCB0ZWFtIG1lbWJlcnNoaXBzXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBsaXN0IGEgdGVhbSdzIG1lbWJlcnMgdXNpbmcgdGhlIHRlYW0ncyBJRC4gQWxsIHRlYW1cbiAgICAgKiBtZW1iZXJzIGhhdmUgcmVhZCBhY2Nlc3MgdG8gdGhpcyBlbmRwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWFtSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgbGlzdE1lbWJlcnNoaXBzKHRlYW1JZCwgcXVlcmllcywgc2VhcmNoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfS9tZW1iZXJzaGlwcycucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlYXJjaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydzZWFyY2gnXSA9IHNlYXJjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRlYW0gbWVtYmVyc2hpcFxuICAgICAqXG4gICAgICogSW52aXRlIGEgbmV3IG1lbWJlciB0byBqb2luIHlvdXIgdGVhbS4gUHJvdmlkZSBhbiBJRCBmb3IgZXhpc3RpbmcgdXNlcnMsIG9yXG4gICAgICogaW52aXRlIHVucmVnaXN0ZXJlZCB1c2VycyB1c2luZyBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIuIElmIGluaXRpYXRlZCBmcm9tXG4gICAgICogYSBDbGllbnQgU0RLLCBBcHB3cml0ZSB3aWxsIHNlbmQgYW4gZW1haWwgb3Igc21zIHdpdGggYSBsaW5rIHRvIGpvaW4gdGhlXG4gICAgICogdGVhbSB0byB0aGUgaW52aXRlZCB1c2VyLCBhbmQgYW4gYWNjb3VudCB3aWxsIGJlIGNyZWF0ZWQgZm9yIHRoZW0gaWYgb25lXG4gICAgICogZG9lc24ndCBleGlzdC4gSWYgaW5pdGlhdGVkIGZyb20gYSBTZXJ2ZXIgU0RLLCB0aGUgbmV3IG1lbWJlciB3aWxsIGJlIGFkZGVkXG4gICAgICogYXV0b21hdGljYWxseSB0byB0aGUgdGVhbS5cbiAgICAgKlxuICAgICAqIFlvdSBvbmx5IG5lZWQgdG8gcHJvdmlkZSBvbmUgb2YgYSB1c2VyIElELCBlbWFpbCwgb3IgcGhvbmUgbnVtYmVyLiBBcHB3cml0ZVxuICAgICAqIHdpbGwgcHJpb3JpdGl6ZSBhY2NlcHRpbmcgdGhlIHVzZXIgSUQgPiBlbWFpbCA+IHBob25lIG51bWJlciBpZiB5b3UgcHJvdmlkZVxuICAgICAqIG1vcmUgdGhhbiBvbmUgb2YgdGhlc2UgcGFyYW1ldGVycy5cbiAgICAgKlxuICAgICAqIFVzZSB0aGUgYHVybGAgcGFyYW1ldGVyIHRvIHJlZGlyZWN0IHRoZSB1c2VyIGZyb20gdGhlIGludml0YXRpb24gZW1haWwgdG9cbiAgICAgKiB5b3VyIGFwcC4gQWZ0ZXIgdGhlIHVzZXIgaXMgcmVkaXJlY3RlZCwgdXNlIHRoZSBbVXBkYXRlIFRlYW0gTWVtYmVyc2hpcFxuICAgICAqIFN0YXR1c10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi90ZWFtcyN1cGRhdGVNZW1iZXJzaGlwU3RhdHVzKVxuICAgICAqIGVuZHBvaW50IHRvIGFsbG93IHRoZSB1c2VyIHRvIGFjY2VwdCB0aGUgaW52aXRhdGlvbiB0byB0aGUgdGVhbS5cbiAgICAgKlxuICAgICAqIFBsZWFzZSBub3RlIHRoYXQgdG8gYXZvaWQgYSBbUmVkaXJlY3RcbiAgICAgKiBBdHRhY2tdKGh0dHBzOi8vZ2l0aHViLmNvbS9PV0FTUC9DaGVhdFNoZWV0U2VyaWVzL2Jsb2IvbWFzdGVyL2NoZWF0c2hlZXRzL1VudmFsaWRhdGVkX1JlZGlyZWN0c19hbmRfRm9yd2FyZHNfQ2hlYXRfU2hlZXQubWQpXG4gICAgICogQXBwd3JpdGUgd2lsbCBhY2NlcHQgdGhlIG9ubHkgcmVkaXJlY3QgVVJMcyB1bmRlciB0aGUgZG9tYWlucyB5b3UgaGF2ZVxuICAgICAqIGFkZGVkIGFzIGEgcGxhdGZvcm0gb24gdGhlIEFwcHdyaXRlIENvbnNvbGUuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWFtSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSByb2xlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGhvbmVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGNyZWF0ZU1lbWJlcnNoaXAodGVhbUlkLCByb2xlcywgZW1haWwsIHVzZXJJZCwgcGhvbmUsIHVybCwgbmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiByb2xlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJvbGVzXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9L21lbWJlcnNoaXBzJy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwaG9uZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydwaG9uZSddID0gcGhvbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJvbGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3JvbGVzJ10gPSByb2xlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3VybCddID0gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGVhbSBtZW1iZXJzaGlwXG4gICAgICpcbiAgICAgKiBHZXQgYSB0ZWFtIG1lbWJlciBieSB0aGUgbWVtYmVyc2hpcCB1bmlxdWUgaWQuIEFsbCB0ZWFtIG1lbWJlcnMgaGF2ZSByZWFkXG4gICAgICogYWNjZXNzIGZvciB0aGlzIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlYW1JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZW1iZXJzaGlwSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGdldE1lbWJlcnNoaXAodGVhbUlkLCBtZW1iZXJzaGlwSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVtYmVyc2hpcElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibWVtYmVyc2hpcElkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9L21lbWJlcnNoaXBzL3ttZW1iZXJzaGlwSWR9Jy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCkucmVwbGFjZSgne21lbWJlcnNoaXBJZH0nLCBtZW1iZXJzaGlwSWQpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgbWVtYmVyc2hpcFxuICAgICAqXG4gICAgICogTW9kaWZ5IHRoZSByb2xlcyBvZiBhIHRlYW0gbWVtYmVyLiBPbmx5IHRlYW0gbWVtYmVycyB3aXRoIHRoZSBvd25lciByb2xlXG4gICAgICogaGF2ZSBhY2Nlc3MgdG8gdGhpcyBlbmRwb2ludC4gTGVhcm4gbW9yZSBhYm91dCBbcm9sZXMgYW5kXG4gICAgICogcGVybWlzc2lvbnNdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9wZXJtaXNzaW9ucykuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWFtSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVtYmVyc2hpcElkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcm9sZXNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIHVwZGF0ZU1lbWJlcnNoaXAodGVhbUlkLCBtZW1iZXJzaGlwSWQsIHJvbGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lbWJlcnNoaXBJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1lbWJlcnNoaXBJZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJvbGVzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicm9sZXNcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0vbWVtYmVyc2hpcHMve21lbWJlcnNoaXBJZH0nLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKS5yZXBsYWNlKCd7bWVtYmVyc2hpcElkfScsIG1lbWJlcnNoaXBJZCk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJvbGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3JvbGVzJ10gPSByb2xlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgdGVhbSBtZW1iZXJzaGlwXG4gICAgICpcbiAgICAgKiBUaGlzIGVuZHBvaW50IGFsbG93cyBhIHVzZXIgdG8gbGVhdmUgYSB0ZWFtIG9yIGZvciBhIHRlYW0gb3duZXIgdG8gZGVsZXRlXG4gICAgICogdGhlIG1lbWJlcnNoaXAgb2YgYW55IG90aGVyIHRlYW0gbWVtYmVyLiBZb3UgY2FuIGFsc28gdXNlIHRoaXMgZW5kcG9pbnQgdG9cbiAgICAgKiBkZWxldGUgYSB1c2VyIG1lbWJlcnNoaXAgZXZlbiBpZiBpdCBpcyBub3QgYWNjZXB0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVhbUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lbWJlcnNoaXBJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgZGVsZXRlTWVtYmVyc2hpcCh0ZWFtSWQsIG1lbWJlcnNoaXBJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZW1iZXJzaGlwSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtZW1iZXJzaGlwSWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0vbWVtYmVyc2hpcHMve21lbWJlcnNoaXBJZH0nLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKS5yZXBsYWNlKCd7bWVtYmVyc2hpcElkfScsIG1lbWJlcnNoaXBJZCk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0ZWFtIG1lbWJlcnNoaXAgc3RhdHVzXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBhbGxvdyBhIHVzZXIgdG8gYWNjZXB0IGFuIGludml0YXRpb24gdG8gam9pbiBhIHRlYW1cbiAgICAgKiBhZnRlciBiZWluZyByZWRpcmVjdGVkIGJhY2sgdG8geW91ciBhcHAgZnJvbSB0aGUgaW52aXRhdGlvbiBlbWFpbCByZWNlaXZlZFxuICAgICAqIGJ5IHRoZSB1c2VyLlxuICAgICAqXG4gICAgICogSWYgdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bCwgYSBzZXNzaW9uIGZvciB0aGUgdXNlciBpcyBhdXRvbWF0aWNhbGx5XG4gICAgICogY3JlYXRlZC5cbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlYW1JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZW1iZXJzaGlwSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlY3JldFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgdXBkYXRlTWVtYmVyc2hpcFN0YXR1cyh0ZWFtSWQsIG1lbWJlcnNoaXBJZCwgdXNlcklkLCBzZWNyZXQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVtYmVyc2hpcElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibWVtYmVyc2hpcElkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2VjcmV0XCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9L21lbWJlcnNoaXBzL3ttZW1iZXJzaGlwSWR9L3N0YXR1cycucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpLnJlcGxhY2UoJ3ttZW1iZXJzaGlwSWR9JywgbWVtYmVyc2hpcElkKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFsnc2VjcmV0J10gPSBzZWNyZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRlYW0gcHJlZmVyZW5jZXNcbiAgICAgKlxuICAgICAqIEdldCB0aGUgdGVhbSdzIHNoYXJlZCBwcmVmZXJlbmNlcyBieSBpdHMgdW5pcXVlIElELiBJZiBhIHByZWZlcmVuY2UgZG9lc24ndFxuICAgICAqIG5lZWQgdG8gYmUgc2hhcmVkIGJ5IGFsbCB0ZWFtIG1lbWJlcnMsIHByZWZlciBzdG9yaW5nIHRoZW0gaW4gW3VzZXJcbiAgICAgKiBwcmVmZXJlbmNlc10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2dldFByZWZzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWFtSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIGdldFByZWZzKHRlYW1JZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0vcHJlZnMnLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHByZWZlcmVuY2VzXG4gICAgICpcbiAgICAgKiBVcGRhdGUgdGhlIHRlYW0ncyBwcmVmZXJlbmNlcyBieSBpdHMgdW5pcXVlIElELiBUaGUgb2JqZWN0IHlvdSBwYXNzIGlzXG4gICAgICogc3RvcmVkIGFzIGlzIGFuZCByZXBsYWNlcyBhbnkgcHJldmlvdXMgdmFsdWUuIFRoZSBtYXhpbXVtIGFsbG93ZWQgcHJlZnNcbiAgICAgKiBzaXplIGlzIDY0a0IgYW5kIHRocm93cyBhbiBlcnJvciBpZiBleGNlZWRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWFtSWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJlZnNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAqL1xuICAgIHVwZGF0ZVByZWZzKHRlYW1JZCwgcHJlZnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJlZnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcmVmc1wiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfS9wcmVmcycucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmVmcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkWydwcmVmcyddID0gcHJlZnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIHVyaSwge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBQZXJtaXNzaW9uIHtcbn1cblBlcm1pc3Npb24ucmVhZCA9IChyb2xlKSA9PiB7XG4gICAgcmV0dXJuIGByZWFkKFwiJHtyb2xlfVwiKWA7XG59O1xuUGVybWlzc2lvbi53cml0ZSA9IChyb2xlKSA9PiB7XG4gICAgcmV0dXJuIGB3cml0ZShcIiR7cm9sZX1cIilgO1xufTtcblBlcm1pc3Npb24uY3JlYXRlID0gKHJvbGUpID0+IHtcbiAgICByZXR1cm4gYGNyZWF0ZShcIiR7cm9sZX1cIilgO1xufTtcblBlcm1pc3Npb24udXBkYXRlID0gKHJvbGUpID0+IHtcbiAgICByZXR1cm4gYHVwZGF0ZShcIiR7cm9sZX1cIilgO1xufTtcblBlcm1pc3Npb24uZGVsZXRlID0gKHJvbGUpID0+IHtcbiAgICByZXR1cm4gYGRlbGV0ZShcIiR7cm9sZX1cIilgO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8gZ2VuZXJhdGUgcm9sZSBzdHJpbmdzIGZvciBgUGVybWlzc2lvbmAuXG4gKi9cbmNsYXNzIFJvbGUge1xuICAgIC8qKlxuICAgICAqIEdyYW50cyBhY2Nlc3MgdG8gYW55b25lLlxuICAgICAqXG4gICAgICogVGhpcyBpbmNsdWRlcyBhdXRoZW50aWNhdGVkIGFuZCB1bmF1dGhlbnRpY2F0ZWQgdXNlcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBhbnkoKSB7XG4gICAgICAgIHJldHVybiAnYW55JztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR3JhbnRzIGFjY2VzcyB0byBhIHNwZWNpZmljIHVzZXIgYnkgdXNlciBJRC5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIHZlcmlmaWVkIG9yIHVudmVyaWZpZWQgZm9yXG4gICAgICogYHN0YXR1c2AgdG8gdGFyZ2V0IHNwZWNpZmljIHR5cGVzIG9mIHVzZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXR1c1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIHVzZXIoaWQsIHN0YXR1cyA9ICcnKSB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gYHVzZXI6JHtpZH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgdXNlcjoke2lkfS8ke3N0YXR1c31gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHcmFudHMgYWNjZXNzIHRvIGFueSBhdXRoZW50aWNhdGVkIG9yIGFub255bW91cyB1c2VyLlxuICAgICAqXG4gICAgICogWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgdmVyaWZpZWQgb3IgdW52ZXJpZmllZCBmb3JcbiAgICAgKiBgc3RhdHVzYCB0byB0YXJnZXQgc3BlY2lmaWMgdHlwZXMgb2YgdXNlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdHVzXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgdXNlcnMoc3RhdHVzID0gJycpIHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiAndXNlcnMnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgdXNlcnMvJHtzdGF0dXN9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR3JhbnRzIGFjY2VzcyB0byBhbnkgZ3Vlc3QgdXNlciB3aXRob3V0IGEgc2Vzc2lvbi5cbiAgICAgKlxuICAgICAqIEF1dGhlbnRpY2F0ZWQgdXNlcnMgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhpcyByb2xlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZ3Vlc3RzKCkge1xuICAgICAgICByZXR1cm4gJ2d1ZXN0cyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdyYW50cyBhY2Nlc3MgdG8gYSB0ZWFtIGJ5IHRlYW0gSUQuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIG9wdGlvbmFsbHkgcGFzcyBhIHJvbGUgZm9yIGByb2xlYCB0byB0YXJnZXRcbiAgICAgKiB0ZWFtIG1lbWJlcnMgd2l0aCB0aGUgc3BlY2lmaWVkIHJvbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcm9sZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIHRlYW0oaWQsIHJvbGUgPSAnJykge1xuICAgICAgICBpZiAocm9sZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBgdGVhbToke2lkfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGB0ZWFtOiR7aWR9LyR7cm9sZX1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHcmFudHMgYWNjZXNzIHRvIGEgc3BlY2lmaWMgbWVtYmVyIG9mIGEgdGVhbS5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhlIG1lbWJlciBpcyByZW1vdmVkIGZyb20gdGhlIHRlYW0sIHRoZXkgd2lsbFxuICAgICAqIG5vIGxvbmdlciBoYXZlIGFjY2Vzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIG1lbWJlcihpZCkge1xuICAgICAgICByZXR1cm4gYG1lbWJlcjoke2lkfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdyYW50cyBhY2Nlc3MgdG8gYSB1c2VyIHdpdGggdGhlIHNwZWNpZmllZCBsYWJlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMgIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIGxhYmVsKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGBsYWJlbDoke25hbWV9YDtcbiAgICB9XG59XG5cbnZhciBfYSwgX0lEX2hleFRpbWVzdGFtcDtcbmNsYXNzIElEIHtcbiAgICBzdGF0aWMgY3VzdG9tKGlkKSB7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgc3RhdGljIHVuaXF1ZShwYWRkaW5nID0gNykge1xuICAgICAgICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBJRCB3aXRoIHBhZGRpbmcgdG8gaGF2ZSBhIGxvbmdlciBJRFxuICAgICAgICBjb25zdCBiYXNlSWQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KElELCBfYSwgXCJtXCIsIF9JRF9oZXhUaW1lc3RhbXApLmNhbGwoSUQpO1xuICAgICAgICBsZXQgcmFuZG9tUGFkZGluZyA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZGRpbmc7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcmFuZG9tSGV4RGlnaXQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxNikudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmFuZG9tUGFkZGluZyArPSByYW5kb21IZXhEaWdpdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZUlkICsgcmFuZG9tUGFkZGluZztcbiAgICB9XG59XG5fYSA9IElELCBfSURfaGV4VGltZXN0YW1wID0gZnVuY3Rpb24gX0lEX2hleFRpbWVzdGFtcCgpIHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IHNlYyA9IE1hdGguZmxvb3Iobm93LmdldFRpbWUoKSAvIDEwMDApO1xuICAgIGNvbnN0IG1zZWMgPSBub3cuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgLy8gQ29udmVydCB0byBoZXhhZGVjaW1hbFxuICAgIGNvbnN0IGhleFRpbWVzdGFtcCA9IHNlYy50b1N0cmluZygxNikgKyBtc2VjLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg1LCAnMCcpO1xuICAgIHJldHVybiBoZXhUaW1lc3RhbXA7XG59O1xuXG52YXIgQXV0aGVudGljYXRvclR5cGU7XG4oZnVuY3Rpb24gKEF1dGhlbnRpY2F0b3JUeXBlKSB7XG4gICAgQXV0aGVudGljYXRvclR5cGVbXCJUb3RwXCJdID0gXCJ0b3RwXCI7XG59KShBdXRoZW50aWNhdG9yVHlwZSB8fCAoQXV0aGVudGljYXRvclR5cGUgPSB7fSkpO1xuXG52YXIgQXV0aGVudGljYXRpb25GYWN0b3I7XG4oZnVuY3Rpb24gKEF1dGhlbnRpY2F0aW9uRmFjdG9yKSB7XG4gICAgQXV0aGVudGljYXRpb25GYWN0b3JbXCJFbWFpbFwiXSA9IFwiZW1haWxcIjtcbiAgICBBdXRoZW50aWNhdGlvbkZhY3RvcltcIlBob25lXCJdID0gXCJwaG9uZVwiO1xuICAgIEF1dGhlbnRpY2F0aW9uRmFjdG9yW1wiVG90cFwiXSA9IFwidG90cFwiO1xuICAgIEF1dGhlbnRpY2F0aW9uRmFjdG9yW1wiUmVjb3Zlcnljb2RlXCJdID0gXCJyZWNvdmVyeWNvZGVcIjtcbn0pKEF1dGhlbnRpY2F0aW9uRmFjdG9yIHx8IChBdXRoZW50aWNhdGlvbkZhY3RvciA9IHt9KSk7XG5cbnZhciBPQXV0aFByb3ZpZGVyO1xuKGZ1bmN0aW9uIChPQXV0aFByb3ZpZGVyKSB7XG4gICAgT0F1dGhQcm92aWRlcltcIkFtYXpvblwiXSA9IFwiYW1hem9uXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIkFwcGxlXCJdID0gXCJhcHBsZVwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJBdXRoMFwiXSA9IFwiYXV0aDBcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiQXV0aGVudGlrXCJdID0gXCJhdXRoZW50aWtcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiQXV0b2Rlc2tcIl0gPSBcImF1dG9kZXNrXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIkJpdGJ1Y2tldFwiXSA9IFwiYml0YnVja2V0XCI7XG4gICAgT0F1dGhQcm92aWRlcltcIkJpdGx5XCJdID0gXCJiaXRseVwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJCb3hcIl0gPSBcImJveFwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJEYWlseW1vdGlvblwiXSA9IFwiZGFpbHltb3Rpb25cIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiRGlzY29yZFwiXSA9IFwiZGlzY29yZFwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJEaXNxdXNcIl0gPSBcImRpc3F1c1wiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJEcm9wYm94XCJdID0gXCJkcm9wYm94XCI7XG4gICAgT0F1dGhQcm92aWRlcltcIkV0c3lcIl0gPSBcImV0c3lcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiRmFjZWJvb2tcIl0gPSBcImZhY2Vib29rXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIkdpdGh1YlwiXSA9IFwiZ2l0aHViXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIkdpdGxhYlwiXSA9IFwiZ2l0bGFiXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIkdvb2dsZVwiXSA9IFwiZ29vZ2xlXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIkxpbmtlZGluXCJdID0gXCJsaW5rZWRpblwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJNaWNyb3NvZnRcIl0gPSBcIm1pY3Jvc29mdFwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJOb3Rpb25cIl0gPSBcIm5vdGlvblwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJPaWRjXCJdID0gXCJvaWRjXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIk9rdGFcIl0gPSBcIm9rdGFcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiUGF5cGFsXCJdID0gXCJwYXlwYWxcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiUGF5cGFsU2FuZGJveFwiXSA9IFwicGF5cGFsU2FuZGJveFwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJQb2Rpb1wiXSA9IFwicG9kaW9cIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiU2FsZXNmb3JjZVwiXSA9IFwic2FsZXNmb3JjZVwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJTbGFja1wiXSA9IFwic2xhY2tcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiU3BvdGlmeVwiXSA9IFwic3BvdGlmeVwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJTdHJpcGVcIl0gPSBcInN0cmlwZVwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJUcmFkZXNoaWZ0XCJdID0gXCJ0cmFkZXNoaWZ0XCI7XG4gICAgT0F1dGhQcm92aWRlcltcIlRyYWRlc2hpZnRCb3hcIl0gPSBcInRyYWRlc2hpZnRCb3hcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiVHdpdGNoXCJdID0gXCJ0d2l0Y2hcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiV29yZHByZXNzXCJdID0gXCJ3b3JkcHJlc3NcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiWWFob29cIl0gPSBcInlhaG9vXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIllhbW1lclwiXSA9IFwieWFtbWVyXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIllhbmRleFwiXSA9IFwieWFuZGV4XCI7XG4gICAgT0F1dGhQcm92aWRlcltcIlpvaG9cIl0gPSBcInpvaG9cIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiWm9vbVwiXSA9IFwiem9vbVwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJNb2NrXCJdID0gXCJtb2NrXCI7XG59KShPQXV0aFByb3ZpZGVyIHx8IChPQXV0aFByb3ZpZGVyID0ge30pKTtcblxudmFyIEJyb3dzZXI7XG4oZnVuY3Rpb24gKEJyb3dzZXIpIHtcbiAgICBCcm93c2VyW1wiQXZhbnRCcm93c2VyXCJdID0gXCJhYVwiO1xuICAgIEJyb3dzZXJbXCJBbmRyb2lkV2ViVmlld0JldGFcIl0gPSBcImFuXCI7XG4gICAgQnJvd3NlcltcIkdvb2dsZUNocm9tZVwiXSA9IFwiY2hcIjtcbiAgICBCcm93c2VyW1wiR29vZ2xlQ2hyb21lSU9TXCJdID0gXCJjaVwiO1xuICAgIEJyb3dzZXJbXCJHb29nbGVDaHJvbWVNb2JpbGVcIl0gPSBcImNtXCI7XG4gICAgQnJvd3NlcltcIkNocm9taXVtXCJdID0gXCJjclwiO1xuICAgIEJyb3dzZXJbXCJNb3ppbGxhRmlyZWZveFwiXSA9IFwiZmZcIjtcbiAgICBCcm93c2VyW1wiU2FmYXJpXCJdID0gXCJzZlwiO1xuICAgIEJyb3dzZXJbXCJNb2JpbGVTYWZhcmlcIl0gPSBcIm1mXCI7XG4gICAgQnJvd3NlcltcIk1pY3Jvc29mdEVkZ2VcIl0gPSBcInBzXCI7XG4gICAgQnJvd3NlcltcIk1pY3Jvc29mdEVkZ2VJT1NcIl0gPSBcIm9pXCI7XG4gICAgQnJvd3NlcltcIk9wZXJhTWluaVwiXSA9IFwib21cIjtcbiAgICBCcm93c2VyW1wiT3BlcmFcIl0gPSBcIm9wXCI7XG4gICAgQnJvd3NlcltcIk9wZXJhTmV4dFwiXSA9IFwib25cIjtcbn0pKEJyb3dzZXIgfHwgKEJyb3dzZXIgPSB7fSkpO1xuXG52YXIgQ3JlZGl0Q2FyZDtcbihmdW5jdGlvbiAoQ3JlZGl0Q2FyZCkge1xuICAgIENyZWRpdENhcmRbXCJBbWVyaWNhbkV4cHJlc3NcIl0gPSBcImFtZXhcIjtcbiAgICBDcmVkaXRDYXJkW1wiQXJnZW5jYXJkXCJdID0gXCJhcmdlbmNhcmRcIjtcbiAgICBDcmVkaXRDYXJkW1wiQ2FiYWxcIl0gPSBcImNhYmFsXCI7XG4gICAgQ3JlZGl0Q2FyZFtcIkNlbmNvc3VkXCJdID0gXCJjZW5jb3N1ZFwiO1xuICAgIENyZWRpdENhcmRbXCJEaW5lcnNDbHViXCJdID0gXCJkaW5lcnNcIjtcbiAgICBDcmVkaXRDYXJkW1wiRGlzY292ZXJcIl0gPSBcImRpc2NvdmVyXCI7XG4gICAgQ3JlZGl0Q2FyZFtcIkVsb1wiXSA9IFwiZWxvXCI7XG4gICAgQ3JlZGl0Q2FyZFtcIkhpcGVyY2FyZFwiXSA9IFwiaGlwZXJjYXJkXCI7XG4gICAgQ3JlZGl0Q2FyZFtcIkpDQlwiXSA9IFwiamNiXCI7XG4gICAgQ3JlZGl0Q2FyZFtcIk1hc3RlcmNhcmRcIl0gPSBcIm1hc3RlcmNhcmRcIjtcbiAgICBDcmVkaXRDYXJkW1wiTmFyYW5qYVwiXSA9IFwibmFyYW5qYVwiO1xuICAgIENyZWRpdENhcmRbXCJUYXJqZXRhU2hvcHBpbmdcIl0gPSBcInRhcmdldGEtc2hvcHBpbmdcIjtcbiAgICBDcmVkaXRDYXJkW1wiVW5pb25DaGluYVBheVwiXSA9IFwidW5pb24tY2hpbmEtcGF5XCI7XG4gICAgQ3JlZGl0Q2FyZFtcIlZpc2FcIl0gPSBcInZpc2FcIjtcbiAgICBDcmVkaXRDYXJkW1wiTUlSXCJdID0gXCJtaXJcIjtcbiAgICBDcmVkaXRDYXJkW1wiTWFlc3Ryb1wiXSA9IFwibWFlc3Ryb1wiO1xufSkoQ3JlZGl0Q2FyZCB8fCAoQ3JlZGl0Q2FyZCA9IHt9KSk7XG5cbnZhciBGbGFnO1xuKGZ1bmN0aW9uIChGbGFnKSB7XG4gICAgRmxhZ1tcIkFmZ2hhbmlzdGFuXCJdID0gXCJhZlwiO1xuICAgIEZsYWdbXCJBbmdvbGFcIl0gPSBcImFvXCI7XG4gICAgRmxhZ1tcIkFsYmFuaWFcIl0gPSBcImFsXCI7XG4gICAgRmxhZ1tcIkFuZG9ycmFcIl0gPSBcImFkXCI7XG4gICAgRmxhZ1tcIlVuaXRlZEFyYWJFbWlyYXRlc1wiXSA9IFwiYWVcIjtcbiAgICBGbGFnW1wiQXJnZW50aW5hXCJdID0gXCJhclwiO1xuICAgIEZsYWdbXCJBcm1lbmlhXCJdID0gXCJhbVwiO1xuICAgIEZsYWdbXCJBbnRpZ3VhQW5kQmFyYnVkYVwiXSA9IFwiYWdcIjtcbiAgICBGbGFnW1wiQXVzdHJhbGlhXCJdID0gXCJhdVwiO1xuICAgIEZsYWdbXCJBdXN0cmlhXCJdID0gXCJhdFwiO1xuICAgIEZsYWdbXCJBemVyYmFpamFuXCJdID0gXCJhelwiO1xuICAgIEZsYWdbXCJCdXJ1bmRpXCJdID0gXCJiaVwiO1xuICAgIEZsYWdbXCJCZWxnaXVtXCJdID0gXCJiZVwiO1xuICAgIEZsYWdbXCJCZW5pblwiXSA9IFwiYmpcIjtcbiAgICBGbGFnW1wiQnVya2luYUZhc29cIl0gPSBcImJmXCI7XG4gICAgRmxhZ1tcIkJhbmdsYWRlc2hcIl0gPSBcImJkXCI7XG4gICAgRmxhZ1tcIkJ1bGdhcmlhXCJdID0gXCJiZ1wiO1xuICAgIEZsYWdbXCJCYWhyYWluXCJdID0gXCJiaFwiO1xuICAgIEZsYWdbXCJCYWhhbWFzXCJdID0gXCJic1wiO1xuICAgIEZsYWdbXCJCb3NuaWFBbmRIZXJ6ZWdvdmluYVwiXSA9IFwiYmFcIjtcbiAgICBGbGFnW1wiQmVsYXJ1c1wiXSA9IFwiYnlcIjtcbiAgICBGbGFnW1wiQmVsaXplXCJdID0gXCJielwiO1xuICAgIEZsYWdbXCJCb2xpdmlhXCJdID0gXCJib1wiO1xuICAgIEZsYWdbXCJCcmF6aWxcIl0gPSBcImJyXCI7XG4gICAgRmxhZ1tcIkJhcmJhZG9zXCJdID0gXCJiYlwiO1xuICAgIEZsYWdbXCJCcnVuZWlEYXJ1c3NhbGFtXCJdID0gXCJiblwiO1xuICAgIEZsYWdbXCJCaHV0YW5cIl0gPSBcImJ0XCI7XG4gICAgRmxhZ1tcIkJvdHN3YW5hXCJdID0gXCJid1wiO1xuICAgIEZsYWdbXCJDZW50cmFsQWZyaWNhblJlcHVibGljXCJdID0gXCJjZlwiO1xuICAgIEZsYWdbXCJDYW5hZGFcIl0gPSBcImNhXCI7XG4gICAgRmxhZ1tcIlN3aXR6ZXJsYW5kXCJdID0gXCJjaFwiO1xuICAgIEZsYWdbXCJDaGlsZVwiXSA9IFwiY2xcIjtcbiAgICBGbGFnW1wiQ2hpbmFcIl0gPSBcImNuXCI7XG4gICAgRmxhZ1tcIkNvdGVESXZvaXJlXCJdID0gXCJjaVwiO1xuICAgIEZsYWdbXCJDYW1lcm9vblwiXSA9IFwiY21cIjtcbiAgICBGbGFnW1wiRGVtb2NyYXRpY1JlcHVibGljT2ZUaGVDb25nb1wiXSA9IFwiY2RcIjtcbiAgICBGbGFnW1wiUmVwdWJsaWNPZlRoZUNvbmdvXCJdID0gXCJjZ1wiO1xuICAgIEZsYWdbXCJDb2xvbWJpYVwiXSA9IFwiY29cIjtcbiAgICBGbGFnW1wiQ29tb3Jvc1wiXSA9IFwia21cIjtcbiAgICBGbGFnW1wiQ2FwZVZlcmRlXCJdID0gXCJjdlwiO1xuICAgIEZsYWdbXCJDb3N0YVJpY2FcIl0gPSBcImNyXCI7XG4gICAgRmxhZ1tcIkN1YmFcIl0gPSBcImN1XCI7XG4gICAgRmxhZ1tcIkN5cHJ1c1wiXSA9IFwiY3lcIjtcbiAgICBGbGFnW1wiQ3plY2hSZXB1YmxpY1wiXSA9IFwiY3pcIjtcbiAgICBGbGFnW1wiR2VybWFueVwiXSA9IFwiZGVcIjtcbiAgICBGbGFnW1wiRGppYm91dGlcIl0gPSBcImRqXCI7XG4gICAgRmxhZ1tcIkRvbWluaWNhXCJdID0gXCJkbVwiO1xuICAgIEZsYWdbXCJEZW5tYXJrXCJdID0gXCJka1wiO1xuICAgIEZsYWdbXCJEb21pbmljYW5SZXB1YmxpY1wiXSA9IFwiZG9cIjtcbiAgICBGbGFnW1wiQWxnZXJpYVwiXSA9IFwiZHpcIjtcbiAgICBGbGFnW1wiRWN1YWRvclwiXSA9IFwiZWNcIjtcbiAgICBGbGFnW1wiRWd5cHRcIl0gPSBcImVnXCI7XG4gICAgRmxhZ1tcIkVyaXRyZWFcIl0gPSBcImVyXCI7XG4gICAgRmxhZ1tcIlNwYWluXCJdID0gXCJlc1wiO1xuICAgIEZsYWdbXCJFc3RvbmlhXCJdID0gXCJlZVwiO1xuICAgIEZsYWdbXCJFdGhpb3BpYVwiXSA9IFwiZXRcIjtcbiAgICBGbGFnW1wiRmlubGFuZFwiXSA9IFwiZmlcIjtcbiAgICBGbGFnW1wiRmlqaVwiXSA9IFwiZmpcIjtcbiAgICBGbGFnW1wiRnJhbmNlXCJdID0gXCJmclwiO1xuICAgIEZsYWdbXCJNaWNyb25lc2lhRmVkZXJhdGVkU3RhdGVzT2ZcIl0gPSBcImZtXCI7XG4gICAgRmxhZ1tcIkdhYm9uXCJdID0gXCJnYVwiO1xuICAgIEZsYWdbXCJVbml0ZWRLaW5nZG9tXCJdID0gXCJnYlwiO1xuICAgIEZsYWdbXCJHZW9yZ2lhXCJdID0gXCJnZVwiO1xuICAgIEZsYWdbXCJHaGFuYVwiXSA9IFwiZ2hcIjtcbiAgICBGbGFnW1wiR3VpbmVhXCJdID0gXCJnblwiO1xuICAgIEZsYWdbXCJHYW1iaWFcIl0gPSBcImdtXCI7XG4gICAgRmxhZ1tcIkd1aW5lYUJpc3NhdVwiXSA9IFwiZ3dcIjtcbiAgICBGbGFnW1wiRXF1YXRvcmlhbEd1aW5lYVwiXSA9IFwiZ3FcIjtcbiAgICBGbGFnW1wiR3JlZWNlXCJdID0gXCJnclwiO1xuICAgIEZsYWdbXCJHcmVuYWRhXCJdID0gXCJnZFwiO1xuICAgIEZsYWdbXCJHdWF0ZW1hbGFcIl0gPSBcImd0XCI7XG4gICAgRmxhZ1tcIkd1eWFuYVwiXSA9IFwiZ3lcIjtcbiAgICBGbGFnW1wiSG9uZHVyYXNcIl0gPSBcImhuXCI7XG4gICAgRmxhZ1tcIkNyb2F0aWFcIl0gPSBcImhyXCI7XG4gICAgRmxhZ1tcIkhhaXRpXCJdID0gXCJodFwiO1xuICAgIEZsYWdbXCJIdW5nYXJ5XCJdID0gXCJodVwiO1xuICAgIEZsYWdbXCJJbmRvbmVzaWFcIl0gPSBcImlkXCI7XG4gICAgRmxhZ1tcIkluZGlhXCJdID0gXCJpblwiO1xuICAgIEZsYWdbXCJJcmVsYW5kXCJdID0gXCJpZVwiO1xuICAgIEZsYWdbXCJJcmFuSXNsYW1pY1JlcHVibGljT2ZcIl0gPSBcImlyXCI7XG4gICAgRmxhZ1tcIklyYXFcIl0gPSBcImlxXCI7XG4gICAgRmxhZ1tcIkljZWxhbmRcIl0gPSBcImlzXCI7XG4gICAgRmxhZ1tcIklzcmFlbFwiXSA9IFwiaWxcIjtcbiAgICBGbGFnW1wiSXRhbHlcIl0gPSBcIml0XCI7XG4gICAgRmxhZ1tcIkphbWFpY2FcIl0gPSBcImptXCI7XG4gICAgRmxhZ1tcIkpvcmRhblwiXSA9IFwiam9cIjtcbiAgICBGbGFnW1wiSmFwYW5cIl0gPSBcImpwXCI7XG4gICAgRmxhZ1tcIkthemFraHN0YW5cIl0gPSBcImt6XCI7XG4gICAgRmxhZ1tcIktlbnlhXCJdID0gXCJrZVwiO1xuICAgIEZsYWdbXCJLeXJneXpzdGFuXCJdID0gXCJrZ1wiO1xuICAgIEZsYWdbXCJDYW1ib2RpYVwiXSA9IFwia2hcIjtcbiAgICBGbGFnW1wiS2lyaWJhdGlcIl0gPSBcImtpXCI7XG4gICAgRmxhZ1tcIlNhaW50S2l0dHNBbmROZXZpc1wiXSA9IFwia25cIjtcbiAgICBGbGFnW1wiU291dGhLb3JlYVwiXSA9IFwia3JcIjtcbiAgICBGbGFnW1wiS3V3YWl0XCJdID0gXCJrd1wiO1xuICAgIEZsYWdbXCJMYW9QZW9wbGVTRGVtb2NyYXRpY1JlcHVibGljXCJdID0gXCJsYVwiO1xuICAgIEZsYWdbXCJMZWJhbm9uXCJdID0gXCJsYlwiO1xuICAgIEZsYWdbXCJMaWJlcmlhXCJdID0gXCJsclwiO1xuICAgIEZsYWdbXCJMaWJ5YVwiXSA9IFwibHlcIjtcbiAgICBGbGFnW1wiU2FpbnRMdWNpYVwiXSA9IFwibGNcIjtcbiAgICBGbGFnW1wiTGllY2h0ZW5zdGVpblwiXSA9IFwibGlcIjtcbiAgICBGbGFnW1wiU3JpTGFua2FcIl0gPSBcImxrXCI7XG4gICAgRmxhZ1tcIkxlc290aG9cIl0gPSBcImxzXCI7XG4gICAgRmxhZ1tcIkxpdGh1YW5pYVwiXSA9IFwibHRcIjtcbiAgICBGbGFnW1wiTHV4ZW1ib3VyZ1wiXSA9IFwibHVcIjtcbiAgICBGbGFnW1wiTGF0dmlhXCJdID0gXCJsdlwiO1xuICAgIEZsYWdbXCJNb3JvY2NvXCJdID0gXCJtYVwiO1xuICAgIEZsYWdbXCJNb25hY29cIl0gPSBcIm1jXCI7XG4gICAgRmxhZ1tcIk1vbGRvdmFcIl0gPSBcIm1kXCI7XG4gICAgRmxhZ1tcIk1hZGFnYXNjYXJcIl0gPSBcIm1nXCI7XG4gICAgRmxhZ1tcIk1hbGRpdmVzXCJdID0gXCJtdlwiO1xuICAgIEZsYWdbXCJNZXhpY29cIl0gPSBcIm14XCI7XG4gICAgRmxhZ1tcIk1hcnNoYWxsSXNsYW5kc1wiXSA9IFwibWhcIjtcbiAgICBGbGFnW1wiTm9ydGhNYWNlZG9uaWFcIl0gPSBcIm1rXCI7XG4gICAgRmxhZ1tcIk1hbGlcIl0gPSBcIm1sXCI7XG4gICAgRmxhZ1tcIk1hbHRhXCJdID0gXCJtdFwiO1xuICAgIEZsYWdbXCJNeWFubWFyXCJdID0gXCJtbVwiO1xuICAgIEZsYWdbXCJNb250ZW5lZ3JvXCJdID0gXCJtZVwiO1xuICAgIEZsYWdbXCJNb25nb2xpYVwiXSA9IFwibW5cIjtcbiAgICBGbGFnW1wiTW96YW1iaXF1ZVwiXSA9IFwibXpcIjtcbiAgICBGbGFnW1wiTWF1cml0YW5pYVwiXSA9IFwibXJcIjtcbiAgICBGbGFnW1wiTWF1cml0aXVzXCJdID0gXCJtdVwiO1xuICAgIEZsYWdbXCJNYWxhd2lcIl0gPSBcIm13XCI7XG4gICAgRmxhZ1tcIk1hbGF5c2lhXCJdID0gXCJteVwiO1xuICAgIEZsYWdbXCJOYW1pYmlhXCJdID0gXCJuYVwiO1xuICAgIEZsYWdbXCJOaWdlclwiXSA9IFwibmVcIjtcbiAgICBGbGFnW1wiTmlnZXJpYVwiXSA9IFwibmdcIjtcbiAgICBGbGFnW1wiTmljYXJhZ3VhXCJdID0gXCJuaVwiO1xuICAgIEZsYWdbXCJOZXRoZXJsYW5kc1wiXSA9IFwibmxcIjtcbiAgICBGbGFnW1wiTm9yd2F5XCJdID0gXCJub1wiO1xuICAgIEZsYWdbXCJOZXBhbFwiXSA9IFwibnBcIjtcbiAgICBGbGFnW1wiTmF1cnVcIl0gPSBcIm5yXCI7XG4gICAgRmxhZ1tcIk5ld1plYWxhbmRcIl0gPSBcIm56XCI7XG4gICAgRmxhZ1tcIk9tYW5cIl0gPSBcIm9tXCI7XG4gICAgRmxhZ1tcIlBha2lzdGFuXCJdID0gXCJwa1wiO1xuICAgIEZsYWdbXCJQYW5hbWFcIl0gPSBcInBhXCI7XG4gICAgRmxhZ1tcIlBlcnVcIl0gPSBcInBlXCI7XG4gICAgRmxhZ1tcIlBoaWxpcHBpbmVzXCJdID0gXCJwaFwiO1xuICAgIEZsYWdbXCJQYWxhdVwiXSA9IFwicHdcIjtcbiAgICBGbGFnW1wiUGFwdWFOZXdHdWluZWFcIl0gPSBcInBnXCI7XG4gICAgRmxhZ1tcIlBvbGFuZFwiXSA9IFwicGxcIjtcbiAgICBGbGFnW1wiRnJlbmNoUG9seW5lc2lhXCJdID0gXCJwZlwiO1xuICAgIEZsYWdbXCJOb3J0aEtvcmVhXCJdID0gXCJrcFwiO1xuICAgIEZsYWdbXCJQb3J0dWdhbFwiXSA9IFwicHRcIjtcbiAgICBGbGFnW1wiUGFyYWd1YXlcIl0gPSBcInB5XCI7XG4gICAgRmxhZ1tcIlFhdGFyXCJdID0gXCJxYVwiO1xuICAgIEZsYWdbXCJSb21hbmlhXCJdID0gXCJyb1wiO1xuICAgIEZsYWdbXCJSdXNzaWFcIl0gPSBcInJ1XCI7XG4gICAgRmxhZ1tcIlJ3YW5kYVwiXSA9IFwicndcIjtcbiAgICBGbGFnW1wiU2F1ZGlBcmFiaWFcIl0gPSBcInNhXCI7XG4gICAgRmxhZ1tcIlN1ZGFuXCJdID0gXCJzZFwiO1xuICAgIEZsYWdbXCJTZW5lZ2FsXCJdID0gXCJzblwiO1xuICAgIEZsYWdbXCJTaW5nYXBvcmVcIl0gPSBcInNnXCI7XG4gICAgRmxhZ1tcIlNvbG9tb25Jc2xhbmRzXCJdID0gXCJzYlwiO1xuICAgIEZsYWdbXCJTaWVycmFMZW9uZVwiXSA9IFwic2xcIjtcbiAgICBGbGFnW1wiRWxTYWx2YWRvclwiXSA9IFwic3ZcIjtcbiAgICBGbGFnW1wiU2FuTWFyaW5vXCJdID0gXCJzbVwiO1xuICAgIEZsYWdbXCJTb21hbGlhXCJdID0gXCJzb1wiO1xuICAgIEZsYWdbXCJTZXJiaWFcIl0gPSBcInJzXCI7XG4gICAgRmxhZ1tcIlNvdXRoU3VkYW5cIl0gPSBcInNzXCI7XG4gICAgRmxhZ1tcIlNhb1RvbWVBbmRQcmluY2lwZVwiXSA9IFwic3RcIjtcbiAgICBGbGFnW1wiU3VyaW5hbWVcIl0gPSBcInNyXCI7XG4gICAgRmxhZ1tcIlNsb3Zha2lhXCJdID0gXCJza1wiO1xuICAgIEZsYWdbXCJTbG92ZW5pYVwiXSA9IFwic2lcIjtcbiAgICBGbGFnW1wiU3dlZGVuXCJdID0gXCJzZVwiO1xuICAgIEZsYWdbXCJFc3dhdGluaVwiXSA9IFwic3pcIjtcbiAgICBGbGFnW1wiU2V5Y2hlbGxlc1wiXSA9IFwic2NcIjtcbiAgICBGbGFnW1wiU3lyaWFcIl0gPSBcInN5XCI7XG4gICAgRmxhZ1tcIkNoYWRcIl0gPSBcInRkXCI7XG4gICAgRmxhZ1tcIlRvZ29cIl0gPSBcInRnXCI7XG4gICAgRmxhZ1tcIlRoYWlsYW5kXCJdID0gXCJ0aFwiO1xuICAgIEZsYWdbXCJUYWppa2lzdGFuXCJdID0gXCJ0alwiO1xuICAgIEZsYWdbXCJUdXJrbWVuaXN0YW5cIl0gPSBcInRtXCI7XG4gICAgRmxhZ1tcIlRpbW9yTGVzdGVcIl0gPSBcInRsXCI7XG4gICAgRmxhZ1tcIlRvbmdhXCJdID0gXCJ0b1wiO1xuICAgIEZsYWdbXCJUcmluaWRhZEFuZFRvYmFnb1wiXSA9IFwidHRcIjtcbiAgICBGbGFnW1wiVHVuaXNpYVwiXSA9IFwidG5cIjtcbiAgICBGbGFnW1wiVHVya2V5XCJdID0gXCJ0clwiO1xuICAgIEZsYWdbXCJUdXZhbHVcIl0gPSBcInR2XCI7XG4gICAgRmxhZ1tcIlRhbnphbmlhXCJdID0gXCJ0elwiO1xuICAgIEZsYWdbXCJVZ2FuZGFcIl0gPSBcInVnXCI7XG4gICAgRmxhZ1tcIlVrcmFpbmVcIl0gPSBcInVhXCI7XG4gICAgRmxhZ1tcIlVydWd1YXlcIl0gPSBcInV5XCI7XG4gICAgRmxhZ1tcIlVuaXRlZFN0YXRlc1wiXSA9IFwidXNcIjtcbiAgICBGbGFnW1wiVXpiZWtpc3RhblwiXSA9IFwidXpcIjtcbiAgICBGbGFnW1wiVmF0aWNhbkNpdHlcIl0gPSBcInZhXCI7XG4gICAgRmxhZ1tcIlNhaW50VmluY2VudEFuZFRoZUdyZW5hZGluZXNcIl0gPSBcInZjXCI7XG4gICAgRmxhZ1tcIlZlbmV6dWVsYVwiXSA9IFwidmVcIjtcbiAgICBGbGFnW1wiVmlldG5hbVwiXSA9IFwidm5cIjtcbiAgICBGbGFnW1wiVmFudWF0dVwiXSA9IFwidnVcIjtcbiAgICBGbGFnW1wiU2Ftb2FcIl0gPSBcIndzXCI7XG4gICAgRmxhZ1tcIlllbWVuXCJdID0gXCJ5ZVwiO1xuICAgIEZsYWdbXCJTb3V0aEFmcmljYVwiXSA9IFwiemFcIjtcbiAgICBGbGFnW1wiWmFtYmlhXCJdID0gXCJ6bVwiO1xuICAgIEZsYWdbXCJaaW1iYWJ3ZVwiXSA9IFwiendcIjtcbn0pKEZsYWcgfHwgKEZsYWcgPSB7fSkpO1xuXG52YXIgRXhlY3V0aW9uTWV0aG9kO1xuKGZ1bmN0aW9uIChFeGVjdXRpb25NZXRob2QpIHtcbiAgICBFeGVjdXRpb25NZXRob2RbXCJHRVRcIl0gPSBcIkdFVFwiO1xuICAgIEV4ZWN1dGlvbk1ldGhvZFtcIlBPU1RcIl0gPSBcIlBPU1RcIjtcbiAgICBFeGVjdXRpb25NZXRob2RbXCJQVVRcIl0gPSBcIlBVVFwiO1xuICAgIEV4ZWN1dGlvbk1ldGhvZFtcIlBBVENIXCJdID0gXCJQQVRDSFwiO1xuICAgIEV4ZWN1dGlvbk1ldGhvZFtcIkRFTEVURVwiXSA9IFwiREVMRVRFXCI7XG4gICAgRXhlY3V0aW9uTWV0aG9kW1wiT1BUSU9OU1wiXSA9IFwiT1BUSU9OU1wiO1xufSkoRXhlY3V0aW9uTWV0aG9kIHx8IChFeGVjdXRpb25NZXRob2QgPSB7fSkpO1xuXG52YXIgSW1hZ2VHcmF2aXR5O1xuKGZ1bmN0aW9uIChJbWFnZUdyYXZpdHkpIHtcbiAgICBJbWFnZUdyYXZpdHlbXCJDZW50ZXJcIl0gPSBcImNlbnRlclwiO1xuICAgIEltYWdlR3Jhdml0eVtcIlRvcGxlZnRcIl0gPSBcInRvcC1sZWZ0XCI7XG4gICAgSW1hZ2VHcmF2aXR5W1wiVG9wXCJdID0gXCJ0b3BcIjtcbiAgICBJbWFnZUdyYXZpdHlbXCJUb3ByaWdodFwiXSA9IFwidG9wLXJpZ2h0XCI7XG4gICAgSW1hZ2VHcmF2aXR5W1wiTGVmdFwiXSA9IFwibGVmdFwiO1xuICAgIEltYWdlR3Jhdml0eVtcIlJpZ2h0XCJdID0gXCJyaWdodFwiO1xuICAgIEltYWdlR3Jhdml0eVtcIkJvdHRvbWxlZnRcIl0gPSBcImJvdHRvbS1sZWZ0XCI7XG4gICAgSW1hZ2VHcmF2aXR5W1wiQm90dG9tXCJdID0gXCJib3R0b21cIjtcbiAgICBJbWFnZUdyYXZpdHlbXCJCb3R0b21yaWdodFwiXSA9IFwiYm90dG9tLXJpZ2h0XCI7XG59KShJbWFnZUdyYXZpdHkgfHwgKEltYWdlR3Jhdml0eSA9IHt9KSk7XG5cbnZhciBJbWFnZUZvcm1hdDtcbihmdW5jdGlvbiAoSW1hZ2VGb3JtYXQpIHtcbiAgICBJbWFnZUZvcm1hdFtcIkpwZ1wiXSA9IFwianBnXCI7XG4gICAgSW1hZ2VGb3JtYXRbXCJKcGVnXCJdID0gXCJqcGVnXCI7XG4gICAgSW1hZ2VGb3JtYXRbXCJHaWZcIl0gPSBcImdpZlwiO1xuICAgIEltYWdlRm9ybWF0W1wiUG5nXCJdID0gXCJwbmdcIjtcbiAgICBJbWFnZUZvcm1hdFtcIldlYnBcIl0gPSBcIndlYnBcIjtcbn0pKEltYWdlRm9ybWF0IHx8IChJbWFnZUZvcm1hdCA9IHt9KSk7XG5cbmV4cG9ydCB7IEFjY291bnQsIEFwcHdyaXRlRXhjZXB0aW9uLCBBdXRoZW50aWNhdGlvbkZhY3RvciwgQXV0aGVudGljYXRvclR5cGUsIEF2YXRhcnMsIEJyb3dzZXIsIENsaWVudCwgQ3JlZGl0Q2FyZCwgRGF0YWJhc2VzLCBFeGVjdXRpb25NZXRob2QsIEZsYWcsIEZ1bmN0aW9ucywgR3JhcGhxbCwgSUQsIEltYWdlRm9ybWF0LCBJbWFnZUdyYXZpdHksIExvY2FsZSwgTWVzc2FnaW5nLCBPQXV0aFByb3ZpZGVyLCBQZXJtaXNzaW9uLCBRdWVyeSwgUm9sZSwgU3RvcmFnZSwgVGVhbXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNkay5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/appwrite/dist/esm/sdk.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CSITRIX%5C%5COneDrive%5C%5C%D0%A0%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D0%B9%20%D1%81%D1%82%D0%BE%D0%BB%5C%5Cnetavto%5C%5C%D0%9D%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%BF%D0%B0%D0%BF%D0%BA%D0%B0%20(2)%5C%5Csport_club%5C%5Capp%5C%5CClientWrapper.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CSITRIX%5C%5COneDrive%5C%5C%D0%A0%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D0%B9%20%D1%81%D1%82%D0%BE%D0%BB%5C%5Cnetavto%5C%5C%D0%9D%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%BF%D0%B0%D0%BF%D0%BA%D0%B0%20(2)%5C%5Csport_club%5C%5Capp%5C%5Cglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CSITRIX%5C%5COneDrive%5C%5C%D0%A0%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D0%B9%20%D1%81%D1%82%D0%BE%D0%BB%5C%5Cnetavto%5C%5C%D0%9D%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%BF%D0%B0%D0%BF%D0%BA%D0%B0%20(2)%5C%5Csport_club%5C%5Capp%5C%5Cheader.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CSITRIX%5C%5COneDrive%5C%5C%D0%A0%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D0%B9%20%D1%81%D1%82%D0%BE%D0%BB%5C%5Cnetavto%5C%5C%D0%9D%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%BF%D0%B0%D0%BF%D0%BA%D0%B0%20(2)%5C%5Csport_club%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22app%5C%5C%5C%5Clayout.js%5C%22%2C%5C%22import%5C%22%3A%5C%22Inter%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22inter%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);